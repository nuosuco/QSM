#!/usr/bin/env qentl
# -*- coding: utf-8 -*-

"""
QSM主应用程序
量子自组织映射社交网络分析平台
"""

# 量子基因编码
QG-MAIN-QSM-SOCIAL-M1N0

# 量子纠缠信道
@quantum_entangle
  channel_id: QE-MAIN-QSM-20240501
  state: ACTIVE
  strength: 0.99
  objects: [
    "QSM/models/qsm_model.qentl",
    "QSM/api/qsm_api.qentl",
    "QSM/utils/qsm_utils.qentl",
    "QSM/services/qsm_service.qentl"
  ]

@imports
  standard: [os, sys, json, logging, time, datetime, argparse]
  quantum: [Dict, List, Any, Optional, Path]
  quantum_web: [fastapi, Depends, HTTPException, status, Request, Response, File, UploadFile]
  quantum_uvicorn: [uvicorn]
  quantum_internal: [
    "QSM/models/qsm_model.qentl" as qsm_model,
    "QSM/api/qsm_api.qentl" as qsm_api,
    "QSM/utils/qsm_utils.qentl" as qsm_utils,
    "QSM/services/qsm_service.qentl" as qsm_service
  ]

@constants
  ROOT_DIR = Path(os.path.dirname(os.path.abspath(__file__)))
  LOG_DIR = ROOT_DIR / 'logs'
  DATA_DIR = ROOT_DIR / 'data'
  PORT = 8000
  HOST = '127.0.0.1'
  API_VERSION = "1.0.0"
  
  # 应用配置
  APP_CONFIG = {
    'name': 'QSM - 量子自组织映射社交网络分析平台',
    'description': '基于量子编码和自组织映射的社交网络分析增强平台',
    'version': '1.0.0',
    'api_prefix': '/api/v1',
    'debug': True,
    'host': HOST,
    'port': PORT
  }

@initialization
  # 创建目录
  LOG_DIR.mkdir(exist_ok=True)
  DATA_DIR.mkdir(exist_ok=True, parents=True)
  
  # 配置日志
  logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - [%(levelname)s] - %(message)s',
    handlers=[
      logging.FileHandler(LOG_DIR / f'qsm_app_{datetime.datetime.now().strftime("%Y%m%d")}.log'),
      logging.StreamHandler()
    ]
  )
  logger = logging.getLogger('QSM-APP')
  
  # 创建FastAPI应用
  app = fastapi.FastAPI(
    title=APP_CONFIG['name'],
    description=APP_CONFIG['description'],
    version=APP_CONFIG['version']
  )
  
  # 创建QSM服务实例
  qsm_service_instance = qsm_service.create_qsm_service()
  
  # 注册API路由
  app.include_router(qsm_api.get_router(), prefix='/api/qsm')

@function parse_args() -> Dict[str, Any]:
  """解析命令行参数
  
  Returns:
      解析后的参数
  """
  parser = argparse.ArgumentParser(description='QSM - 量子自组织映射社交网络分析平台')
  
  parser.add_argument(
    '--host',
    type=str,
    default=HOST,
    help='服务主机地址'
  )
  
  parser.add_argument(
    '--port',
    type=int,
    default=PORT,
    help='服务端口'
  )
  
  parser.add_argument(
    '--debug',
    action='store_true',
    help='启用调试模式'
  )
  
  parser.add_argument(
    '--generate-data',
    action='store_true',
    help='生成测试数据'
  )
  
  parser.add_argument(
    '--train',
    action='store_true',
    help='训练模型'
  )
  
  return vars(parser.parse_args())

@function generate_test_data() -> str:
  """生成测试数据
  
  Returns:
      数据文件路径
  """
  logger.info("生成测试数据...")
  
  # 生成测试数据集
  dataset = qsm_utils.generate_test_dataset(
    user_count=50,
    feature_dim=8,
    connection_probability=0.3
  )
  
  # 导出数据
  timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
  filepath = os.path.join(DATA_DIR, f'test_data_{timestamp}.json')
  
  # 确保目录存在
  os.makedirs(os.path.dirname(filepath), exist_ok=True)
  
  # 保存数据
  with open(filepath, 'w', encoding='utf-8') as f:
    # 将numpy数组转换为列表
    features = {
      user_id: features.tolist() 
      for user_id, features in dataset['user_features'].items()
    }
    dataset['user_features'] = features
    
    json.dump(dataset, f, ensure_ascii=False, indent=2)
  
  logger.info(f"测试数据已保存到: {filepath}")
  return filepath

@function train_default_model(data_file: Optional[str] = None) -> None:
  """训练默认模型
  
  Args:
      data_file: 数据文件路径，如果为None则生成测试数据
  """
  # 如果没有提供数据文件，则生成测试数据
  if data_file is None:
    data_file = generate_test_data()
  
  # 加载数据
  logger.info(f"从{data_file}加载训练数据...")
  with open(data_file, 'r', encoding='utf-8') as f:
    data = json.load(f)
  
  # 将用户特征列表转换为numpy数组
  user_features = {
    user_id: np.array(features) 
    for user_id, features in data['user_features'].items()
  }
  
  # 提取特征向量用于训练
  training_data = list(user_features.values())
  
  # 训练模型
  logger.info(f"开始训练默认模型: 训练数据大小={len(training_data)}")
  result = qsm_service_instance.train_model(
    model_id=None,  # 使用默认模型
    data=training_data,
    iterations=500,
    async_mode=False
  )
  
  logger.info(f"训练完成: {result['message']}")

@function cleanup() -> None:
  """清理资源"""
  logger.info("正在清理资源...")
  qsm_service_instance.stop()
  logger.info("清理完成")

@route GET "/"
  @function(request: Request):
    """应用根端点"""
    return {
      'name': APP_CONFIG['name'],
      'description': APP_CONFIG['description'],
      'version': APP_CONFIG['version'],
      'api_prefix': APP_CONFIG['api_prefix'],
      'api_docs': f"http://{APP_CONFIG['host']}:{APP_CONFIG['port']}/docs",
      'timestamp': datetime.datetime.now().isoformat()
    }

@route GET "/health"
  @function():
    """健康检查端点"""
    return {
      'status': 'ok',
      'version': APP_CONFIG['version'],
      'timestamp': datetime.datetime.now().isoformat()
    }

@route GET "/info"
  @function():
    """获取应用信息"""
    default_model = qsm_service_instance.default_model
    
    return {
      'app': APP_CONFIG,
      'models': qsm_service_instance.list_models(),
      'default_model': default_model.to_dict() if default_model else None,
      'utils': {
        'available_functions': [
          'generate_feature_vector',
          'generate_user_features',
          'generate_random_connections',
          'calculate_network_metrics',
          'find_communities'
        ]
      },
      'timestamp': datetime.datetime.now().isoformat()
    }

@entrypoint
  """应用入口函数"""
  # 解析命令行参数
  args = parse_args()
  
  # 更新应用配置
  APP_CONFIG['host'] = args['host']
  APP_CONFIG['port'] = args['port']
  APP_CONFIG['debug'] = args['debug']
  
  # 处理生成数据参数
  if args['generate_data']:
    generate_test_data()
    
  # 处理训练模型参数
  if args['train']:
    train_default_model()
  
  try:
    # 注册清理函数
    import atexit
    atexit.register(cleanup)
    
    # 启动应用
    logger.info(f"启动应用: http://{APP_CONFIG['host']}:{APP_CONFIG['port']}")
    
    uvicorn.run(
      "main:app",
      host=APP_CONFIG['host'],
      port=APP_CONFIG['port'],
      reload=APP_CONFIG['debug']
    )
    
  except KeyboardInterrupt:
    logger.info("应用被用户中断")
    cleanup()
    
  except Exception as e:
    logger.error(f"应用出错: {str(e)}")
    cleanup()
    sys.exit(1) 