#!/usr/bin/env qpy
# -*- coding: utf-8 -*-

"""
QSM叠加态服务模块
提供QSM叠加态模型的服务功能
"""

# 量子基因编码
QG-SERVICE-QSM-SUPERPOSITION-S1P2

# 量子纠缠信道
@quantum_entangle
  channel_id: QE-SERVICE-QSM-SUPERPOSITION-20240405
  state: ACTIVE
  strength: 0.95
  objects: [
    "QSM/api/qsm_superposition_api.qpy",
    "QSM/models/qsm_superposition_model.qpy",
    "QSM/utils/qsm_superposition_utils.qpy"
  ]

@imports
  standard: [os, json, logging, time, datetime, threading]
  quantum: [Dict, List, Tuple, Any, Optional, Union, Path]
  quantum_internal: [
    "../api/qsm_superposition_api.qpy" as qsm_api,
    "../models/qsm_superposition_model.qpy" as qsm_model,
    "../utils/qsm_superposition_utils.qpy" as qsm_utils
  ]

@constants
  ROOT_DIR = Path(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
  LOG_DIR = ROOT_DIR / '.logs'
  DATA_DIR = ROOT_DIR / 'QSM' / 'data'
  SERVICE_PORT = 5001
  SERVICE_HOST = '127.0.0.1'
  
  # 任务类型
  TASK_TYPES = {
    'VECTOR_CREATION': '创建向量',
    'ENTANGLEMENT': '创建纠缠',
    'GROUP_ANALYSIS': '组分析',
    'TRANSFORMATION': '向量变换',
    'SUPERPOSITION': '创建叠加态',
    'COLLAPSE': '量子坍缩',
    'MODEL_SAVE': '保存模型',
    'MODEL_LOAD': '加载模型'
  }
  
  # 服务状态
  SERVICE_STATES = {
    'STARTING': '启动中',
    'RUNNING': '运行中',
    'STOPPING': '停止中',
    'STOPPED': '已停止',
    'ERROR': '错误'
  }

@initialization
  # 创建日志目录
  LOG_DIR.mkdir(exist_ok=True)
  DATA_DIR.mkdir(exist_ok=True, parents=True)
  
  # 配置日志
  logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - [%(levelname)s] - %(message)s',
    handlers=[
      logging.FileHandler(LOG_DIR / f'qsm_superposition_service_{datetime.datetime.now().strftime("%Y%m%d")}.log'),
      logging.StreamHandler()
    ]
  )
  logger = logging.getLogger('QSM-SUPERPOSITION-SERVICE')

@class Task:
  """任务类"""
  
  @constructor(task_id: str, task_type: str, params: Dict[str, Any])
    """初始化任务
    
    Args:
        task_id: 任务ID
        task_type: 任务类型
        params: 任务参数
    """
    self.task_id = task_id
    self.task_type = task_type
    self.params = params
    self.status = 'PENDING'
    self.result = None
    self.error = None
    self.created_at = datetime.datetime.now().isoformat()
    self.started_at = None
    self.completed_at = None
  
  @method start(self)
    """标记任务开始"""
    self.status = 'RUNNING'
    self.started_at = datetime.datetime.now().isoformat()
  
  @method complete(self, result: Any)
    """标记任务完成
    
    Args:
        result: 任务结果
    """
    self.status = 'COMPLETED'
    self.result = result
    self.completed_at = datetime.datetime.now().isoformat()
  
  @method fail(self, error: str)
    """标记任务失败
    
    Args:
        error: 错误信息
    """
    self.status = 'FAILED'
    self.error = error
    self.completed_at = datetime.datetime.now().isoformat()
  
  @method to_dict(self) -> Dict[str, Any]:
    """转换为字典
    
    Returns:
        任务字典表示
    """
    return {
      'task_id': self.task_id,
      'task_type': self.task_type,
      'task_type_name': TASK_TYPES.get(self.task_type, '未知任务'),
      'status': self.status,
      'params': self.params,
      'result': self.result,
      'error': self.error,
      'created_at': self.created_at,
      'started_at': self.started_at,
      'completed_at': self.completed_at,
      'duration': self._calculate_duration()
    }
  
  @method _calculate_duration(self) -> Optional[float]:
    """计算任务持续时间（秒）
    
    Returns:
        持续时间，如果任务未完成则为None
    """
    if not self.started_at:
      return None
    
    start_time = datetime.datetime.fromisoformat(self.started_at)
    
    if self.completed_at:
      end_time = datetime.datetime.fromisoformat(self.completed_at)
      return (end_time - start_time).total_seconds()
    else:
      current_time = datetime.datetime.now()
      return (current_time - start_time).total_seconds()

@class QSMSuperpositionService:
  """QSM叠加态服务类"""
  
  @constructor()
    """初始化服务"""
    self.api = qsm_api.get_api()
    self.tasks = {}  # {task_id: Task}
    self.task_queue = []  # [task_id]
    self.max_concurrent_tasks = 3
    self.running_tasks = 0
    self.status = SERVICE_STATES['STOPPED']
    self.start_time = None
    self.worker_thread = None
    self.lock = threading.Lock()
    
    # 服务配置
    self.config = {
      'auto_save_interval': 3600,  # 自动保存间隔（秒）
      'max_tasks_history': 100,  # 最大任务历史记录数
      'default_model_path': str(DATA_DIR / 'default_superposition_model.json')
    }
  
  @method start(self)
    """启动服务"""
    with self.lock:
      if self.status != SERVICE_STATES['STOPPED']:
        logger.warning(f"服务已在{self.status}状态，无法启动")
        return False
      
      logger.info("正在启动QSM叠加态服务...")
      self.status = SERVICE_STATES['STARTING']
      
      # 启动工作线程
      self.worker_thread = threading.Thread(target=self._process_tasks)
      self.worker_thread.daemon = True
      self.worker_thread.start()
      
      self.start_time = datetime.datetime.now().isoformat()
      self.status = SERVICE_STATES['RUNNING']
      logger.info("QSM叠加态服务已启动")
      return True
  
  @method stop(self)
    """停止服务"""
    with self.lock:
      if self.status != SERVICE_STATES['RUNNING']:
        logger.warning(f"服务当前为{self.status}状态，无法停止")
        return False
      
      logger.info("正在停止QSM叠加态服务...")
      self.status = SERVICE_STATES['STOPPING']
      
      # 等待工作线程完成当前任务
      if self.worker_thread and self.worker_thread.is_alive():
        self.worker_thread.join(timeout=10)
      
      self.status = SERVICE_STATES['STOPPED']
      logger.info("QSM叠加态服务已停止")
      return True
  
  @method _process_tasks(self)
    """处理任务队列"""
    logger.info("任务处理线程已启动")
    
    while self.status in [SERVICE_STATES['STARTING'], SERVICE_STATES['RUNNING']]:
      # 检查是否有待处理的任务
      with self.lock:
        if not self.task_queue or self.running_tasks >= self.max_concurrent_tasks:
          time.sleep(0.1)
          continue
        
        # 获取下一个任务
        task_id = self.task_queue.pop(0)
        task = self.tasks.get(task_id)
        
        if not task:
          logger.warning(f"任务{task_id}不存在")
          continue
        
        self.running_tasks += 1
      
      # 执行任务
      try:
        logger.info(f"开始执行任务: {task_id} ({task.task_type})")
        task.start()
        
        result = self._execute_task(task)
        task.complete(result)
        logger.info(f"任务完成: {task_id}")
        
      except Exception as e:
        logger.error(f"任务执行出错: {task_id}, 错误: {str(e)}")
        task.fail(str(e))
      finally:
        with self.lock:
          self.running_tasks -= 1
  
  @method _execute_task(self, task: Task) -> Any:
    """执行任务
    
    Args:
        task: 要执行的任务
        
    Returns:
        任务结果
    """
    if task.task_type == 'VECTOR_CREATION':
      return self.api.create_vector(
        vector_id=task.params.get('vector_id'),
        dimension=task.params.get('dimension'),
        sp_type=task.params.get('sp_type', 'QUANTUM')
      )
    
    elif task.task_type == 'ENTANGLEMENT':
      return self.api.create_entanglement(
        vector_id1=task.params.get('vector_id1'),
        vector_id2=task.params.get('vector_id2')
      )
    
    elif task.task_type == 'GROUP_ANALYSIS':
      return self.api.analyze_group(
        group_id=task.params.get('group_id')
      )
    
    elif task.task_type == 'TRANSFORMATION':
      return self.api.apply_transformation(
        vector_id=task.params.get('vector_id'),
        transformation_type=task.params.get('transformation_type'),
        params=task.params.get('params', {})
      )
    
    elif task.task_type == 'SUPERPOSITION':
      return self.api.create_superposition(
        vector_ids=task.params.get('vector_ids', []),
        weights=task.params.get('weights')
      )
    
    elif task.task_type == 'COLLAPSE':
      return self.api.collapse_vector(
        vector_id=task.params.get('vector_id'),
        method=task.params.get('method', 'OBSERVE')
      )
    
    elif task.task_type == 'MODEL_SAVE':
      return self.api.save_model(
        filepath=task.params.get('filepath')
      )
    
    elif task.task_type == 'MODEL_LOAD':
      return self.api.load_model(
        filepath=task.params.get('filepath')
      )
    
    else:
      raise ValueError(f"未知的任务类型: {task.task_type}")
  
  @method submit_task(self, task_type: str, params: Dict[str, Any]) -> str:
    """提交任务
    
    Args:
        task_type: 任务类型
        params: 任务参数
        
    Returns:
        任务ID
    """
    with self.lock:
      if self.status != SERVICE_STATES['RUNNING']:
        raise RuntimeError(f"服务当前为{self.status}状态，无法提交任务")
      
      # 创建任务ID
      task_id = f"task_{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}_{len(self.tasks)}"
      
      # 创建任务
      task = Task(task_id, task_type, params)
      self.tasks[task_id] = task
      
      # 添加到队列
      self.task_queue.append(task_id)
      
      # 清理历史任务
      self._cleanup_tasks()
      
      logger.info(f"提交任务: {task_id} ({task_type})")
      return task_id
  
  @method get_task(self, task_id: str) -> Optional[Dict[str, Any]]:
    """获取任务信息
    
    Args:
        task_id: 任务ID
        
    Returns:
        任务信息字典，如果任务不存在则返回None
    """
    with self.lock:
      task = self.tasks.get(task_id)
      if task:
        return task.to_dict()
      return None
  
  @method get_tasks(self, status: Optional[str] = None) -> List[Dict[str, Any]]:
    """获取任务列表
    
    Args:
        status: 过滤的任务状态
        
    Returns:
        任务列表
    """
    with self.lock:
      if status:
        tasks = [task for task in self.tasks.values() if task.status == status]
      else:
        tasks = list(self.tasks.values())
      
      # 按创建时间降序排序
      tasks.sort(key=lambda t: t.created_at, reverse=True)
      
      return [task.to_dict() for task in tasks]
  
  @method _cleanup_tasks(self)
    """清理历史任务"""
    if len(self.tasks) <= self.config['max_tasks_history']:
      return
    
    # 按创建时间排序
    task_items = sorted(self.tasks.items(), key=lambda x: x[1].created_at)
    
    # 计算要删除的数量
    to_remove = len(task_items) - self.config['max_tasks_history']
    
    # 删除最旧的已完成任务
    removed = 0
    for task_id, task in task_items:
      if task.status in ['COMPLETED', 'FAILED'] and removed < to_remove:
        del self.tasks[task_id]
        removed += 1
      
      if removed >= to_remove:
        break
  
  @method get_service_info(self) -> Dict[str, Any]:
    """获取服务信息
    
    Returns:
        服务信息
    """
    uptime_seconds = None
    if self.start_time:
      start_time = datetime.datetime.fromisoformat(self.start_time)
      uptime_seconds = (datetime.datetime.now() - start_time).total_seconds()
    
    with self.lock:
      return {
        'status': self.status,
        'start_time': self.start_time,
        'uptime_seconds': uptime_seconds,
        'tasks_total': len(self.tasks),
        'tasks_pending': len(self.task_queue),
        'tasks_running': self.running_tasks,
        'tasks_completed': len([t for t in self.tasks.values() if t.status == 'COMPLETED']),
        'tasks_failed': len([t for t in self.tasks.values() if t.status == 'FAILED']),
        'max_concurrent_tasks': self.max_concurrent_tasks,
        'config': self.config,
        'api_info': self.api.get_info().get('data', {})
      }
  
  @method update_config(self, new_config: Dict[str, Any]) -> Dict[str, Any]:
    """更新服务配置
    
    Args:
        new_config: 新配置
        
    Returns:
        更新后的配置
    """
    with self.lock:
      for key, value in new_config.items():
        if key in self.config:
          self.config[key] = value
      
      return self.config

# 创建服务实例
_service_instance = QSMSuperpositionService()

@function get_service() -> QSMSuperpositionService:
  """获取服务实例
  
  Returns:
      服务实例
  """
  return _service_instance

@function start_service() -> bool:
  """启动服务
  
  Returns:
      是否成功启动
  """
  return _service_instance.start()

@function stop_service() -> bool:
  """停止服务
  
  Returns:
      是否成功停止
  """
  return _service_instance.stop()

@entrypoint
  # 示例使用代码
  if __name__ == "__main__":
    import signal
    import sys
    
    # 处理终止信号
    def signal_handler(sig, frame):
      print("\n正在停止服务...")
      stop_service()
      sys.exit(0)
    
    signal.signal(signal.SIGINT, signal_handler)
    
    # 启动服务
    start_service()
    print("服务已启动，按Ctrl+C停止")
    
    # 创建一些测试任务
    service = get_service()
    
    # 创建向量任务
    vector_task = service.submit_task('VECTOR_CREATION', {
      'vector_id': 'test_vector_1',
      'sp_type': 'QUANTUM'
    })
    
    # 等待任务完成
    task_info = None
    while True:
      task_info = service.get_task(vector_task)
      if task_info['status'] in ['COMPLETED', 'FAILED']:
        break
      time.sleep(0.1)
    
    print(f"向量创建任务完成: {json.dumps(task_info, ensure_ascii=False)}")
    
    # 服务信息
    service_info = service.get_service_info()
    print(f"服务信息: {json.dumps(service_info, ensure_ascii=False, indent=2)}")
    
    # 持续运行
    while True:
      time.sleep(1) 