#!/usr/bin/env qpy
# -*- coding: utf-8 -*-

"""
QSM叠加态工具函数模块
提供用于操作和处理量子叠加态的实用工具
"""

# 量子基因编码
QG-UTILS-QSM-SUPERPOSITION-U4P3

# 量子纠缠信道
@quantum_entangle
  channel_id: QE-UTILS-QSM-SUPERPOSITION-20240405
  state: ACTIVE
  strength: 0.96
  objects: [
    "QSM/models/qsm_superposition_model.qpy",
    "QSM/api/qsm_api.qpy"
  ]

@imports
  standard: [os, json, logging, datetime, random, math, uuid]
  quantum: [Dict, List, Tuple, Any, Optional, Union, Path]
  quantum_math: [numpy as np]
  quantum_internal: [
    "../models/qsm_superposition_model.qpy" as qsm_superposition_model
  ]

@constants
  ROOT_DIR = Path(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
  LOG_DIR = ROOT_DIR / '.logs'
  DATA_DIR = ROOT_DIR / 'QSM' / 'data'
  CACHE_DIR = DATA_DIR / 'cache'
  
  # 复合叠加态类型
  COMPOSITE_TYPES = {
    'SUM': '求和叠加',
    'PRODUCT': '乘积叠加',
    'INTERFERENCE': '干涉叠加',
    'WEIGHTED': '加权叠加'
  }
  
  # 状态转换方式
  TRANSFORMATION_TYPES = {
    'ROTATION': '旋转变换',
    'PHASE_SHIFT': '相位变换',
    'SCALING': '缩放变换',
    'PROJECTION': '投影变换'
  }

@initialization
  # 创建目录
  LOG_DIR.mkdir(exist_ok=True)
  DATA_DIR.mkdir(exist_ok=True, parents=True)
  CACHE_DIR.mkdir(exist_ok=True, parents=True)
  
  # 配置日志
  logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - [%(levelname)s] - %(message)s',
    handlers=[
      logging.FileHandler(LOG_DIR / f'qsm_superposition_utils_{datetime.datetime.now().strftime("%Y%m%d")}.log'),
      logging.StreamHandler()
    ]
  )
  logger = logging.getLogger('QSM-SUPERPOSITION-UTILS')

@function create_random_vector(dimension: int = 8, sp_type: str = 'QUANTUM') -> qsm_superposition_model.SuperpositionVector:
  """创建随机叠加态向量
  
  Args:
      dimension: 向量维度
      sp_type: 叠加态类型
      
  Returns:
      创建的叠加态向量
  """
  vector = qsm_superposition_model.SuperpositionVector(dimension, sp_type)
  
  # 随机设置振幅和相位
  vector.amplitudes = np.random.random(dimension)
  vector.phases = np.random.uniform(0, 2 * math.pi, dimension)
  
  # 规范化
  vector._normalize()
  
  return vector

@function create_orthogonal_vectors(dimension: int, count: int) -> List[qsm_superposition_model.SuperpositionVector]:
  """创建一组正交的叠加态向量
  
  Args:
      dimension: 向量维度
      count: 向量数量
      
  Returns:
      正交向量列表
  """
  if count > dimension:
    raise ValueError(f"正交向量数量不能超过维度: {count} > {dimension}")
  
  vectors = []
  for i in range(count):
    vector = qsm_superposition_model.SuperpositionVector(dimension, 'QUANTUM')
    
    # 创建基向量 (单一维度为1，其余为0)
    vector.amplitudes = np.zeros(dimension)
    vector.amplitudes[i] = 1.0
    
    # 随机相位
    vector.phases = np.random.uniform(0, 2 * math.pi, dimension)
    
    # 设置为已规范化
    vector.normalized = True
    
    vectors.append(vector)
  
  return vectors

@function vector_superposition(
                          vectors: List[qsm_superposition_model.SuperpositionVector], 
                          weights: Optional[List[float]] = None,
                          composite_type: str = 'SUM') -> qsm_superposition_model.SuperpositionVector:
  """将多个向量组合为叠加态
  
  Args:
      vectors: 向量列表
      weights: 权重列表
      composite_type: 组合类型
      
  Returns:
      组合后的叠加态向量
  """
  if not vectors:
    raise ValueError("向量列表不能为空")
  
  # 检查维度
  dimension = vectors[0].dimension
  for v in vectors:
    if v.dimension != dimension:
      raise ValueError(f"向量维度不一致: {v.dimension} != {dimension}")
  
  # 标准化权重
  if weights is None:
    weights = [1.0 / len(vectors)] * len(vectors)
  else:
    if len(weights) != len(vectors):
      weights = weights[:len(vectors)]
      weights = weights + [0.0] * (len(vectors) - len(weights))
    
    # 确保权重和为1
    weight_sum = sum(weights)
    if weight_sum > 0:
      weights = [w / weight_sum for w in weights]
    else:
      weights = [1.0 / len(vectors)] * len(vectors)
  
  # 创建结果向量
  result = qsm_superposition_model.SuperpositionVector(dimension, 'HYBRID')
  
  if composite_type == 'SUM':
    # 求和叠加
    result.amplitudes = np.zeros(dimension)
    result.phases = np.zeros(dimension)
    
    for i, vector in enumerate(vectors):
      result.amplitudes += weights[i] * vector.amplitudes
      result.phases += weights[i] * vector.phases
      
  elif composite_type == 'PRODUCT':
    # 乘积叠加 (用于模拟量子门操作)
    result.amplitudes = np.ones(dimension)
    result.phases = np.zeros(dimension)
    
    for i, vector in enumerate(vectors):
      result.amplitudes *= vector.amplitudes ** weights[i]
      result.phases += vector.phases * weights[i]
      
  elif composite_type == 'INTERFERENCE':
    # 干涉叠加 (考虑相位干涉)
    result.amplitudes = np.zeros(dimension)
    result.phases = np.zeros(dimension)
    
    for i, vector in enumerate(vectors):
      # 使用复数表示带相位的振幅
      complex_amplitudes = vector.amplitudes * np.exp(1j * vector.phases)
      
      # 加权组合
      if i == 0:
        result_complex = weights[i] * complex_amplitudes
      else:
        result_complex += weights[i] * complex_amplitudes
    
    # 转换回振幅和相位
    result.amplitudes = np.abs(result_complex)
    result.phases = np.angle(result_complex)
    
  elif composite_type == 'WEIGHTED':
    # 加权叠加
    result.amplitudes = np.zeros(dimension)
    result.phases = np.zeros(dimension)
    
    # 在每个维度上找出权重最大的向量
    for d in range(dimension):
      max_weight_idx = np.argmax([w * v.amplitudes[d] for w, v in zip(weights, vectors)])
      result.amplitudes[d] = vectors[max_weight_idx].amplitudes[d]
      result.phases[d] = vectors[max_weight_idx].phases[d]
  
  # 规范化结果
  result._normalize()
  return result

@function transform_vector(
                      vector: qsm_superposition_model.SuperpositionVector,
                      transformation_type: str,
                      params: Dict[str, float]) -> qsm_superposition_model.SuperpositionVector:
  """变换叠加态向量
  
  Args:
      vector: 输入向量
      transformation_type: 变换类型
      params: 变换参数
      
  Returns:
      变换后的向量
  """
  if transformation_type not in TRANSFORMATION_TYPES:
    raise ValueError(f"无效的变换类型: {transformation_type}")
  
  result = qsm_superposition_model.SuperpositionVector(vector.dimension, vector.sp_type)
  result.amplitudes = vector.amplitudes.copy()
  result.phases = vector.phases.copy()
  
  if transformation_type == 'ROTATION':
    # 旋转变换 (需要角度参数)
    angle = params.get('angle', math.pi/4)  # 默认45度
    axis1 = params.get('axis1', 0)
    axis2 = params.get('axis2', 1)
    
    if axis1 < vector.dimension and axis2 < vector.dimension:
      # 在两个维度上执行旋转
      amp1, amp2 = result.amplitudes[axis1], result.amplitudes[axis2]
      result.amplitudes[axis1] = amp1 * math.cos(angle) - amp2 * math.sin(angle)
      result.amplitudes[axis2] = amp1 * math.sin(angle) + amp2 * math.cos(angle)
      
  elif transformation_type == 'PHASE_SHIFT':
    # 相位变换
    phase = params.get('phase', math.pi/2)  # 默认90度
    axis = params.get('axis', None)
    
    if axis is None:
      # 对所有维度应用相位变换
      result.phases = (result.phases + phase) % (2 * math.pi)
    else:
      # 对特定维度应用相位变换
      if axis < vector.dimension:
        result.phases[axis] = (result.phases[axis] + phase) % (2 * math.pi)
      
  elif transformation_type == 'SCALING':
    # 缩放变换
    scale = params.get('scale', 2.0)
    axis = params.get('axis', None)
    
    if axis is None:
      # 对所有振幅进行缩放
      result.amplitudes = result.amplitudes * scale
    else:
      # 对特定维度进行缩放
      if axis < vector.dimension:
        result.amplitudes[axis] = result.amplitudes[axis] * scale
        
  elif transformation_type == 'PROJECTION':
    # 投影变换 (向某个子空间的投影)
    dimensions = params.get('dimensions', [0])
    
    # 创建投影结果
    projection = np.zeros(vector.dimension)
    for dim in dimensions:
      if dim < vector.dimension:
        projection[dim] = result.amplitudes[dim]
    
    # 应用投影
    result.amplitudes = projection
  
  # 规范化结果
  result._normalize()
  return result

@function calculate_similarity(vector1: qsm_superposition_model.SuperpositionVector, 
                          vector2: qsm_superposition_model.SuperpositionVector) -> float:
  """计算两个叠加态向量的相似度
  
  Args:
      vector1: 第一个向量
      vector2: 第二个向量
      
  Returns:
      相似度分数 (0-1)
  """
  if vector1.dimension != vector2.dimension:
    raise ValueError(f"向量维度不匹配: {vector1.dimension} vs {vector2.dimension}")
  
  # 计算振幅的余弦相似度
  similarity = np.dot(vector1.amplitudes, vector2.amplitudes)
  
  # 考虑相位差异
  phase_diff = np.abs(vector1.phases - vector2.phases)
  phase_similarity = np.mean(np.cos(phase_diff))
  
  # 综合相似度 (振幅和相位)
  combined_similarity = (similarity + phase_similarity) / 2
  
  return max(0.0, min(1.0, combined_similarity))

@function calculate_entanglement_degree(vector1: qsm_superposition_model.SuperpositionVector, 
                                   vector2: qsm_superposition_model.SuperpositionVector) -> float:
  """计算两个向量间的潜在纠缠程度
  
  Args:
      vector1: 第一个向量
      vector2: 第二个向量
      
  Returns:
      纠缠程度分数 (0-1)
  """
  if vector1.dimension != vector2.dimension:
    raise ValueError(f"向量维度不匹配: {vector1.dimension} vs {vector2.dimension}")
  
  # 计算量子状态的潜在纠缠度
  # 1. 振幅互补性 (一个高另一个低)
  amplitude_complementarity = np.mean(np.abs(vector1.amplitudes - vector2.amplitudes))
  
  # 2. 相位相关性
  phase_correlation = np.abs(np.mean(np.exp(1j * (vector1.phases - vector2.phases))))
  
  # 3. 主导状态互补性
  dominant1 = vector1.dominant_state()
  dominant2 = vector2.dominant_state()
  state_complementarity = 1.0 if dominant1 != dominant2 else 0.0
  
  # 综合纠缠程度评分
  entanglement_score = (amplitude_complementarity + phase_correlation + state_complementarity) / 3
  
  return max(0.0, min(1.0, entanglement_score))

@function generate_test_vectors(count: int = 5, dimension: int = 8) -> Dict[str, qsm_superposition_model.SuperpositionVector]:
  """生成测试用的叠加态向量
  
  Args:
      count: 向量数量
      dimension: 向量维度
      
  Returns:
      向量字典 {vector_id: vector}
  """
  vectors = {}
  
  # 创建有不同特性的向量
  for i in range(count):
    vector_id = f"test_vector_{i}"
    
    if i == 0:
      # 均匀分布的向量
      vector = qsm_superposition_model.SuperpositionVector(dimension, 'QUANTUM')
      vector.amplitudes = np.ones(dimension) / np.sqrt(dimension)
      vector.phases = np.zeros(dimension)
      
    elif i == 1:
      # 主导单一状态的向量
      vector = qsm_superposition_model.SuperpositionVector(dimension, 'QUANTUM')
      vector.amplitudes = np.zeros(dimension)
      vector.amplitudes[0] = 1.0
      vector.phases = np.zeros(dimension)
      
    elif i == 2:
      # 两个主要状态的向量
      vector = qsm_superposition_model.SuperpositionVector(dimension, 'QUANTUM')
      vector.amplitudes = np.zeros(dimension)
      vector.amplitudes[0] = 0.7
      vector.amplitudes[1] = 0.7
      vector._normalize()
      vector.phases = np.random.uniform(0, 2 * math.pi, dimension)
      
    elif i == 3:
      # 随机振幅，一致相位
      vector = qsm_superposition_model.SuperpositionVector(dimension, 'QUANTUM')
      vector.amplitudes = np.random.random(dimension)
      vector._normalize()
      vector.phases = np.ones(dimension) * math.pi/4
      
    else:
      # 完全随机向量
      vector = create_random_vector(dimension)
    
    vectors[vector_id] = vector
  
  return vectors

@function visualize_vector(vector: qsm_superposition_model.SuperpositionVector) -> Dict[str, Any]:
  """创建向量的可视化数据
  
  Args:
      vector: 叠加态向量
      
  Returns:
      可视化数据字典
  """
  amplitude_data = []
  phase_data = []
  complex_data = []
  
  for i in range(vector.dimension):
    amplitude = vector.amplitudes[i]
    phase = vector.phases[i]
    
    amplitude_data.append({
      'index': i,
      'value': float(amplitude),
      'label': f"状态 {i}"
    })
    
    phase_data.append({
      'index': i,
      'value': float(phase),
      'label': f"状态 {i}"
    })
    
    # 复数表示
    complex_data.append({
      'index': i,
      'real': float(amplitude * math.cos(phase)),
      'imaginary': float(amplitude * math.sin(phase)),
      'label': f"状态 {i}"
    })
  
  return {
    'id': str(uuid.uuid4()),
    'dimension': vector.dimension,
    'type': vector.sp_type,
    'dominant_state': int(vector.dominant_state()),
    'coherence': float(vector.coherence()),
    'amplitude_data': amplitude_data,
    'phase_data': phase_data,
    'complex_data': complex_data,
    'created_at': datetime.datetime.now().isoformat()
  }

@function export_model_data(model: qsm_superposition_model.QSMSuperpositionModel, 
                       filepath: Optional[str] = None) -> str:
  """导出模型数据为JSON格式
  
  Args:
      model: 叠加态模型
      filepath: 导出路径，如果为None则自动生成
      
  Returns:
      导出文件路径
  """
  if filepath is None:
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    filepath = os.path.join(DATA_DIR, f'qsm_superposition_export_{timestamp}.json')
  
  # 准备导出数据
  export_data = {
    'model_info': model.to_dict(),
    'vectors': {
      vector_id: vector.to_dict() for vector_id, vector in model.vectors.items()
    },
    'groups': {
      group_id: vector_ids for group_id, vector_ids in model.vector_groups.items()
    },
    'entanglement_map': {
      f"{ent[0]},{ent[1]}": data for ent, data in model.entanglement_map.items()
    },
    'export_time': datetime.datetime.now().isoformat()
  }
  
  # 确保目录存在
  os.makedirs(os.path.dirname(filepath), exist_ok=True)
  
  # 导出数据
  with open(filepath, 'w', encoding='utf-8') as f:
    json.dump(export_data, f, ensure_ascii=False, indent=2)
    
  logger.info(f"模型数据已导出到: {filepath}")
  return filepath

@function import_model_data(filepath: str) -> Dict[str, Any]:
  """导入模型数据
  
  Args:
      filepath: 数据文件路径
      
  Returns:
      导入的数据
  """
  try:
    with open(filepath, 'r', encoding='utf-8') as f:
      data = json.load(f)
    
    logger.info(f"从{filepath}导入模型数据")
    return data
    
  except Exception as e:
    logger.error(f"导入模型数据出错: {str(e)}")
    raise

@function validate_model_data(model_data: Dict[str, Any]) -> Tuple[bool, str]:
  """验证模型数据格式
  
  Args:
      model_data: 模型数据
      
  Returns:
      (是否有效, 错误信息)
  """
  # 检查必要字段
  if not isinstance(model_data, dict):
    return False, "模型数据必须是字典格式"
  
  required_fields = ["model_info", "vectors"]
  for field in required_fields:
    if field not in model_data:
      return False, f"缺少必要字段: {field}"
  
  # 验证模型信息
  model_info = model_data["model_info"]
  if not isinstance(model_info, dict):
    return False, "模型信息必须是字典格式"
  
  required_model_fields = ["name", "dimension", "version"]
  for field in required_model_fields:
    if field not in model_info:
      return False, f"模型信息缺少必要字段: {field}"
  
  # 验证向量数据
  vectors = model_data["vectors"]
  if not isinstance(vectors, dict):
    return False, "向量数据必须是字典格式"
  
  for vector_id, vector_data in vectors.items():
    if not isinstance(vector_data, dict):
      return False, f"向量 {vector_id} 的数据必须是字典格式"
    
    required_vector_fields = ["dimension", "sp_type", "amplitudes", "phases"]
    for field in required_vector_fields:
      if field not in vector_data:
        return False, f"向量 {vector_id} 缺少必要字段: {field}"
  
  return True, "" 