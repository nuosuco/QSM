/**
 * QEntL虚拟机内存管理器
 * QuantumGene: QG-VM-MEMORY-A1B2-1714042200
 * EntanglementStrength: 1.0
 */

quantum_module MemoryManager {
    // 量子基因编码
    metadata: {
        name: "QEntL虚拟机内存管理器",
        version: "1.0.0",
        description: "管理QEntL虚拟机的内存分配和访问",
        quantum_gene: "QG-VM-MEMORY-A1B2-1714042200",
        entanglement_strength: 1.0,
        node_state: "ACTIVE"
    },
    
    // 内存配置
    config: {
        page_size: 4096,             // 页大小 (字节)
        default_mem_size: 16777216,  // 默认内存大小 (16MB)
        max_mem_size: 17179869184,   // 最大内存大小 (16GB)
        allocation_strategy: "quantum_first_fit", // 分配策略
        protection_level: "quantum_isolation",    // 保护级别
        gc_threshold: 0.75,          // 垃圾回收阈值 (内存使用率)
        gc_algorithm: "quantum_mark_sweep"        // 垃圾回收算法
    },
    
    // 内存状态
    state: {
        total_memory: 0,             // 总内存大小
        free_memory: 0,              // 可用内存大小
        allocated_pages: 0,          // 已分配页数
        total_pages: 0,              // 总页数
        gc_counter: 0,               // 垃圾回收计数
        last_gc_time: 0              // 上次垃圾回收时间
    },
    
    // 初始化内存管理器
    initialize: function(memory_size = this.config.default_mem_size) {
        log("MemoryManager", "初始化内存管理器");
        
        // 确保内存大小在有效范围内
        if (memory_size > this.config.max_mem_size) {
            log("MemoryManager", `内存大小超出限制，调整为最大值: ${this.config.max_mem_size}`, "WARNING");
            memory_size = this.config.max_mem_size;
        }
        
        // 计算页数
        let page_count = Math.ceil(memory_size / this.config.page_size);
        
        // 初始化内存池
        this.memory_pool = new QuantumMemoryPool(page_count * this.config.page_size);
        
        // 初始化页表
        this.page_table = new QuantumArray(page_count);
        for (let i = 0; i < page_count; i++) {
            this.page_table[i] = {
                address: i * this.config.page_size,
                allocated: false,
                process_id: null,
                protection: "r/w",
                last_access: 0,
                quantum_state: new QuantumState()
            };
        }
        
        // 初始化分配器
        this.allocator = new QuantumAllocator(this.config.allocation_strategy);
        
        // 初始化内存保护系统
        this.protection_system = new QuantumMemoryProtection(this.config.protection_level);
        
        // 更新状态
        this.state.total_memory = memory_size;
        this.state.free_memory = memory_size;
        this.state.total_pages = page_count;
        this.state.allocated_pages = 0;
        
        log("MemoryManager", `内存管理器初始化完成，总内存: ${this.formatMemorySize(memory_size)}, 页数: ${page_count}`);
        return true;
    },
    
    // 分配内存
    allocate: function(size, process_id, protection = "r/w") {
        // 检查是否有足够的内存
        if (size > this.state.free_memory) {
            // 尝试进行垃圾回收
            this.garbageCollect(true);
            
            // 再次检查
            if (size > this.state.free_memory) {
                log("MemoryManager", `内存不足，请求: ${this.formatMemorySize(size)}, 可用: ${this.formatMemorySize(this.state.free_memory)}`, "ERROR");
                return null;
            }
        }
        
        // 计算需要的页数
        let pages_needed = Math.ceil(size / this.config.page_size);
        
        // 找到连续的空闲页
        let start_page = this.allocator.findFreePages(this.page_table, pages_needed);
        if (start_page === -1) {
            log("MemoryManager", "无法找到连续的空闲页", "ERROR");
            return null;
        }
        
        // 分配页
        for (let i = 0; i < pages_needed; i++) {
            let page = this.page_table[start_page + i];
            page.allocated = true;
            page.process_id = process_id;
            page.protection = protection;
            page.last_access = this.getCurrentTime();
            page.quantum_state.reset(); // 重置量子状态
        }
        
        // 更新状态
        let allocated_size = pages_needed * this.config.page_size;
        this.state.free_memory -= allocated_size;
        this.state.allocated_pages += pages_needed;
        
        // 创建内存块对象
        let memory_block = {
            address: start_page * this.config.page_size,
            size: allocated_size,
            pages: pages_needed,
            start_page: start_page,
            process_id: process_id,
            
            // 读取内存
            read: function(offset, length) {
                return this.parent.read(this.address + offset, length, this.process_id);
            },
            
            // 写入内存
            write: function(offset, data, length) {
                return this.parent.write(this.address + offset, data, length, this.process_id);
            },
            
            // 释放内存
            free: function() {
                return this.parent.free(this.address, this.process_id);
            },
            
            // 父对象引用
            parent: this
        };
        
        log("MemoryManager", `已分配内存: ${this.formatMemorySize(allocated_size)}, 起始地址: 0x${memory_block.address.toString(16)}`);
        return memory_block;
    },
    
    // 为系统分配内存
    allocateSystemMemory: function(size) {
        return this.allocate(size, "system", "r/w/x");
    },
    
    // 释放内存
    free: function(address, process_id) {
        // 找到对应的页
        let page_index = Math.floor(address / this.config.page_size);
        
        // 验证页是否存在
        if (page_index < 0 || page_index >= this.state.total_pages) {
            log("MemoryManager", `无效的内存地址: 0x${address.toString(16)}`, "ERROR");
            return false;
        }
        
        // 验证进程ID和分配状态
        let page = this.page_table[page_index];
        if (!page.allocated) {
            log("MemoryManager", `尝试释放未分配的内存: 0x${address.toString(16)}`, "ERROR");
            return false;
        }
        
        if (process_id !== "system" && page.process_id !== process_id) {
            log("MemoryManager", `无权释放其他进程的内存: 进程 ${process_id} 尝试释放进程 ${page.process_id} 的内存`, "ERROR");
            return false;
        }
        
        // 找到连续分配的页
        let pages_to_free = 1;
        while (page_index + pages_to_free < this.state.total_pages) {
            let next_page = this.page_table[page_index + pages_to_free];
            if (!next_page.allocated || next_page.process_id !== page.process_id) {
                break;
            }
            pages_to_free++;
        }
        
        // 释放页
        for (let i = 0; i < pages_to_free; i++) {
            let p = this.page_table[page_index + i];
            p.allocated = false;
            p.process_id = null;
            p.protection = "r/w";
            p.quantum_state.collapse(); // 坍缩量子状态，清除信息
            
            // 清零内存
            let page_address = (page_index + i) * this.config.page_size;
            this.memory_pool.clear(page_address, this.config.page_size);
        }
        
        // 更新状态
        let freed_size = pages_to_free * this.config.page_size;
        this.state.free_memory += freed_size;
        this.state.allocated_pages -= pages_to_free;
        
        log("MemoryManager", `已释放内存: ${this.formatMemorySize(freed_size)}, 起始地址: 0x${address.toString(16)}`);
        return true;
    },
    
    // 读取内存
    read: function(address, length, process_id) {
        // 计算起始页和结束页
        let start_page = Math.floor(address / this.config.page_size);
        let end_page = Math.floor((address + length - 1) / this.config.page_size);
        
        // 检查页范围
        if (start_page < 0 || end_page >= this.state.total_pages) {
            log("MemoryManager", `内存访问越界: 0x${address.toString(16)}, 长度: ${length}`, "ERROR");
            return null;
        }
        
        // 检查权限
        for (let i = start_page; i <= end_page; i++) {
            let page = this.page_table[i];
            
            // 验证分配状态
            if (!page.allocated) {
                log("MemoryManager", `访问未分配的内存: 0x${(i * this.config.page_size).toString(16)}`, "ERROR");
                return null;
            }
            
            // 检查权限
            if (process_id !== "system" && page.process_id !== process_id) {
                if (!this.protection_system.checkAccess(process_id, page.process_id, "read")) {
                    log("MemoryManager", `无读取权限: 进程 ${process_id} 尝试读取进程 ${page.process_id} 的内存`, "ERROR");
                    return null;
                }
            }
            
            // 检查读取保护
            if (!page.protection.includes("r")) {
                log("MemoryManager", `内存不可读: 页 ${i} 的保护级别为 ${page.protection}`, "ERROR");
                return null;
            }
            
            // 更新访问时间
            page.last_access = this.getCurrentTime();
        }
        
        // 从内存池读取数据
        let data = this.memory_pool.read(address, length);
        
        return data;
    },
    
    // 写入内存
    write: function(address, data, length, process_id) {
        // 计算起始页和结束页
        let start_page = Math.floor(address / this.config.page_size);
        let end_page = Math.floor((address + length - 1) / this.config.page_size);
        
        // 检查页范围
        if (start_page < 0 || end_page >= this.state.total_pages) {
            log("MemoryManager", `内存访问越界: 0x${address.toString(16)}, 长度: ${length}`, "ERROR");
            return false;
        }
        
        // 检查权限
        for (let i = start_page; i <= end_page; i++) {
            let page = this.page_table[i];
            
            // 验证分配状态
            if (!page.allocated) {
                log("MemoryManager", `访问未分配的内存: 0x${(i * this.config.page_size).toString(16)}`, "ERROR");
                return false;
            }
            
            // 检查权限
            if (process_id !== "system" && page.process_id !== process_id) {
                if (!this.protection_system.checkAccess(process_id, page.process_id, "write")) {
                    log("MemoryManager", `无写入权限: 进程 ${process_id} 尝试写入进程 ${page.process_id} 的内存`, "ERROR");
                    return false;
                }
            }
            
            // 检查写入保护
            if (!page.protection.includes("w")) {
                log("MemoryManager", `内存不可写: 页 ${i} 的保护级别为 ${page.protection}`, "ERROR");
                return false;
            }
            
            // 更新访问时间
            page.last_access = this.getCurrentTime();
        }
        
        // 写入内存池
        this.memory_pool.write(address, data, length);
        
        return true;
    },
    
    // 加载数据到内存
    loadToMemory: function(memory_block, data) {
        // 确保数据大小不超过内存块
        if (data.length > memory_block.size) {
            log("MemoryManager", `数据大小超过内存块大小: ${data.length} > ${memory_block.size}`, "ERROR");
            return false;
        }
        
        // 写入数据
        return memory_block.write(0, data, data.length);
    },
    
    // 垃圾回收
    garbageCollect: function(force = false) {
        // 检查是否需要垃圾回收
        let mem_usage = 1 - (this.state.free_memory / this.state.total_memory);
        if (!force && mem_usage < this.config.gc_threshold) {
            return false;
        }
        
        log("MemoryManager", `开始垃圾回收，当前内存使用率: ${(mem_usage * 100).toFixed(2)}%`);
        let start_time = this.getCurrentTime();
        
        // 标记所有可回收的页
        let reclaimable_pages = [];
        for (let i = 0; i < this.state.total_pages; i++) {
            let page = this.page_table[i];
            if (page.allocated && page.process_id !== "system") {
                // 根据GC算法决定是否回收
                if (this.shouldReclaim(page)) {
                    reclaimable_pages.push(i);
                }
            }
        }
        
        // 回收页
        let reclaimed_pages = 0;
        for (let i of reclaimable_pages) {
            let page = this.page_table[i];
            let process_id = page.process_id;
            let address = i * this.config.page_size;
            
            if (this.free(address, "system")) {
                reclaimed_pages++;
            }
        }
        
        // 更新状态
        this.state.gc_counter++;
        this.state.last_gc_time = start_time;
        
        let end_time = this.getCurrentTime();
        let duration = end_time - start_time;
        
        log("MemoryManager", `垃圾回收完成，回收页数: ${reclaimed_pages}，耗时: ${duration.toFixed(2)}ms`);
        return reclaimed_pages > 0;
    },
    
    // 决定是否应该回收页
    shouldReclaim: function(page) {
        // 根据算法决定是否回收
        if (this.config.gc_algorithm === "quantum_mark_sweep") {
            // 检查页的量子状态
            if (page.quantum_state.isDisconnected()) {
                return true;
            }
            
            // 检查页的最后访问时间
            let current_time = this.getCurrentTime();
            let idle_time = current_time - page.last_access;
            if (idle_time > 10000) { // 10秒未访问
                return true;
            }
        }
        
        return false;
    },
    
    // 获取当前时间
    getCurrentTime: function() {
        return Date.now();
    },
    
    // 格式化内存大小
    formatMemorySize: function(size) {
        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        let unit_index = 0;
        let formatted_size = size;
        
        while (formatted_size >= 1024 && unit_index < units.length - 1) {
            formatted_size /= 1024;
            unit_index++;
        }
        
        return `${formatted_size.toFixed(2)} ${units[unit_index]}`;
    },
    
    // 关闭内存管理器
    shutdown: function() {
        log("MemoryManager", "关闭内存管理器");
        
        // 释放所有系统内存
        for (let i = 0; i < this.state.total_pages; i++) {
            let page = this.page_table[i];
            if (page.allocated && page.process_id === "system") {
                this.free(i * this.config.page_size, "system");
            }
        }
        
        // 释放内存池
        this.memory_pool = null;
        this.page_table = null;
        this.allocator = null;
        this.protection_system = null;
        
        log("MemoryManager", "内存管理器已关闭");
        return true;
    }
};

// 导出模块
export MemoryManager; 