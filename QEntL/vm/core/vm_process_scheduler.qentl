/**
 * QEntL虚拟机进程调度器
 * QuantumGene: QG-VM-PROCESS-A1B2-1714042300
 * EntanglementStrength: 1.0
 */

quantum_module ProcessScheduler {
    // 量子基因编码
    metadata: {
        name: "QEntL虚拟机进程调度器",
        version: "1.0.0",
        description: "管理QEntL虚拟机的进程调度和执行",
        quantum_gene: "QG-VM-PROCESS-A1B2-1714042300",
        entanglement_strength: 1.0,
        node_state: "ACTIVE"
    },
    
    // 调度器配置
    config: {
        max_processes: 1024,           // 最大进程数
        quantum_time_slice: 20,        // 量子时间片 (量子时间单位)
        scheduler_algorithm: "quantum_priority", // 调度算法
        process_priority_levels: 16,    // 进程优先级级别
        default_priority: 8,           // 默认优先级
        system_priority: 0,            // 系统进程优先级
        max_process_state_dimensions: 8, // 最大进程状态维度
        context_switch_overhead: 2      // 上下文切换开销 (量子时间单位)
    },
    
    // 调度器状态
    state: {
        total_processes: 0,            // 总进程数
        running_processes: 0,           // 运行中的进程数
        waiting_processes: 0,           // 等待中的进程数
        terminated_processes: 0,        // 已终止的进程数
        current_process: null,          // 当前运行进程
        current_quantum_slice: 0,       // 当前量子时间片计数
        scheduler_cycle: 0,             // 调度周期计数
        last_process_id: 0,             // 上次分配的进程ID
        load_average: 0                 // 负载平均值
    },
    
    // 进程状态枚举
    process_states: {
        CREATED: "created",             // 已创建
        READY: "ready",                 // 就绪
        RUNNING: "running",             // 运行中
        WAITING: "waiting",             // 等待中
        SUSPENDED: "suspended",         // 已挂起
        TERMINATED: "terminated"        // 已终止
    },
    
    // 初始化进程调度器
    initialize: function() {
        log("ProcessScheduler", "初始化进程调度器");
        
        // 初始化进程表
        this.process_table = new QuantumArray(this.config.max_processes);
        
        // 初始化就绪队列 (按优先级)
        this.ready_queues = [];
        for (let i = 0; i < this.config.process_priority_levels; i++) {
            this.ready_queues[i] = new QuantumQueue();
        }
        
        // 初始化等待队列
        this.wait_queues = {
            io: new QuantumQueue(),           // I/O等待
            timer: new QuantumQueue(),        // 定时器等待
            synchronization: new QuantumQueue(), // 同步等待
            resource: new QuantumQueue()      // 资源等待
        };
        
        // 初始化进程事件系统
        this.process_event_system = new QuantumEventEmitter();
        this.registerEventHandlers();
        
        log("ProcessScheduler", "进程调度器初始化完成");
        return true;
    },
    
    // 注册事件处理函数
    registerEventHandlers: function() {
        // 进程创建事件
        this.process_event_system.on("process_created", (process) => {
            log("ProcessScheduler", `进程已创建: ${process.id} (${process.name})`);
        });
        
        // 进程状态变更事件
        this.process_event_system.on("process_state_changed", (process, old_state, new_state) => {
            log("ProcessScheduler", `进程 ${process.id} (${process.name}) 状态变更: ${old_state} -> ${new_state}`);
        });
        
        // 进程终止事件
        this.process_event_system.on("process_terminated", (process, exit_code) => {
            log("ProcessScheduler", `进程已终止: ${process.id} (${process.name}), 退出码: ${exit_code}`);
        });
    },
    
    // 创建新进程
    createProcess: function(options) {
        // 检查进程数量限制
        if (this.state.total_processes >= this.config.max_processes) {
            log("ProcessScheduler", "达到最大进程数限制", "ERROR");
            return null;
        }
        
        // 生成新进程ID
        let process_id = ++this.state.last_process_id;
        
        // 创建进程对象
        let process = {
            id: process_id,
            name: options.name || `process-${process_id}`,
            priority: options.priority !== undefined ? options.priority : this.config.default_priority,
            memory: options.memory || null,
            entry_point: options.entry_point || 0,
            parent_id: options.parent_id || null,
            
            // 进程状态
            state: this.process_states.CREATED,
            quantum_state: new QuantumState({
                dimensions: [
                    this.process_states.READY,
                    this.process_states.RUNNING,
                    this.process_states.WAITING,
                    this.process_states.SUSPENDED
                ],
                initial: this.process_states.CREATED
            }),
            
            // 进程上下文
            context: {
                registers: {
                    r0: 0, r1: 0, r2: 0, r3: 0,
                    r4: 0, r5: 0, r6: 0, r7: 0,
                    pc: options.entry_point || 0,
                    sp: options.memory ? options.memory.address + options.memory.size - 8 : 0,
                    fp: options.memory ? options.memory.address + options.memory.size - 8 : 0,
                    sr: 0
                },
                quantum_registers: {
                    qr0: null, qr1: null, qr2: null, qr3: null
                }
            },
            
            // 进程统计信息
            stats: {
                creation_time: this.getCurrentTime(),
                last_run_time: 0,
                total_run_time: 0,
                wait_time: 0,
                context_switches: 0
            },
            
            // 进程资源
            resources: {
                memory: options.memory || null,
                open_files: [],
                quantum_resources: []
            }
        };
        
        // 添加到进程表
        this.process_table[process_id] = process;
        
        // 更新状态
        this.state.total_processes++;
        
        // 触发进程创建事件
        this.process_event_system.emit("process_created", process);
        
        // 将进程状态设置为就绪
        this.setProcessState(process, this.process_states.READY);
        
        log("ProcessScheduler", `已创建进程: ${process.id} (${process.name}), 优先级: ${process.priority}`);
        return process;
    },
    
    // 启动进程
    startProcess: function(process) {
        // 检查进程状态
        if (process.state !== this.process_states.READY && process.state !== this.process_states.CREATED) {
            log("ProcessScheduler", `无法启动非就绪状态的进程: ${process.id}, 当前状态: ${process.state}`, "ERROR");
            return false;
        }
        
        // 设置进程状态为就绪
        this.setProcessState(process, this.process_states.READY);
        
        // 加入就绪队列
        this.ready_queues[process.priority].enqueue(process.id);
        
        log("ProcessScheduler", `进程已启动: ${process.id} (${process.name})`);
        return true;
    },
    
    // 终止进程
    terminateProcess: function(process_id, exit_code = 0) {
        // 获取进程
        let process = this.process_table[process_id];
        if (!process) {
            log("ProcessScheduler", `进程不存在: ${process_id}`, "ERROR");
            return false;
        }
        
        // 设置进程状态为终止
        this.setProcessState(process, this.process_states.TERMINATED);
        
        // 释放进程资源
        this.releaseProcessResources(process);
        
        // 更新状态
        this.state.terminated_processes++;
        
        // 如果是当前进程，设置当前进程为null
        if (this.state.current_process === process_id) {
            this.state.current_process = null;
        }
        
        // 触发进程终止事件
        this.process_event_system.emit("process_terminated", process, exit_code);
        
        log("ProcessScheduler", `进程已终止: ${process.id} (${process.name}), 退出码: ${exit_code}`);
        return true;
    },
    
    // 设置进程状态
    setProcessState: function(process, new_state) {
        let old_state = process.state;
        
        // 忽略相同状态的设置
        if (old_state === new_state) {
            return;
        }
        
        // 更新常规状态
        process.state = new_state;
        
        // 更新量子状态
        process.quantum_state.collapse(new_state);
        
        // 更新进程计数
        if (old_state === this.process_states.RUNNING) {
            this.state.running_processes--;
        } else if (old_state === this.process_states.WAITING) {
            this.state.waiting_processes--;
        }
        
        if (new_state === this.process_states.RUNNING) {
            this.state.running_processes++;
            process.stats.last_run_time = this.getCurrentTime();
        } else if (new_state === this.process_states.WAITING) {
            this.state.waiting_processes++;
        }
        
        // 触发状态变更事件
        this.process_event_system.emit("process_state_changed", process, old_state, new_state);
    },
    
    // 调度任务
    scheduleTasks: function() {
        // 增加调度周期计数
        this.state.scheduler_cycle++;
        
        // 检查当前进程是否仍在运行
        if (this.state.current_process !== null) {
            let current_process = this.process_table[this.state.current_process];
            
            // 检查当前进程是否已终止
            if (current_process.state === this.process_states.TERMINATED) {
                this.state.current_process = null;
            }
            // 检查时间片是否已用完
            else if (this.state.current_quantum_slice >= this.config.quantum_time_slice) {
                // 时间片用完，将进程切换到就绪状态
                this.setProcessState(current_process, this.process_states.READY);
                this.ready_queues[current_process.priority].enqueue(current_process.id);
                this.state.current_process = null;
            }
            // 当前进程仍在运行，增加时间片计数
            else {
                this.state.current_quantum_slice++;
                return this.executeCurrentProcess();
            }
        }
        
        // 选择下一个要运行的进程
        let next_process_id = this.selectNextProcess();
        if (next_process_id === null) {
            // 没有可运行的进程
            return false;
        }
        
        // 切换到新进程
        let next_process = this.process_table[next_process_id];
        
        // 执行上下文切换
        if (this.state.current_process !== null) {
            let current_process = this.process_table[this.state.current_process];
            this.switchContext(current_process, next_process);
        }
        
        // 设置新的当前进程
        this.state.current_process = next_process_id;
        this.state.current_quantum_slice = 0;
        
        // 将进程状态设置为运行
        this.setProcessState(next_process, this.process_states.RUNNING);
        
        // 执行进程
        return this.executeCurrentProcess();
    },
    
    // 选择下一个要运行的进程
    selectNextProcess: function() {
        // 根据调度算法选择下一个进程
        if (this.config.scheduler_algorithm === "quantum_priority") {
            // 量子优先级调度算法
            // 首先从高优先级队列开始检查
            for (let i = 0; i < this.config.process_priority_levels; i++) {
                if (!this.ready_queues[i].isEmpty()) {
                    return this.ready_queues[i].dequeue();
                }
            }
        } else if (this.config.scheduler_algorithm === "quantum_superposition") {
            // 量子叠加态调度算法
            // 使用量子概率选择下一个进程
            
            // 首先收集所有就绪进程
            let ready_processes = [];
            for (let i = 0; i < this.config.process_priority_levels; i++) {
                let queue = this.ready_queues[i];
                for (let j = 0; j < queue.size(); j++) {
                    let process_id = queue.peekAt(j);
                    if (process_id !== null) {
                        let process = this.process_table[process_id];
                        ready_processes.push({
                            id: process_id,
                            priority: process.priority,
                            queue_index: i,
                            position: j
                        });
                    }
                }
            }
            
            if (ready_processes.length > 0) {
                // 计算每个进程的量子权重
                let total_weight = 0;
                for (let i = 0; i < ready_processes.length; i++) {
                    // 优先级越高，权重越大
                    let priority_weight = this.config.process_priority_levels - ready_processes[i].priority;
                    ready_processes[i].weight = Math.pow(2, priority_weight);
                    total_weight += ready_processes[i].weight;
                }
                
                // 生成随机数
                let random = Math.random() * total_weight;
                
                // 选择进程
                let cumulative_weight = 0;
                for (let i = 0; i < ready_processes.length; i++) {
                    cumulative_weight += ready_processes[i].weight;
                    if (random < cumulative_weight) {
                        // 从对应队列中移除该进程
                        let queue = this.ready_queues[ready_processes[i].queue_index];
                        queue.removeAt(ready_processes[i].position);
                        return ready_processes[i].id;
                    }
                }
                
                // 保底，返回第一个进程
                let first = ready_processes[0];
                let queue = this.ready_queues[first.queue_index];
                queue.removeAt(first.position);
                return first.id;
            }
        }
        
        // 没有找到可运行的进程
        return null;
    },
    
    // 执行当前进程
    executeCurrentProcess: function() {
        if (this.state.current_process === null) {
            return false;
        }
        
        // 获取当前进程
        let process = this.process_table[this.state.current_process];
        
        // 更新进程统计信息
        process.stats.total_run_time++;
        
        // 获取当前指令
        let current_instruction = this.fetchInstruction(process);
        
        // 执行指令
        return this.executeInstruction(process, current_instruction);
    },
    
    // 获取当前指令
    fetchInstruction: function(process) {
        // 检查进程内存
        if (!process.resources.memory) {
            log("ProcessScheduler", `进程 ${process.id} 没有分配内存`, "ERROR");
            return null;
        }
        
        // 获取程序计数器
        let pc = process.context.registers.pc;
        
        // 从内存读取指令
        try {
            let instruction = process.resources.memory.read(pc, 8);
            return instruction;
        } catch (error) {
            log("ProcessScheduler", `读取进程 ${process.id} 指令失败: ${error}`, "ERROR");
            return null;
        }
    },
    
    // 执行指令
    executeInstruction: function(process, instruction) {
        if (!instruction) {
            // 无效指令，终止进程
            this.terminateProcess(process.id, -1);
            return false;
        }
        
        // 调用指令执行器执行指令
        let result = quantum_vm.components.instruction_set.executeInstruction(process.context, instruction);
        
        // 检查执行结果
        if (!result) {
            // 执行失败，终止进程
            this.terminateProcess(process.id, -1);
            return false;
        }
        
        return true;
    },
    
    // 切换上下文
    switchContext: function(from_process, to_process) {
        // 保存当前进程上下文
        // 在量子虚拟机中，上下文切换是通过量子纠缠实现的，不需要显式保存和恢复
        
        // 增加上下文切换计数
        from_process.stats.context_switches++;
        to_process.stats.context_switches++;
        
        // 消耗上下文切换开销
        // 在实际系统中，这里需要等待一段时间
        
        log("ProcessScheduler", `上下文切换: ${from_process.id} -> ${to_process.id}`);
    },
    
    // 释放进程资源
    releaseProcessResources: function(process) {
        // 释放内存
        if (process.resources.memory) {
            process.resources.memory.free();
            process.resources.memory = null;
        }
        
        // 关闭打开的文件
        for (let file of process.resources.open_files) {
            file.close();
        }
        process.resources.open_files = [];
        
        // 释放量子资源
        for (let resource of process.resources.quantum_resources) {
            resource.release();
        }
        process.resources.quantum_resources = [];
    },
    
    // 获取当前时间
    getCurrentTime: function() {
        return Date.now();
    },
    
    // 关闭进程调度器
    shutdown: function() {
        log("ProcessScheduler", "关闭进程调度器");
        
        // 终止所有进程
        for (let i = 1; i <= this.state.last_process_id; i++) {
            let process = this.process_table[i];
            if (process && process.state !== this.process_states.TERMINATED) {
                this.terminateProcess(i);
            }
        }
        
        // 清理资源
        this.process_table = null;
        this.ready_queues = null;
        this.wait_queues = null;
        this.process_event_system = null;
        
        log("ProcessScheduler", "进程调度器已关闭");
        return true;
    }
};

// 导出模块
export ProcessScheduler; 