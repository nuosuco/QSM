// QEntL编译器
// 创建者: Claude
// 功能: 将QEntL源代码编译为量子虚拟机可执行文件

#include <lexer.h>
#include <parser.h>
#include <semantic_analyzer.h>
#include <code_generator.h>
#include <optimizer.h>
#include <error_handler.h>
#include <file_manager.h>

// QEntL编译器主类
class QEntLCompiler {
private:
    // 文件管理器
    FileManager fileManager;
    
    // 词法分析器
    Lexer lexer;
    
    // 语法分析器
    Parser parser;
    
    // 语义分析器
    SemanticAnalyzer semanticAnalyzer;
    
    // 代码优化器
    Optimizer optimizer;
    
    // 代码生成器
    CodeGenerator codeGenerator;
    
    // 错误处理器
    ErrorHandler errorHandler;
    
    // 编译选项
    CompilerOptions options;
    
public:
    // 初始化编译器
    void initialize() {
        lexer.initialize();
        parser.initialize();
        semanticAnalyzer.initialize();
        optimizer.initialize();
        codeGenerator.initialize();
        errorHandler.initialize();
        fileManager.initialize();
    }
    
    // 设置编译选项
    void setOptions(const CompilerOptions& opts) {
        options = opts;
        
        // 将选项传递给各个组件
        lexer.setOptions(options);
        parser.setOptions(options);
        semanticAnalyzer.setOptions(options);
        optimizer.setOptions(options);
        codeGenerator.setOptions(options);
    }
    
    // 编译单个文件
    bool compileFile(const char* inputFile, const char* outputFile) {
        try {
            // 读取源文件
            std::string sourceCode = fileManager.readFile(inputFile);
            
            // 预处理源代码
            sourceCode = preprocessCode(sourceCode);
            
            // 词法分析
            TokenStream tokens = lexer.tokenize(sourceCode);
            
            // 语法分析
            ASTNode* ast = parser.parse(tokens);
            
            // 语义分析
            semanticAnalyzer.analyze(ast);
            
            // 代码优化
            if (options.enableOptimization) {
                optimizer.optimize(ast);
            }
            
            // 代码生成
            ByteCode byteCode = codeGenerator.generate(ast);
            
            // 保存输出文件
            fileManager.writeByteCode(byteCode, outputFile);
            
            // 清理资源
            parser.cleanup(ast);
            
            return true;
        } catch (CompilerException& e) {
            errorHandler.handleException(e);
            return false;
        }
    }
    
    // 处理包含文件
    std::string preprocessCode(const std::string& sourceCode) {
        IncludeProcessor includeProcessor;
        return includeProcessor.process(sourceCode, fileManager);
    }
    
    // 显示版本信息
    void showVersion() {
        std::cout << "QEntL编译器 v0.1.0" << std::endl;
        std::cout << "实现量子叠加态模型项目" << std::endl;
        std::cout << "由Claude设计与实现" << std::endl;
    }
};

// QEntL编译器类型定义
namespace QEntL {
    // 量子类型定义
    struct QBit {
        // 表示单个量子比特
        bool isEntangled;
        int entanglementGroup;
    };
    
    struct QRegister {
        // 量子寄存器，包含多个量子比特
        std::vector<QBit> qbits;
        int size;
    };
    
    // 量子操作定义
    enum class QGateType {
        Hadamard,
        PauliX,
        PauliY,
        PauliZ,
        CNOT,
        Toffoli,
        Measurement
    };
    
    struct QGate {
        QGateType type;
        std::vector<int> targetQubits;
        std::vector<int> controlQubits;
    };
    
    // 类型检查辅助函数
    bool isQuantumType(const Type& type) {
        return type.isQubit() || type.isQRegister();
    }
    
    bool isClassicalType(const Type& type) {
        return !isQuantumType(type);
    }
    
    // 量子语言关键字
    const std::vector<std::string> quantumKeywords = {
        "qbit", "qreg", "measure", "reset", "hadamard", "paulix", "pauliy", "pauliz",
        "cnot", "toffoli", "superposition", "entanglement"
    };
};

// 词法分析器实现
void Lexer::initialize() {
    // 定义所有QEntL语言的标记类型
    defineTokenTypes();
    
    // 添加所有关键字
    for (const auto& keyword : QEntL::quantumKeywords) {
        addKeyword(keyword);
    }
    
    // 添加所有运算符
    addOperators();
    
    // 配置对量子状态标记的支持
    enableQuantumStateTokens();
}

TokenStream Lexer::tokenize(const std::string& sourceCode) {
    TokenStream tokens;
    
    // 实现词法分析逻辑
    std::string::const_iterator it = sourceCode.begin();
    
    while (it != sourceCode.end()) {
        // 跳过空白字符
        while (it != sourceCode.end() && isWhitespace(*it)) {
            ++it;
        }
        
        if (it == sourceCode.end()) {
            break;
        }
        
        // 识别注释
        if (*it == '/' && (it + 1) != sourceCode.end() && *(it + 1) == '/') {
            // 单行注释，跳过直到行尾
            it += 2;
            while (it != sourceCode.end() && *it != '\n') {
                ++it;
            }
            continue;
        }
        
        if (*it == '/' && (it + 1) != sourceCode.end() && *(it + 1) == '*') {
            // 多行注释，跳过直到找到结束标记
            it += 2;
            while (it != sourceCode.end() && !(*it == '*' && (it + 1) != sourceCode.end() && *(it + 1) == '/')) {
                ++it;
            }
            if (it != sourceCode.end()) {
                it += 2; // 跳过 */
            }
            continue;
        }
        
        // 识别标识符和关键字
        if (isAlpha(*it) || *it == '_') {
            std::string identifier;
            while (it != sourceCode.end() && (isAlphaNumeric(*it) || *it == '_')) {
                identifier += *it;
                ++it;
            }
            
            // 检查是否是关键字
            if (isKeyword(identifier)) {
                tokens.add(Token(TokenType::KEYWORD, identifier));
            } else {
                tokens.add(Token(TokenType::IDENTIFIER, identifier));
            }
            continue;
        }
        
        // 识别数字
        if (isDigit(*it)) {
            std::string number;
            bool isFloat = false;
            
            while (it != sourceCode.end() && (isDigit(*it) || *it == '.')) {
                if (*it == '.') {
                    if (isFloat) {
                        throw CompilerException("非法的浮点数格式", SourceLocation(line, column));
                    }
                    isFloat = true;
                }
                number += *it;
                ++it;
            }
            
            if (isFloat) {
                tokens.add(Token(TokenType::FLOAT_LITERAL, number));
            } else {
                tokens.add(Token(TokenType::INTEGER_LITERAL, number));
            }
            continue;
        }
        
        // 处理其他标记类型（运算符、分隔符等）
        handleSpecialCharacters(it, tokens);
    }
    
    // 添加文件结束标记
    tokens.add(Token(TokenType::EOF_TOKEN, ""));
    
    return tokens;
}

// 主入口函数
int main(int argc, char** argv) {
    // 解析命令行参数
    CompilerOptions options;
    std::string inputFile;
    std::string outputFile;
    
    if (argc < 2) {
        std::cout << "用法: qentl-compiler [选项] <输入文件> [-o <输出文件>]" << std::endl;
        std::cout << "选项:" << std::endl;
        std::cout << "  -o <文件>    指定输出文件" << std::endl;
        std::cout << "  -O           启用优化" << std::endl;
        std::cout << "  -I <目录>    添加包含目录" << std::endl;
        std::cout << "  -v           显示版本信息" << std::endl;
        return 1;
    }
    
    // 解析命令行选项
    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];
        
        if (arg == "-o" && i + 1 < argc) {
            outputFile = argv[++i];
        } else if (arg == "-O") {
            options.enableOptimization = true;
        } else if (arg == "-I" && i + 1 < argc) {
            options.includePaths.push_back(argv[++i]);
        } else if (arg == "-v") {
            QEntLCompiler compiler;
            compiler.showVersion();
            return 0;
        } else if (arg[0] != '-') {
            // 没有前导连字符的参数被视为输入文件
            inputFile = arg;
        }
    }
    
    // 如果没有指定输出文件，使用默认命名
    if (outputFile.empty() && !inputFile.empty()) {
        // 从输入文件名生成输出文件名，更改扩展名
        size_t dotPos = inputFile.find_last_of('.');
        if (dotPos != std::string::npos) {
            outputFile = inputFile.substr(0, dotPos) + ".qobj";
        } else {
            outputFile = inputFile + ".qobj";
        }
    }
    
    // 创建和初始化编译器
    QEntLCompiler compiler;
    compiler.initialize();
    compiler.setOptions(options);
    
    // 编译文件
    bool success = compiler.compileFile(inputFile.c_str(), outputFile.c_str());
    
    return success ? 0 : 1;
} 