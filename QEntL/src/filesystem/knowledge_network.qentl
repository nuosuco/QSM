// QEntL知识网络
// 版本: 1.0.0
// 描述: 构建和维护语义关联网络和知识图谱系统
// 作者: QEntL开发团队
// 量子基因: 0xE7D195
// 纠缠强度: 0.96

导入 "./semantic_analyzer.qentl" 作为 分析器
导入 "./semantic_extractor.qentl" 作为 提取器

配置 {
    存储类型: "图数据库",   // 图数据库、内存、分布式
    最大节点数: 1000000,
    最大边数: 5000000,
    最小关联阈值: 0.65,
    自动清理: true,
    清理阈值: 0.4,          // 可靠性低于此值的节点将被清理
    并行工作器: 8,
    索引更新间隔: 30,       // 秒
    稀疏关联: true,         // 使用稀疏矩阵存储关联
    量子关联模式: true      // 启用量子关联计算
}

类型 知识节点 {
    ID: 字符串,
    标签: [字符串],
    内容: 字符串,
    类型: 字符串,             // 概念、实体、主题、属性等
    源引用: [字符串],
    向量表示: 分析器.TextVector,
    可靠性: 浮点数,           // 0-1之间的可靠性分数
    创建时间: 时间戳,
    最后更新: 时间戳,
    元数据: 映射<字符串, 任意>
}

类型 知识边 {
    ID: 字符串,
    源节点ID: 字符串,
    目标节点ID: 字符串,
    关系类型: 字符串,
    权重: 浮点数,             // 0-1之间的关系强度
    证据: [字符串],           // 支持这种关系的证据
    置信度: 浮点数,
    创建时间: 时间戳,
    双向: 布尔
}

类型 知识路径 {
    节点序列: [知识节点],
    边序列: [知识边],
    路径长度: 整数,
    路径强度: 浮点数          // 路径上所有边的综合强度
}

类型 子图 {
    节点: [知识节点],
    边: [知识边],
    中心节点ID: 字符串,
    深度: 整数
}

状态 {
    节点计数: 整数,
    边计数: 整数,
    已初始化: 布尔,
    锁定操作: 布尔,
    最后备份: 时间戳
}

// 初始化知识网络
函数 初始化() -> 布尔 {
    日志("初始化知识网络...")
    
    如果 (!分析器.初始化() || !提取器.初始化()) {
        日志("依赖组件初始化失败")
        返回 false
    }
    
    尝试 {
        初始化存储(配置.存储类型)
        日志("知识网络存储初始化完成")
        
        状态.节点计数 = 获取节点计数()
        状态.边计数 = 获取边计数()
        状态.已初始化 = true
        状态.锁定操作 = false
        状态.最后备份 = 获取当前时间()
        
        返回 true
    } 捕获 (错误) {
        日志(`知识网络初始化错误: ${错误.消息}`)
        返回 false
    }
}

// 添加新知识节点
函数 添加节点(内容: 字符串, 类型: 字符串, 标签: [字符串] = []) -> 知识节点 {
    如果 (!状态.已初始化) 抛出 新错误("知识网络未初始化")
    
    当前时间 = 获取当前时间()
    节点ID = 生成唯一ID()
    
    向量 = 分析器.向量化(内容)
    
    新节点 = {
        ID: 节点ID,
        标签: 标签,
        内容: 内容,
        类型: 类型,
        源引用: [],
        向量表示: 向量,
        可靠性: 1.0,
        创建时间: 当前时间,
        最后更新: 当前时间,
        元数据: {}
    }
    
    存储节点(新节点)
    状态.节点计数++
    
    // 尝试自动关联已有知识
    如果 (状态.节点计数 > 1) {
        自动关联(新节点)
    }
    
    返回 新节点
}

// 添加知识边
函数 添加边(源ID: 字符串, 目标ID: 字符串, 关系类型: 字符串, 
          权重: 浮点数 = 1.0, 双向: 布尔 = false) -> 知识边 {
    如果 (!状态.已初始化) 抛出 新错误("知识网络未初始化")
    
    如果 (!节点存在(源ID) || !节点存在(目标ID)) {
        抛出 新错误("源节点或目标节点不存在")
    }
    
    边ID = 生成唯一ID()
    当前时间 = 获取当前时间()
    
    新边 = {
        ID: 边ID,
        源节点ID: 源ID,
        目标节点ID: 目标ID,
        关系类型: 关系类型,
        权重: 权重,
        证据: [],
        置信度: 1.0,
        创建时间: 当前时间,
        双向: 双向
    }
    
    存储边(新边)
    状态.边计数++
    
    如果 (双向) {
        反向边ID = 生成唯一ID()
        反向边 = {
            ID: 反向边ID,
            源节点ID: 目标ID,
            目标节点ID: 源ID,
            关系类型: 关系类型,
            权重: 权重,
            证据: [],
            置信度: 1.0,
            创建时间: 当前时间,
            双向: true
        }
        
        存储边(反向边)
        状态.边计数++
    }
    
    返回 新边
}

// 查询相关节点
函数 查询节点(查询内容: 字符串, 最大结果数: 整数 = 10) -> [知识节点] {
    如果 (!状态.已初始化) 抛出 新错误("知识网络未初始化")
    
    查询向量 = 分析器.向量化(查询内容)
    
    所有节点 = 获取所有节点()
    相似度列表 = []
    
    对于 (节点 在 所有节点) {
        相似度 = 计算向量相似度(查询向量, 节点.向量表示)
        如果 (相似度 >= 配置.最小关联阈值) {
            相似度列表.push({
                节点: 节点,
                相似度: 相似度
            })
        }
    }
    
    相似度列表.排序((a, b) => b.相似度 - a.相似度)
    
    返回 相似度列表.切片(0, 最大结果数).map(项 => 项.节点)
}

// 获取两个节点间的路径
函数 获取路径(源ID: 字符串, 目标ID: 字符串, 最大深度: 整数 = 5) -> [知识路径] {
    如果 (!状态.已初始化) 抛出 新错误("知识网络未初始化")
    
    路径列表 = 寻找路径(源ID, 目标ID, 最大深度)
    
    // 按路径强度排序
    路径列表.排序((a, b) => b.路径强度 - a.路径强度)
    
    返回 路径列表
}

// 获取节点的子图
函数 获取子图(中心节点ID: 字符串, 深度: 整数 = 2) -> 子图 {
    如果 (!状态.已初始化) 抛出 新错误("知识网络未初始化")
    
    如果 (!节点存在(中心节点ID)) {
        抛出 新错误("中心节点不存在")
    }
    
    结果 = 提取子图(中心节点ID, 深度)
    
    返回 {
        节点: 结果.节点,
        边: 结果.边,
        中心节点ID: 中心节点ID,
        深度: 深度
    }
}

// 导入知识
函数 导入知识(源: 提取器.数据源) -> {添加节点: 整数, 添加边: 整数} {
    如果 (!状态.已初始化) 抛出 新错误("知识网络未初始化")
    
    提取结果 = 提取器.提取(源)
    添加节点计数 = 0
    添加边计数 = 0
    
    // 处理每个内容块
    对于 (块 在 提取结果.内容块列表) {
        节点 = 添加节点(块.原始内容, "内容", 块.标签 || [])
        添加节点计数++
        
        // 添加与实体的关系
        对于 (实体 在 提取结果.语义概要.主要实体) {
            实体节点ID = 查找或创建实体节点(实体)
            添加边(节点.ID, 实体节点ID, "包含", 实体.置信度, false)
            添加边计数++
        }
    }
    
    返回 {
        添加节点: 添加节点计数,
        添加边: 添加边计数
    }
}

// 合并重复节点
函数 合并重复节点(相似度阈值: 浮点数 = 0.9) -> 整数 {
    如果 (!状态.已初始化) 抛出 新错误("知识网络未初始化")
    
    所有节点 = 获取所有节点()
    合并计数 = 0
    
    对于 (i = 0; i < 所有节点.长度; i++) {
        节点A = 所有节点[i]
        
        对于 (j = i + 1; j < 所有节点.长度; j++) {
            节点B = 所有节点[j]
            
            相似度 = 计算向量相似度(节点A.向量表示, 节点B.向量表示)
            
            如果 (相似度 >= 相似度阈值) {
                执行节点合并(节点A.ID, 节点B.ID)
                合并计数++
            }
        }
    }
    
    返回 合并计数
}

// 清理低可靠性节点
函数 清理网络() -> 整数 {
    如果 (!状态.已初始化) 抛出 新错误("知识网络未初始化")
    
    所有节点 = 获取所有节点()
    清理计数 = 0
    
    对于 (节点 在 所有节点) {
        如果 (节点.可靠性 < 配置.清理阈值) {
            移除节点(节点.ID)
            清理计数++
        }
    }
    
    返回 清理计数
}

// 内部函数：自动关联新节点与现有知识
内部函数 自动关联(新节点: 知识节点) -> 整数 {
    已添加边 = 0
    相关节点 = 查询节点(新节点.内容, 20)
    
    对于 (相关节点 在 相关节点) {
        如果 (相关节点.ID === 新节点.ID) 继续
        
        相关类型 = 确定关系类型(新节点, 相关节点)
        相关强度 = 计算向量相似度(新节点.向量表示, 相关节点.向量表示)
        
        如果 (相关强度 >= 配置.最小关联阈值) {
            添加边(新节点.ID, 相关节点.ID, 相关类型, 相关强度, false)
            已添加边++
        }
    }
    
    返回 已添加边
}

// 内部函数：确定两个节点之间的关系类型
内部函数 确定关系类型(节点A: 知识节点, 节点B: 知识节点) -> 字符串 {
    如果 (节点A.类型 === "概念" && 节点B.类型 === "实例") {
        返回 "是一个"
    } 否则如果 (节点A.类型 === "实例" && 节点B.类型 === "概念") {
        返回 "属于"
    } 否则如果 (节点A.类型 === 节点B.类型) {
        返回 "相关"
    } 否则 {
        内容A = 节点A.内容.toLowerCase()
        内容B = 节点B.内容.toLowerCase()
        
        如果 (内容A.包含(内容B) || 内容B.包含(内容A)) {
            返回 "部分的"
        }
        
        关系 = 分析器.发现关系(节点A.内容, 节点B.内容)
        如果 (关系 && 关系.类型) {
            返回 关系.类型
        }
        
        返回 "关联"
    }
} 