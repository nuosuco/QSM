/**
 * 文件关系分析器 - 分析文件间的相关性和关联关系
 * 版本: 1.0.0
 * 作者: QEntL团队
 * 描述: 该组件分析文件间的语义相关性、使用模式关联和内容相似度，为智能加载和推荐提供支持
 */

import { 记录日志 } from "../utils/logger.qentl";
import { 读取文件, 文件存在 } from "./file_operations.qentl";
import { 获取文件引用 } from "./dependency_analyzer.qentl";

/**
 * 文件关系分析器配置
 */
export const 配置 = {
  // 相关性缓存时间(毫秒)
  缓存时间: 180000, // 3分钟
  // 最大缓存项目数
  最大缓存项目数: 1000,
  // 最小相关度阈值(0-1)
  最小相关度阈值: 0.2,
  // 文件内容权重
  内容权重: 0.4,
  // 引用关系权重
  引用关系权重: 0.3,
  // 命名相似度权重
  命名相似度权重: 0.2,
  // 同目录权重
  同目录权重: 0.1,
  // 内容相似度计算方法: "jaccard", "cosine"
  相似度计算方法: "jaccard",
  // 内容分析最大字符数
  最大分析字符数: 10000,
  // 最大返回相关文件数
  最大返回文件数: 10,
  // 共同引用相关度增强系数
  共同引用增强系数: 1.5,
  // 是否分析引用网络
  分析引用网络: true,
  // 是否使用命名规则分析
  使用命名规则分析: true,
  // 命名规则映射(正则匹配)
  命名规则映射: [
    { 模式: /(.+)\.test\.(js|ts|jsx|tsx|qentl)$/, 匹配组: 1, 相关度: 0.9 },
    { 模式: /(.+)\.spec\.(js|ts|jsx|tsx|qentl)$/, 匹配组: 1, 相关度: 0.9 },
    { 模式: /(.+)\.d\.ts$/, 匹配组: 1, 相关度: 0.8 },
    { 模式: /(.+)(Controller|Service|Repository|Model)/, 匹配组: 1, 相关度: 0.7 },
    { 模式: /(index|main)\.(js|ts|jsx|tsx|qentl)$/, 相关度: 0.5 }
  ],
  // 要分析的文件类型
  文件类型: [
    "js", "ts", "jsx", "tsx", "qentl", "css", "scss", "html", "json"
  ]
};

/**
 * 文件相关性类型
 */
export type 文件相关性 = {
  // 相关文件路径
  路径: string;
  // 相关度分数(0-1)
  相关度: number;
  // 相关类型
  类型: string;
  // 相关原因描述
  原因器: string;
  // 计算时间
  计算时间: number;
};

/**
 * 文件相关度计算结果
 */
export type 相关度计算结果 = {
  // 源文件
  源文件: string;
  // 相关文件列表
  相关文件: 文件相关性[];
  // 计算时间
  计算时间: number;
};

/**
 * 文件关系分析器状态
 */
const 状态 = {
  // 是否已初始化
  已初始化: false,
  // 相关性缓存
  相关性缓存: new Map<string, 相关度计算结果>(),
  // 内容摘要缓存
  内容摘要缓存: new Map<string, string[]>(),
  // 统计信息
  统计: {
    分析文件数: 0,
    缓存命中数: 0,
    平均分析时间: 0
  }
};

/**
 * 初始化文件关系分析器
 */
export function 初始化(): boolean {
  if (状态.已初始化) {
    return true;
  }
  
  try {
    状态.已初始化 = true;
    状态.相关性缓存 = new Map();
    状态.内容摘要缓存 = new Map();
    状态.统计 = {
      分析文件数: 0,
      缓存命中数: 0,
      平均分析时间: 0
    };
    
    记录日志("INFO", "文件关系分析器初始化完成");
    
    // 启动定期清理任务
    setInterval(清理过期缓存, 配置.缓存时间 * 2);
    
    return true;
  } catch (error) {
    记录日志("ERROR", `文件关系分析器初始化失败: ${error}`);
    return false;
  }
}

/**
 * 分析文件相关性
 */
export async function 分析文件相关性(文件路径: string): Promise<文件相关性[]> {
  if (!状态.已初始化) {
    初始化();
  }
  
  // 检查参数
  if (!文件路径) {
    记录日志("ERROR", "分析文件相关性：文件路径不能为空");
    return [];
  }
  
  // 检查缓存
  if (状态.相关性缓存.has(文件路径)) {
    const 缓存项目 = 状态.相关性缓存.get(文件路径)!;
    const 当前时间 = Date.now();
    
    // 如果缓存未过期，直接返回
    if (当前时间 - 缓存项目.计算时间 < 配置.缓存时间) {
      状态.统计.缓存命中数++;
      return 缓存项目.相关文件;
    }
  }
  
  try {
    const 开始时间 = Date.now();
    
    // 检查文件是否存在
    if (!await 文件存在(文件路径)) {
      记录日志("ERROR", `分析文件相关性：文件不存在 ${文件路径}`);
      return [];
    }
    
    // 读取文件内容
    const 文件内容 = await 读取文件(文件路径);
    if (!文件内容) {
      记录日志("ERROR", `无法读取文件: ${文件路径}`);
      return [];
    }
    
    // 1. 基于文件路径和命名规则分析相关性
    const 命名相关文件 = 分析命名相关性(文件路径);
    
    // 2. 基于目录结构分析相关性
    const 目录相关文件 = 分析目录相关性(文件路径);
    
    // 3. 基于引用关系分析相关性
    const 引用相关文件 = await 分析引用相关性(文件路径);
    
    // 4. 基于内容相似度分析相关性
    const 内容相关文件 = await 分析内容相关性(文件路径, 文件内容);
    
    // 合并所有相关文件
    const 所有相关文件 = [...命名相关文件, ...目录相关文件, ...引用相关文件, ...内容相关文件];
    
    // 合并相同路径的相关文件，调整相关度分数
    const 合并结果 = 合并相关文件(所有相关文件);
    
    // 过滤掉相关度低于阈值的文件
    const 过滤结果 = 合并结果
      .filter(项 => 项.相关度 >= 配置.最小相关度阈值 && 项.路径 !== 文件路径)
      .sort((a, b) => b.相关度 - a.相关度)
      .slice(0, 配置.最大返回文件数);
    
    // 添加计算时间
    过滤结果.forEach(项 => {
      项.计算时间 = Date.now();
    });
    
    // 更新统计信息
    状态.统计.分析文件数++;
    const 分析时间 = Date.now() - 开始时间;
    状态.统计.平均分析时间 = (状态.统计.平均分析时间 * (状态.统计.分析文件数 - 1) + 分析时间) / 状态.统计.分析文件数;
    
    // 添加到缓存
    const 结果: 相关度计算结果 = {
      源文件: 文件路径,
      相关文件: 过滤结果,
      计算时间: Date.now()
    };
    状态.相关性缓存.set(文件路径, 结果);
    
    // 控制缓存大小
    if (状态.相关性缓存.size > 配置.最大缓存项目数) {
      清理过期缓存();
    }
    
    记录日志("DEBUG", `完成文件相关性分析: ${文件路径} (找到${过滤结果.length}个相关文件, ${分析时间}ms)`);
    
    return 过滤结果;
  } catch (error) {
    记录日志("ERROR", `分析文件相关性失败: ${error}`);
    return [];
  }
}

/**
 * 分析相关性 - 为预测加载器提供简化接口
 */
export function 分析相关性(文件路径: string): 文件相关性[] {
  if (!状态.已初始化) {
    初始化();
  }
  
  // 检查缓存
  if (状态.相关性缓存.has(文件路径)) {
    const 缓存项目 = 状态.相关性缓存.get(文件路径)!;
    const 当前时间 = Date.now();
    
    // 如果缓存未过期，直接返回
    if (当前时间 - 缓存项目.计算时间 < 配置.缓存时间) {
      状态.统计.缓存命中数++;
      return 缓存项目.相关文件;
    }
  }
  
  // 异步分析，但返回空数组
  // 下次查询时可能会有缓存结果
  分析文件相关性(文件路径).then(() => {
    记录日志("DEBUG", `异步完成文件相关性分析: ${文件路径}`);
  }).catch(error => {
    记录日志("ERROR", `异步分析文件相关性失败: ${error}`);
  });
  
  return [];
}

/**
 * 清除缓存
 */
export function 清除缓存(文件路径器: string): void {
  if (文件路径) {
    // 清除特定文件的缓存
    状态.相关性缓存.delete(文件路径);
    状态.内容摘要缓存.delete(文件路径);
  } else {
    // 清除所有缓存
    状态.相关性缓存.clear();
    状态.内容摘要缓存.clear();
  }
  
  记录日志("DEBUG", `已清除关系分析缓存${文件路径 器 `: ${文件路径}` : ''}`);
}

/**
 * 获取统计信息
 */
export function 获取统计(): any {
  return {
    ...状态.统计,
    缓存大小: {
      相关性缓存: 状态.相关性缓存.size,
      内容摘要缓存: 状态.内容摘要缓存.size
    }
  };
}

/**
 * 内部方法: 分析命名相关性
 */
function 分析命名相关性(文件路径: string): 文件相关性[] {
  if (!配置.使用命名规则分析) {
    return [];
  }
  
  try {
    const 相关文件: 文件相关性[] = [];
    
    // 获取文件名
    const 文件名 = 获取文件名(文件路径);
    
    // 分析命名规则
    for (const 规则 of 配置.命名规则映射) {
      const 匹配结果 = 文件名.match(规则.模式);
      if (匹配结果) {
        // 提取基础名称
        const 基础名称 = 规则.匹配组 !== undefined 器 匹配结果[规则.匹配组] : 文件名;
        
        // 查找其他可能相关的文件
        for (const [缓存路径] of 状态.相关性缓存.entries()) {
          const 缓存文件名 = 获取文件名(缓存路径);
          if (缓存文件名.includes(基础名称) && 缓存路径 !== 文件路径) {
            相关文件.push({
              路径: 缓存路径,
              相关度: 规则.相关度,
              类型: "命名相关",
              原因: `基于命名规则:${规则.模式}`,
              计算时间: Date.now()
            });
          }
        }
      }
    }
    
    return 相关文件;
  } catch (error) {
    记录日志("ERROR", `分析命名相关性失败: ${error}`);
    return [];
  }
}

/**
 * 内部方法: 分析目录相关性
 */
function 分析目录相关性(文件路径: string): 文件相关性[] {
  try {
    const 相关文件: 文件相关性[] = [];
    
    // 获取文件所在目录
    const 目录路径 = 获取文件目录(文件路径);
    
    // 检查缓存中的文件是否在同一目录
    for (const [缓存路径] of 状态.相关性缓存.entries()) {
      const 缓存文件目录 = 获取文件目录(缓存路径);
      if (缓存文件目录 === 目录路径 && 缓存路径 !== 文件路径) {
        // 计算相关度 - 同目录文件具有基础相关度
        相关文件.push({
          路径: 缓存路径,
          相关度: 配置.同目录权重,
          类型: "目录相关",
          原因: `同目录文件`,
          计算时间: Date.now()
        });
      }
    }
    
    return 相关文件;
  } catch (error) {
    记录日志("ERROR", `分析目录相关性失败: ${error}`);
    return [];
  }
}

/**
 * 内部方法: 分析引用相关性
 */
async function 分析引用相关性(文件路径: string): Promise<文件相关性[]> {
  if (!配置.分析引用网络) {
    return [];
  }
  
  try {
    const 相关文件: 文件相关性[] = [];
    
    // 获取文件的引用
    const 文件引用列表 = 获取文件引用(文件路径);
    
    // 如果有直接引用，添加相关性
    for (const 引用 of 文件引用列表) {
      相关文件.push({
        路径: 引用.路径,
        相关度: 引用.重要性 * 配置.引用关系权重,
        类型: "直接引用",
        原因: `直接${引用.类型}引用`,
        计算时间: Date.now()
      });
    }
    
    // 分析共同引用 - 找到引用了相同文件的其他文件
    if (文件引用列表.length > 0) {
      // 从缓存获取其他文件的依赖信息
      for (const [缓存路径, 缓存项] of 状态.相关性缓存.entries()) {
        if (缓存路径 === 文件路径) continue;
        
        // 检查是否有共同引用
        let 共同引用计数 = 0;
        for (const 相关文件项 of 缓存项.相关文件) {
          if (相关文件项.类型 === "直接引用") {
            const 是共同引用 = 文件引用列表.some(引用 => 
              引用.路径 === 相关文件项.路径);
            
            if (是共同引用) {
              共同引用计数++;
            }
          }
        }
        
        // 如果有共同引用，添加相关性
        if (共同引用计数 > 0) {
          const 共同引用比例 = 共同引用计数 / Math.max(文件引用列表.length, 1);
          相关文件.push({
            路径: 缓存路径,
            相关度: 共同引用比例 * 配置.引用关系权重 * 配置.共同引用增强系数,
            类型: "共同引用",
            原因: `共享${共同引用计数}个共同引用`,
            计算时间: Date.now()
          });
        }
      }
    }
    
    return 相关文件;
  } catch (error) {
    记录日志("ERROR", `分析引用相关性失败: ${error}`);
    return [];
  }
}

/**
 * 内部方法: 分析内容相关性
 */
async function 分析内容相关性(文件路径: string, 文件内容: string): Promise<文件相关性[]> {
  try {
    const 相关文件: 文件相关性[] = [];
    
    // 生成当前文件的内容摘要
    const 当前文件摘要 = 生成内容摘要(文件内容);
    
    // 添加到缓存
    状态.内容摘要缓存.set(文件路径, 当前文件摘要);
    
    // 与缓存中的其他文件比较内容相似度
    for (const [缓存路径, 缓存摘要] of 状态.内容摘要缓存.entries()) {
      if (缓存路径 === 文件路径) continue;
      
      // 计算内容相似度
      const 相似度 = 计算内容相似度(当前文件摘要, 缓存摘要);
      
      // 如果相似度足够高，添加相关性
      if (相似度 > 0.1) {
        相关文件.push({
          路径: 缓存路径,
          相关度: 相似度 * 配置.内容权重,
          类型: "内容相似",
          原因: `内容相似度:${相似度.toFixed(2)}`,
          计算时间: Date.now()
        });
      }
    }
    
    return 相关文件;
  } catch (error) {
    记录日志("ERROR", `分析内容相关性失败: ${error}`);
    return [];
  }
}

/**
 * 内部方法: 生成内容摘要
 */
function 生成内容摘要(文件内容: string): string[] {
  try {
    // 限制分析内容大小
    const 分析内容 = 文件内容.substring(0, 配置.最大分析字符数);
    
    // 移除注释、空行和多余空格
    const 清理内容 = 分析内容
      .replace(/\/\/.*|\/\*[\s\S]*器\*\//g, '') // 移除注释
      .replace(/^\s*[\r\n]/gm, '') // 移除空行
      .replace(/\s+/g, ' ') // 合并空格
      .trim();
    
    // 提取关键词和标识符
    const 标识符正则 = /\b[a-zA-Z_]\w*\b/g;
    const 所有标识符 = 清理内容.match(标识符正则) || [];
    
    // 过滤掉常见的关键词
    const 常见关键词 = new Set([
      'const', 'let', 'var', 'function', 'return', 'if', 'else', 'for', 'while',
      'import', 'export', 'from', 'class', 'interface', 'type', 'interface',
      'public', 'private', 'protected', 'static', 'new', 'this', 'super',
      'try', 'catch', 'finally', 'throw', 'async', 'await'
    ]);
    
    const 有效标识符 = 所有标识符.filter(单词 => 
      !常见关键词.has(单词) && 单词.length > 1
    );
    
    // 保留最有信息量的标识符，按频率排序
    const 频率表 = new Map<string, number>();
    for (const 标识符 of 有效标识符) {
      频率表.set(标识符, (频率表.get(标识符) || 0) + 1);
    }
    
    // 转换为数组并排序
    const 排序标识符 = Array.from(频率表.entries())
      .sort((a, b) => b[1] - a[1])
      .map(([标识符]) => 标识符)
      .slice(0, 100); // 最多保留100个标识符
    
    return 排序标识符;
  } catch (error) {
    记录日志("ERROR", `生成内容摘要失败: ${error}`);
    return [];
  }
}

/**
 * 内部方法: 计算内容相似度
 */
function 计算内容相似度(摘要1: string[], 摘要2: string[]): number {
  try {
    if (摘要1.length === 0 || 摘要2.length === 0) {
      return 0;
    }
    
    // 根据配置选择相似度计算方法
    if (配置.相似度计算方法 === "cosine") {
      return 计算余弦相似度(摘要1, 摘要2);
    } else {
      // 默认使用Jaccard相似度
      return 计算Jaccard相似度(摘要1, 摘要2);
    }
  } catch (error) {
    记录日志("ERROR", `计算内容相似度失败: ${error}`);
    return 0;
  }
}

/**
 * 内部方法: 计算Jaccard相似度
 */
function 计算Jaccard相似度(集合1: string[], 集合2: string[]): number {
  try {
    const 集合A = new Set(集合1);
    const 集合B = new Set(集合2);
    
    // 计算交集大小
    let 交集大小 = 0;
    for (const 项 of 集合A) {
      if (集合B.has(项)) {
        交集大小++;
      }
    }
    
    // 计算并集大小
    const 并集大小 = 集合A.size + 集合B.size - 交集大小;
    
    // 防止除以零
    if (并集大小 === 0) {
      return 0;
    }
    
    return 交集大小 / 并集大小;
  } catch (error) {
    记录日志("ERROR", `计算Jaccard相似度失败: ${error}`);
    return 0;
  }
}

/**
 * 内部方法: 计算余弦相似度
 */
function 计算余弦相似度(向量1: string[], 向量2: string[]): number {
  try {
    // 构建词频向量
    const 词频1 = new Map<string, number>();
    const 词频2 = new Map<string, number>();
    
    // 统计第一个向量的词频
    for (const 词 of 向量1) {
      词频1.set(词, (词频1.get(词) || 0) + 1);
    }
    
    // 统计第二个向量的词频
    for (const 词 of 向量2) {
      词频2.set(词, (词频2.get(词) || 0) + 1);
    }
    
    // 收集所有唯一词汇
    const 所有词汇 = new Set([...词频1.keys(), ...词频2.keys()]);
    
    // 计算点积
    let 点积 = 0;
    let 向量1长度平方 = 0;
    let 向量2长度平方 = 0;
    
    for (const 词 of 所有词汇) {
      const 频率1 = 词频1.get(词) || 0;
      const 频率2 = 词频2.get(词) || 0;
      
      点积 += 频率1 * 频率2;
      向量1长度平方 += 频率1 * 频率1;
      向量2长度平方 += 频率2 * 频率2;
    }
    
    // 计算向量长度
    const 向量1长度 = Math.sqrt(向量1长度平方);
    const 向量2长度 = Math.sqrt(向量2长度平方);
    
    // 防止除以零
    if (向量1长度 === 0 || 向量2长度 === 0) {
      return 0;
    }
    
    // 返回余弦相似度
    return 点积 / (向量1长度 * 向量2长度);
  } catch (error) {
    记录日志("ERROR", `计算余弦相似度失败: ${error}`);
    return 0;
  }
}

/**
 * 内部方法: 合并相关文件
 */
function 合并相关文件(相关文件列表: 文件相关性[]): 文件相关性[] {
  try {
    // 按路径分组
    const 路径分组 = new Map<string, 文件相关性[]>();
    
    for (const 相关项 of 相关文件列表) {
      const 现有组 = 路径分组.get(相关项.路径) || [];
      现有组.push(相关项);
      路径分组.set(相关项.路径, 现有组);
    }
    
    // 合并每个路径的多个相关项
    const 结果: 文件相关性[] = [];
    
    for (const [路径, 组] of 路径分组.entries()) {
      if (组.length === 1) {
        // 只有一个相关项，直接添加
        结果.push(组[0]);
      } else {
        // 多个相关项，合并相关度和原因
        // 计算组合相关度 - 使用概率组合方法
        let 组合相关度 = 0;
        const 原因列表: string[] = [];
        
        for (const 项 of 组) {
          // 使用概率累加公式: P(A∪B) = P(A) + P(B) - P(A)P(B)
          组合相关度 = 组合相关度 + 项.相关度 - 组合相关度 * 项.相关度;
          
          if (项.原因) {
            原因列表.push(项.原因);
          }
        }
        
        // 创建合并项
        结果.push({
          路径,
          相关度: Math.min(1, 组合相关度), // 确保相关度不超过1
          类型: 组.map(项 => 项.类型).join(","),
          原因: 原因列表.join("; "),
          计算时间: Date.now()
        });
      }
    }
    
    return 结果;
  } catch (error) {
    记录日志("ERROR", `合并相关文件失败: ${error}`);
    return 相关文件列表;
  }
}

/**
 * 内部方法: 获取文件名
 */
function 获取文件名(文件路径: string): string {
  try {
    // 移除路径，只保留文件名
    const 最后分隔符索引 = Math.max(
      文件路径.lastIndexOf('/'), 
      文件路径.lastIndexOf('\\')
    );
    
    if (最后分隔符索引 >= 0) {
      return 文件路径.substring(最后分隔符索引 + 1);
    }
    
    return 文件路径;
  } catch (error) {
    记录日志("ERROR", `获取文件名失败: ${error}`);
    return 文件路径;
  }
}

/**
 * 内部方法: 获取文件目录
 */
function 获取文件目录(文件路径: string): string {
  try {
    // 获取文件所在目录路径
    const 最后分隔符索引 = Math.max(
      文件路径.lastIndexOf('/'), 
      文件路径.lastIndexOf('\\')
    );
    
    if (最后分隔符索引 >= 0) {
      return 文件路径.substring(0, 最后分隔符索引);
    }
    
    return "";
  } catch (error) {
    记录日志("ERROR", `获取文件目录失败: ${error}`);
    return "";
  }
}

/**
 * 内部方法: 清理过期缓存
 */
function 清理过期缓存() {
  try {
    const 当前时间 = Date.now();
    let 清理计数 = 0;
    
    // 找出过期的缓存项
    const 过期相关性项 = [];
    for (const [路径, 结果] of 状态.相关性缓存.entries()) {
      if (当前时间 - 结果.计算时间 > 配置.缓存时间) {
        过期相关性项.push(路径);
      }
    }
    
    // 删除过期项
    for (const 路径 of 过期相关性项) {
      状态.相关性缓存.delete(路径);
      // 同时清理内容摘要缓存
      状态.内容摘要缓存.delete(路径);
      清理计数++;
    }
    
    // 如果缓存还是太大，删除最老的项目
    if (状态.相关性缓存.size > 配置.最大缓存项目数) {
      // 按分析时间排序
      const 排序项 = Array.from(状态.相关性缓存.entries())
        .sort((a, b) => a[1].计算时间 - b[1].计算时间);
      
      // 计算需要删除的数量
      const 删除数量 = 状态.相关性缓存.size - 配置.最大缓存项目数;
      
      // 删除最老的项目
      for (let i = 0; i < 删除数量 && i < 排序项.length; i++) {
        const 路径 = 排序项[i][0];
        状态.相关性缓存.delete(路径);
        状态.内容摘要缓存.delete(路径);
        清理计数++;
      }
    }
    
    if (清理计数 > 0) {
      记录日志("DEBUG", `已清理${清理计数}个过期关系分析缓存项，当前缓存大小: ${状态.相关性缓存.size}`);
    }
  } catch (error) {
    记录日志("ERROR", `清理过期缓存失败: ${error}`);
  }
}

// 导出默认接口
export default {
  初始化,
  分析文件相关性,
  分析相关性,
  清除缓存,
  获取统计
}; 