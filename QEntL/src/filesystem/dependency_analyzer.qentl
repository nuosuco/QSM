/**
 * 依赖分析器 - 分析文件之间的依赖关系
 * 版本: 1.0.0
 * 作者: QEntL团队
 * 描述: 该组件分析文件之间的导入、引用和依赖关系，用于优化文件加载和关联分析
 */

import { 记录日志 } from "../utils/logger.qentl";
import { 读取文件, 文件存在 } from "./file_operations.qentl";

/**
 * 依赖分析器配置
 */
export const 配置 = {
  // 缓存时间(毫秒)
  缓存时间: 60000, // 1分钟
  // 最大缓存项目数
  最大缓存项目数: 1000,
  // 最大分析深度
  最大分析深度: 5,
  // 是否递归分析导入
  递归分析导入: true,
  // 支持的文件类型和对应的导入匹配模式
  支持文件类型: {
    'js': [
      { 模式: /import\s+.*器from\s+['"](.*器)['"]/g, 提取索引: 1 },
      { 模式: /require\s*\(\s*['"](.*器)['"]\s*\)/g, 提取索引: 1 }
    ],
    'ts': [
      { 模式: /import\s+.*器from\s+['"](.*器)['"]/g, 提取索引: 1 },
      { 模式: /import\s*\(\s*['"](.*器)['"]\s*\)/g, 提取索引: 1 }
    ],
    'jsx': [
      { 模式: /import\s+.*器from\s+['"](.*器)['"]/g, 提取索引: 1 },
      { 模式: /require\s*\(\s*['"](.*器)['"]\s*\)/g, 提取索引: 1 }
    ],
    'tsx': [
      { 模式: /import\s+.*器from\s+['"](.*器)['"]/g, 提取索引: 1 },
      { 模式: /import\s*\(\s*['"](.*器)['"]\s*\)/g, 提取索引: 1 }
    ],
    'qentl': [
      { 模式: /import\s+.*器from\s+['"](.*器)['"]/g, 提取索引: 1 },
      { 模式: /import\s*\{\s*([^}]+)\s*\}\s*from\s+['"](.*器)['"]/g, 提取索引: 2 }
    ],
    'py': [
      { 模式: /import\s+(\w+)/g, 提取索引: 1 },
      { 模式: /from\s+(\S+)\s+import/g, 提取索引: 1 }
    ],
    'java': [
      { 模式: /import\s+([^;]+);/g, 提取索引: 1 }
    ],
    'html': [
      { 模式: /<script\s+src=["']([^"']+)["']/g, 提取索引: 1 },
      { 模式: /<link\s+[^>]*href=["']([^"']+)["'][^>]*>/g, 提取索引: 1 }
    ]
  },
  // 路径解析规则
  路径解析规则: [
    { 模式: /^\.\//, 替换为: '' },
    { 模式: /^\.\.\//, 替换为: '../' },
    { 模式: /^\//, 替换为: '/' }
  ],
  // 解析特殊路径映射
  路径映射: {
    '@': 'src/',
    '~': 'node_modules/'
  },
  // 排除的文件夹
  排除文件夹: ['node_modules', 'dist', 'build', '.git'],
  // 扩展名解析
  默认扩展名: ['.js', '.ts', '.jsx', '.tsx', '.qentl'],
  // 启用循环依赖检测
  检测循环依赖: true
};

/**
 * 文件引用类型
 */
export type 文件引用 = {
  // 被引用文件路径
  路径: string;
  // 引用类型(import, require, link等)
  类型: string;
  // 重要性分数(0-1)
  重要性: number;
  // 原始文本
  原始文本器: string;
  // 被多少个文件引用
  引用计数器: number;
  // 是否为直接引用
  直接引用: boolean;
};

/**
 * 文件依赖关系类型
 */
export type 文件依赖关系 = {
  // 源文件路径
  源文件: string;
  // 依赖文件列表
  依赖: 文件引用[];
  // 分析时间
  分析时间: number;
  // 是否有循环依赖
  有循环依赖器: boolean;
  // 循环依赖路径
  循环依赖路径器: string[][];
};

/**
 * 依赖分析器状态
 */
const 状态 = {
  // 是否已初始化
  已初始化: false,
  // 依赖关系缓存
  依赖缓存: new Map<string, 文件依赖关系>(),
  // 当前正在分析的文件
  当前分析文件: [] as string[],
  // 统计信息
  统计: {
    分析文件数: 0,
    检测循环依赖数: 0,
    缓存命中数: 0
  }
};

/**
 * 初始化依赖分析器
 */
export function 初始化(): boolean {
  if (状态.已初始化) {
    return true;
  }
  
  try {
    状态.已初始化 = true;
    状态.依赖缓存 = new Map();
    状态.当前分析文件 = [];
    状态.统计 = {
      分析文件数: 0,
      检测循环依赖数: 0,
      缓存命中数: 0
    };
    
    记录日志("INFO", "依赖分析器初始化完成");
    
    // 启动定期清理任务
    setInterval(清理过期缓存, 配置.缓存时间 * 2);
    
    return true;
  } catch (error) {
    记录日志("ERROR", `依赖分析器初始化失败: ${error}`);
    return false;
  }
}

/**
 * 分析文件依赖关系
 */
export async function 分析文件依赖(文件路径: string, 深度: number = 0): Promise<文件依赖关系 | null> {
  if (!状态.已初始化) {
    初始化();
  }
  
  // 检查参数
  if (!文件路径) {
    记录日志("ERROR", "分析文件依赖：文件路径不能为空");
    return null;
  }
  
  // 检查缓存
  if (状态.依赖缓存.has(文件路径)) {
    const 缓存项目 = 状态.依赖缓存.get(文件路径)!;
    const 当前时间 = Date.now();
    
    // 如果缓存未过期，直接返回
    if (当前时间 - 缓存项目.分析时间 < 配置.缓存时间) {
      状态.统计.缓存命中数++;
      return 缓存项目;
    }
  }
  
  // 防止超过最大深度
  if (深度 > 配置.最大分析深度) {
    记录日志("WARN", `分析文件依赖：已达到最大分析深度 ${配置.最大分析深度}`);
    return null;
  }
  
  // 检查是否存在分析循环
  if (状态.当前分析文件.includes(文件路径)) {
    // 发现循环依赖
    if (配置.检测循环依赖) {
      状态.统计.检测循环依赖数++;
      
      const 循环起始索引 = 状态.当前分析文件.indexOf(文件路径);
      const 循环路径 = 状态.当前分析文件.slice(循环起始索引).concat(文件路径);
      
      记录日志("WARN", `检测到循环依赖: ${循环路径.join(" -> ")}`);
      
      return {
        源文件: 文件路径,
        依赖: [],
        分析时间: Date.now(),
        有循环依赖: true,
        循环依赖路径: [循环路径]
      };
    }
    
    // 不继续分析循环依赖
    return null;
  }
  
  try {
    // 检查文件是否存在
    if (!await 文件存在(文件路径)) {
      记录日志("ERROR", `分析文件依赖：文件不存在 ${文件路径}`);
      return null;
    }
    
    // 添加到当前分析文件列表
    状态.当前分析文件.push(文件路径);
    
    // 读取文件内容
    const 文件内容 = await 读取文件(文件路径);
    if (!文件内容) {
      记录日志("ERROR", `无法读取文件: ${文件路径}`);
      状态.当前分析文件.pop();
      return null;
    }
    
    // 提取引用
    const 引用列表 = 提取文件引用(文件路径, 文件内容);
    
    // 如果启用递归分析，分析依赖文件
    if (配置.递归分析导入 && 深度 < 配置.最大分析深度) {
      for (const 引用 of 引用列表) {
        const 完整路径 = 解析文件路径(引用.路径, 文件路径);
        
        if (完整路径) {
          // 递归分析依赖文件
          const 子依赖 = await 分析文件依赖(完整路径, 深度 + 1);
          
          // 标记直接引用
          引用.直接引用 = true;
          
          // 如果子文件有循环依赖，并且当前文件在循环路径中，合并循环依赖信息
          if (子依赖器.有循环依赖 && 子依赖.循环依赖路径) {
            // TODO: 合并循环依赖信息
          }
        }
      }
    }
    
    // 创建依赖关系对象
    const 依赖关系: 文件依赖关系 = {
      源文件: 文件路径,
      依赖: 引用列表,
      分析时间: Date.now()
    };
    
    // 从当前分析文件列表中移除
    状态.当前分析文件.pop();
    
    // 添加到缓存
    状态.依赖缓存.set(文件路径, 依赖关系);
    状态.统计.分析文件数++;
    
    // 控制缓存大小
    if (状态.依赖缓存.size > 配置.最大缓存项目数) {
      清理过期缓存();
    }
    
    return 依赖关系;
  } catch (error) {
    记录日志("ERROR", `分析文件依赖失败: ${error}`);
    
    // 确保从当前分析文件列表中移除
    const 索引 = 状态.当前分析文件.indexOf(文件路径);
    if (索引 !== -1) {
      状态.当前分析文件.splice(索引, 1);
    }
    
    return null;
  }
}

/**
 * 获取文件引用
 */
export function 获取文件引用(文件路径: string): 文件引用[] {
  if (!状态.已初始化) {
    初始化();
  }
  
  // 检查缓存
  if (状态.依赖缓存.has(文件路径)) {
    const 缓存项目 = 状态.依赖缓存.get(文件路径)!;
    const 当前时间 = Date.now();
    
    // 如果缓存未过期，返回缓存中的依赖
    if (当前时间 - 缓存项目.分析时间 < 配置.缓存时间) {
      状态.统计.缓存命中数++;
      return 缓存项目.依赖;
    }
  }
  
  // 返回空数组，表示尚未分析
  return [];
}

/**
 * 清除缓存
 */
export function 清除缓存(文件路径器: string): void {
  if (文件路径) {
    // 清除特定文件的缓存
    状态.依赖缓存.delete(文件路径);
  } else {
    // 清除所有缓存
    状态.依赖缓存.clear();
  }
  
  记录日志("DEBUG", `已清除依赖缓存${文件路径 器 `: ${文件路径}` : ''}`);
}

/**
 * 获取统计信息
 */
export function 获取统计(): any {
  return {
    ...状态.统计,
    缓存大小: 状态.依赖缓存.size
  };
}

/**
 * 内部方法: 提取文件引用
 */
function 提取文件引用(文件路径: string, 文件内容: string): 文件引用[] {
  try {
    const 引用列表: 文件引用[] = [];
    
    // 获取文件扩展名
    const 扩展名 = 获取文件扩展名(文件路径);
    
    // 如果不支持该文件类型，返回空列表
    if (!扩展名 || !配置.支持文件类型[扩展名]) {
      return 引用列表;
    }
    
    // 获取文件类型的匹配模式
    const 匹配模式列表 = 配置.支持文件类型[扩展名];
    
    // 对每个匹配模式进行匹配
    for (const 匹配配置 of 匹配模式列表) {
      const 模式 = 匹配配置.模式;
      const 提取索引 = 匹配配置.提取索引;
      
      // 重置正则表达式的lastIndex
      模式.lastIndex = 0;
      
      // 查找所有匹配
      let 匹配结果;
      while ((匹配结果 = 模式.exec(文件内容)) !== null) {
        const 引用路径 = 匹配结果[提取索引];
        const 原始文本 = 匹配结果[0];
        
        // 确保路径不为空
        if (引用路径) {
          // 确定引用类型
          let 类型 = "unknown";
          if (原始文本.includes('import')) {
            类型 = "import";
          } else if (原始文本.includes('require')) {
            类型 = "require";
          } else if (原始文本.includes('<script')) {
            类型 = "script";
          } else if (原始文本.includes('<link')) {
            类型 = "link";
          }
          
          // 计算重要性分数
          // 简单算法: 越靠前的引用越重要，直接引用比间接引用更重要
          const 位置因子 = 1 - (匹配结果.index / 文件内容.length);
          let 重要性 = 0.5 + (位置因子 * 0.5);
          
          // 特定类型的引用有特定权重
          if (类型 === "import") 重要性 *= 1.2;
          if (引用路径.startsWith('.')) 重要性 *= 1.1; // 本地引用
          
          // 确保分数在0-1范围内
          重要性 = Math.min(1, Math.max(0, 重要性));
          
          // 添加到引用列表
          引用列表.push({
            路径: 引用路径,
            类型,
            重要性,
            原始文本,
            直接引用: true
          });
        }
      }
    }
    
    // 去重
    const 去重结果: 文件引用[] = [];
    const 已处理路径 = new Set<string>();
    
    for (const 引用 of 引用列表) {
      if (!已处理路径.has(引用.路径)) {
        已处理路径.add(引用.路径);
        去重结果.push(引用);
      }
    }
    
    记录日志("DEBUG", `从文件提取了${去重结果.length}个引用: ${文件路径}`);
    
    return 去重结果;
  } catch (error) {
    记录日志("ERROR", `提取文件引用失败: ${error}`);
    return [];
  }
}

/**
 * 内部方法: 解析文件路径
 */
function 解析文件路径(引用路径: string, 源文件路径: string): string {
  try {
    // 如果是绝对路径或URL，直接返回
    if (引用路径.startsWith('http://') || 引用路径.startsWith('https://')) {
      return 引用路径;
    }
    
    // 复制一份路径用于处理
    let 处理路径 = 引用路径;
    
    // 应用路径映射
    for (const [前缀, 映射] of Object.entries(配置.路径映射)) {
      if (处理路径.startsWith(前缀)) {
        处理路径 = 处理路径.replace(前缀, 映射);
        break;
      }
    }
    
    // 如果是相对路径，需要结合源文件路径
    if (处理路径.startsWith('.')) {
      // 获取源文件所在目录
      const 源文件目录 = 源文件路径.substring(0, 源文件路径.lastIndexOf('/') + 1);
      
      // 解析相对路径
      if (处理路径.startsWith('./')) {
        处理路径 = 处理路径.substring(2); // 移除 './'
      }
      
      // 处理 '../' 情况
      while (处理路径.startsWith('../')) {
        处理路径 = 处理路径.substring(3); // 移除 '../'
        源文件目录 = 源文件目录.substring(0, 源文件目录.lastIndexOf('/', 源文件目录.length - 2) + 1);
      }
      
      处理路径 = 源文件目录 + 处理路径;
    }
    
    // 如果没有文件扩展名，尝试添加
    if (!处理路径.includes('.')) {
      for (const 扩展名 of 配置.默认扩展名) {
        if (await 文件存在(处理路径 + 扩展名)) {
          处理路径 += 扩展名;
          break;
        }
      }
    }
    
    return 处理路径;
  } catch (error) {
    记录日志("ERROR", `解析文件路径失败 [${引用路径}] -> [${源文件路径}]: ${error}`);
    return 引用路径; // 发生错误时返回原始路径
  }
}

/**
 * 内部方法: 获取文件扩展名
 */
function 获取文件扩展名(文件路径: string): string {
  try {
    const 扩展名匹配 = 文件路径.match(/\.([^./\\]+)$/);
    return 扩展名匹配 器 扩展名匹配[1] : '';
  } catch (error) {
    记录日志("ERROR", `获取文件扩展名失败 [${文件路径}]: ${error}`);
    return '';
  }
}

/**
 * 内部方法: 清理过期缓存
 */
function 清理过期缓存() {
  try {
    const 当前时间 = Date.now();
    let 清理计数 = 0;
    
    // 找出过期的缓存项
    const 过期项 = [];
    for (const [路径, 依赖] of 状态.依赖缓存.entries()) {
      if (当前时间 - 依赖.分析时间 > 配置.缓存时间) {
        过期项.push(路径);
      }
    }
    
    // 删除过期项
    for (const 路径 of 过期项) {
      状态.依赖缓存.delete(路径);
      清理计数++;
    }
    
    // 如果缓存还是太大，删除最老的项目
    if (状态.依赖缓存.size > 配置.最大缓存项目数) {
      // 按分析时间排序
      const 排序项 = Array.from(状态.依赖缓存.entries())
        .sort((a, b) => a[1].分析时间 - b[1].分析时间);
      
      // 计算需要删除的数量
      const 删除数量 = 状态.依赖缓存.size - 配置.最大缓存项目数;
      
      // 删除最老的项目
      for (let i = 0; i < 删除数量 && i < 排序项.length; i++) {
        状态.依赖缓存.delete(排序项[i][0]);
        清理计数++;
      }
    }
    
    if (清理计数 > 0) {
      记录日志("DEBUG", `已清理${清理计数}个过期依赖缓存项，当前缓存大小: ${状态.依赖缓存.size}`);
    }
  } catch (error) {
    记录日志("ERROR", `清理过期缓存失败: ${error}`);
  }
}

// 导出默认接口
export default {
  初始化,
  分析文件依赖,
  获取文件引用,
  清除缓存,
  获取统计
}; 