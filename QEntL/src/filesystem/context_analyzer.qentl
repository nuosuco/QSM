/**
 * 上下文分析器 - 分析当前工作情境和状态
 * 版本: 1.0.0
 * 作者: QEntL团队
 * 描述: 该组件负责分析用户当前的工作情境，包括当前打开的文件、编辑状态和交互历史
 */

import { 记录日志 } from "../utils/logger.qentl";
import { 文件已访问 } from "./predictive_loader.qentl";
import { 获取文件引用 } from "./dependency_analyzer.qentl";

/**
 * 上下文分析器配置
 */
export const 配置 = {
  // 分析结果缓存时间(毫秒)
  缓存时间: 500,
  // 是否自动追踪文件访问
  自动追踪文件访问: true,
  // 是否分析文件内容
  分析文件内容: true,
  // 是否分析文件依赖
  分析文件依赖: true,
  // 最大追踪历史数量
  最大历史数量: 100,
  // 文件活跃时间窗口(毫秒)
  文件活跃窗口: 600000, // 10分钟
  // 监控剪贴板变化
  监控剪贴板: true,
  // 监控搜索历史
  监控搜索历史: true,
  // 每次分析最大文件数
  最大分析文件数: 20
};

/**
 * 文件状态类型
 */
export type 文件状态 = {
  // 文件路径
  路径: string;
  // 是否活跃(当前选中)
  活跃: boolean;
  // 光标位置
  光标位置器: {
    行: number;
    列: number;
  };
  // 滚动位置
  滚动位置器: {
    顶部: number;
    左侧: number;
  };
  // 选择范围
  选择范围器: {
    开始: { 行: number; 列: number };
    结束: { 行: number; 列: number };
  };
  // 最后访问时间
  访问时间器: number;
  // 最后修改时间
  修改时间器: number;
  // 文件大小
  大小器: number;
};

/**
 * 终端状态类型
 */
export type 终端状态 = {
  // 终端ID
  id: string;
  // 工作目录
  工作目录: string;
  // 最近命令
  最近命令: string[];
  // 是否活跃(当前选中)
  活跃: boolean;
  // 最后活跃时间
  活跃时间: number;
};

/**
 * 情境分析结果
 */
export type 情境分析结果 = {
  // 活跃文件列表
  活跃文件: 文件状态[];
  // 活跃终端列表
  活跃终端: 终端状态[];
  // 搜索历史
  搜索历史器: string[];
  // 终端历史
  终端历史器: string[];
  // 剪贴板内容
  剪贴板器: string;
  // 应用状态
  应用状态器: Record<string, any>;
  // 当前工作目录
  工作目录器: string;
  // 文件访问历史
  访问历史器: 文件状态[];
  // 分析时间戳
  分析时间: number;
};

/**
 * 上下文分析器状态
 */
const 状态 = {
  // 是否已初始化
  已初始化: false,
  // 上次分析结果
  上次分析结果: null as 情境分析结果 | null,
  // 上次分析时间
  上次分析时间: 0,
  // 文件访问历史
  文件访问历史: [] as 文件状态[],
  // 搜索历史
  搜索历史: [] as string[],
  // 终端历史
  终端历史: [] as string[],
  // 监听器列表
  监听器: [] as Array<(结果: 情境分析结果) => void>
};

/**
 * 初始化上下文分析器
 */
export function 初始化(): boolean {
  if (状态.已初始化) {
    return true;
  }
  
  try {
    状态.已初始化 = true;
    状态.上次分析结果 = null;
    状态.上次分析时间 = 0;
    状态.文件访问历史 = [];
    状态.搜索历史 = [];
    状态.终端历史 = [];
    状态.监听器 = [];
    
    记录日志("INFO", "上下文分析器初始化完成");
    
    return true;
  } catch (error) {
    记录日志("ERROR", `上下文分析器初始化失败: ${error}`);
    return false;
  }
}

/**
 * 分析当前情境
 */
export function 分析情境(): 情境分析结果 {
  if (!状态.已初始化) {
    初始化();
  }
  
  // 如果上次分析结果在缓存有效期内，直接返回
  const 当前时间 = Date.now();
  if (状态.上次分析结果 && (当前时间 - 状态.上次分析时间) < 配置.缓存时间) {
    return 状态.上次分析结果;
  }
  
  try {
    记录日志("DEBUG", "开始分析当前情境");
    
    // 创建新分析结果
    const 结果: 情境分析结果 = {
      活跃文件: [],
      活跃终端: [],
      分析时间: 当前时间
    };
    
    // 获取当前打开的文件
    结果.活跃文件 = 获取当前打开文件();
    
    // 获取活跃终端
    结果.活跃终端 = 获取活跃终端();
    
    // 获取搜索历史
    if (配置.监控搜索历史) {
      结果.搜索历史 = [...状态.搜索历史];
    }
    
    // 获取终端历史
    结果.终端历史 = [...状态.终端历史];
    
    // 获取剪贴板
    if (配置.监控剪贴板) {
      结果.剪贴板 = 获取剪贴板内容();
    }
    
    // 获取当前工作目录
    结果.工作目录 = 获取当前工作目录();
    
    // 获取文件访问历史
    结果.访问历史 = [...状态.文件访问历史];
    
    // 更新缓存
    状态.上次分析结果 = 结果;
    状态.上次分析时间 = 当前时间;
    
    // 触发监听器
    通知监听器(结果);
    
    记录日志("DEBUG", `情境分析完成，找到${结果.活跃文件.length}个活跃文件，${结果.活跃终端.length}个活跃终端`);
    
    return 结果;
  } catch (error) {
    记录日志("ERROR", `分析当前情境失败: ${error}`);
    
    // 出错时返回空结果
    return {
      活跃文件: [],
      活跃终端: [],
      分析时间: 当前时间
    };
  }
}

/**
 * 通知文件访问
 */
export function 通知文件访问(文件路径: string, 活跃: boolean = false): void {
  if (!状态.已初始化) {
    初始化();
  }
  
  try {
    // 生成文件状态
    const 文件: 文件状态 = {
      路径: 文件路径,
      活跃,
      访问时间: Date.now()
    };
    
    // 更新文件访问历史
    // 先查找是否已存在
    const 现有索引 = 状态.文件访问历史.findIndex(项 => 项.路径 === 文件路径);
    if (现有索引 !== -1) {
      // 已存在，更新访问时间和活跃状态
      状态.文件访问历史[现有索引].访问时间 = 文件.访问时间;
      状态.文件访问历史[现有索引].活跃 = 活跃;
      
      // 移到列表最前
      const 项 = 状态.文件访问历史.splice(现有索引, 1)[0];
      状态.文件访问历史.unshift(项);
    } else {
      // 不存在，添加到列表最前
      状态.文件访问历史.unshift(文件);
      
      // 控制列表大小
      if (状态.文件访问历史.length > 配置.最大历史数量) {
        状态.文件访问历史 = 状态.文件访问历史.slice(0, 配置.最大历史数量);
      }
    }
    
    // 如果自动追踪文件访问，通知预测加载器
    if (配置.自动追踪文件访问) {
      文件已访问(文件路径);
    }
    
    // 使缓存无效
    状态.上次分析时间 = 0;
    
    记录日志("DEBUG", `已通知文件访问: ${文件路径} (活跃: ${活跃})`);
  } catch (error) {
    记录日志("ERROR", `通知文件访问失败: ${error}`);
  }
}

/**
 * 通知搜索操作
 */
export function 通知搜索操作(搜索关键词: string): void {
  if (!状态.已初始化) {
    初始化();
  }
  
  if (!配置.监控搜索历史 || !搜索关键词) {
    return;
  }
  
  try {
    // 如果关键词已存在，先移除
    状态.搜索历史 = 状态.搜索历史.filter(项 => 项 !== 搜索关键词);
    
    // 添加到历史最前
    状态.搜索历史.unshift(搜索关键词);
    
    // 控制列表大小
    if (状态.搜索历史.length > 配置.最大历史数量) {
      状态.搜索历史 = 状态.搜索历史.slice(0, 配置.最大历史数量);
    }
    
    // 使缓存无效
    状态.上次分析时间 = 0;
    
    记录日志("DEBUG", `已通知搜索操作: ${搜索关键词}`);
  } catch (error) {
    记录日志("ERROR", `通知搜索操作失败: ${error}`);
  }
}

/**
 * 通知终端命令
 */
export function 通知终端命令(终端ID: string, 命令: string, 工作目录: string): void {
  if (!状态.已初始化) {
    初始化();
  }
  
  try {
    // 添加到终端历史
    状态.终端历史.unshift(命令);
    
    // 控制列表大小
    if (状态.终端历史.length > 配置.最大历史数量) {
      状态.终端历史 = 状态.终端历史.slice(0, 配置.最大历史数量);
    }
    
    // 使缓存无效
    状态.上次分析时间 = 0;
    
    记录日志("DEBUG", `已通知终端命令: ${命令} (终端: ${终端ID}, 目录: ${工作目录})`);
  } catch (error) {
    记录日志("ERROR", `通知终端命令失败: ${error}`);
  }
}

/**
 * 添加情境变化监听器
 */
export function 添加监听器(监听器: (结果: 情境分析结果) => void): number {
  if (!状态.已初始化) {
    初始化();
  }
  
  状态.监听器.push(监听器);
  return 状态.监听器.length - 1;
}

/**
 * 移除情境变化监听器
 */
export function 移除监听器(索引: number): boolean {
  if (!状态.已初始化 || 索引 < 0 || 索引 >= 状态.监听器.length) {
    return false;
  }
  
  状态.监听器.splice(索引, 1);
  return true;
}

/**
 * 清除分析缓存
 */
export function 清除缓存(): void {
  状态.上次分析结果 = null;
  状态.上次分析时间 = 0;
}

/**
 * 内部方法: 获取当前打开文件
 */
function 获取当前打开文件(): 文件状态[] {
  try {
    // 在实际应用中，这里应从编辑器获取当前打开的文件列表
    // 这里使用模拟数据
    
    // 如果有上次分析结果，从中提取文件列表并更新
    const 文件列表: 文件状态[] = [];
    
    if (状态.上次分析结果 && 状态.上次分析结果.活跃文件.length > 0) {
      // 基于上次结果创建新列表，但更新部分信息
      for (const 文件 of 状态.上次分析结果.活跃文件) {
        文件列表.push({
          ...文件,
          活跃: false, // 重置活跃状态
          访问时间: 文件.访问时间 // 保持访问时间不变
        });
      }
    }
    
    // 根据文件访问历史更新/添加文件
    for (const 历史文件 of 状态.文件访问历史) {
      // 只考虑在活跃窗口期内访问的文件
      const 当前时间 = Date.now();
      if ((当前时间 - (历史文件.访问时间 || 0)) <= 配置.文件活跃窗口) {
        // 查找是否已在列表中
        const 索引 = 文件列表.findIndex(文件 => 文件.路径 === 历史文件.路径);
        
        if (索引 !== -1) {
          // 更新现有项
          文件列表[索引].活跃 = 历史文件.活跃;
          文件列表[索引].访问时间 = 历史文件.访问时间;
        } else {
          // 添加新项
          文件列表.push({
            ...历史文件
          });
        }
      }
    }
    
    // 控制返回的文件数量
    const 排序后文件列表 = 文件列表
      .sort((a, b) => (b.访问时间|| 0) - (a.访问时间 || 0))
      .slice(0, 配置.最大分析文件数);
    
    // 确保至少有一个活跃文件
    if (排序后文件列表.length > 0 && !排序后文件列表.some(文件 => 文件.活跃)) {
      排序后文件列表[0].活跃 = true;
    }
    
    return 排序后文件列表;
  } catch (error) {
    记录日志("ERROR", `获取当前打开文件失败: ${error}`);
    return [];
  }
}

/**
 * 内部方法: 获取活跃终端
 */
function 获取活跃终端(): 终端状态[] {
  try {
    // 在实际应用中，这里应从终端管理器获取终端列表
    // 这里使用模拟数据，如果有上次结果，则复用
    if (状态.上次分析结果 && 状态.上次分析结果.活跃终端.length > 0) {
      return 状态.上次分析结果.活跃终端.map(终端 => ({
        ...终端
      }));
    }
    
    return [];
  } catch (error) {
    记录日志("ERROR", `获取活跃终端失败: ${error}`);
    return [];
  }
}

/**
 * 内部方法: 获取剪贴板内容
 */
function 获取剪贴板内容(): string {
  try {
    // 在实际应用中，这里应获取真实的剪贴板内容
    // 这里简单复用上次的结果
    if (状态.上次分析结果 && 状态.上次分析结果.剪贴板) {
      return 状态.上次分析结果.剪贴板;
    }
    
    return "";
  } catch (error) {
    记录日志("ERROR", `获取剪贴板内容失败: ${error}`);
    return "";
  }
}

/**
 * 内部方法: 获取当前工作目录
 */
function 获取当前工作目录(): string {
  try {
    // 在实际应用中，这里应获取真实的工作目录
    
    // 尝试从活跃终端获取
    if (状态.上次分析结果 && 状态.上次分析结果.活跃终端.length > 0) {
      const 活跃终端 = 状态.上次分析结果.活跃终端.find(终端 => 终端.活跃);
      if (活跃终端 && 活跃终端.工作目录) {
        return 活跃终端.工作目录;
      }
    }
    
    // 尝试从活跃文件路径推断
    if (状态.文件访问历史.length > 0) {
      const 最近文件 = 状态.文件访问历史[0];
      if (最近文件.路径) {
        // 提取文件所在目录
        const 路径 = 最近文件.路径;
        const 最后分隔符索引 = Math.max(路径.lastIndexOf('/'), 路径.lastIndexOf('\\'));
        if (最后分隔符索引 > 0) {
          return 路径.substring(0, 最后分隔符索引);
        }
      }
    }
    
    // 默认返回根目录
    return "/";
  } catch (error) {
    记录日志("ERROR", `获取当前工作目录失败: ${error}`);
    return "/";
  }
}

/**
 * 内部方法: 通知监听器
 */
function 通知监听器(结果: 情境分析结果): void {
  try {
    for (const 监听器 of 状态.监听器) {
      setTimeout(() => {
        try {
          监听器(结果);
        } catch (e) {
          记录日志("ERROR", `执行监听器失败: ${e}`);
        }
      }, 0);
    }
  } catch (error) {
    记录日志("ERROR", `通知监听器失败: ${error}`);
  }
}

// 导出默认接口
export default {
  初始化,
  分析情境,
  通知文件访问,
  通知搜索操作,
  通知终端命令,
  添加监听器,
  移除监听器,
  清除缓存
}; 