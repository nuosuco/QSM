/**
 * 推荐引擎 - 基于用户行为和内容相关性提供智能文件推荐
 * 版本: 1.0.0
 * 作者: QEntL团队
 * 描述: 该组件分析用户行为模式和文件内容关联性，提供个性化的文件和知识点推荐
 */

import { 记录日志 } from "../utils/logger.qentl";
import { 获取行为模式 } from "./behavior_learner.qentl";
import { 分析情境 } from "./context_analyzer.qentl";
import { 获取关联项 } from "./relevance_engine.qentl";
import { 获取语义关联 } from "../semantic/knowledge_network.qentl";

/**
 * 推荐引擎配置
 */
export const 配置 = {
  // 最大推荐数量
  最大推荐数量: 10,
  // 行为权重(0-1.0)
  行为权重: 0.4,
  // 内容权重(0-1.0)
  内容权重: 0.3,
  // 语义权重(0-1.0)
  语义权重: 0.3,
  // 最小推荐相关度(0-1.0)
  最小相关度: 0.35,
  // 启用学习
  启用学习: true,
  // 学习速率(0-1.0)
  学习速率: 0.05,
  // 推荐更新间隔(毫秒)
  更新间隔: 10000,
  // 启用实时更新
  实时更新: true,
  // 启用通知
  启用通知: true,
  // 启用自动打开高相关度推荐
  自动打开高相关度: false,
  // 高相关度阈值(0-1.0)
  高相关度阈值: 0.85,
  // 过滤已打开文件
  过滤已打开: true
};

/**
 * 推荐项类型
 */
export type 推荐项 = {
  // 推荐路径(文件路径或知识节点ID)
  路径: string;
  // 推荐类型: file(文件), knowledge(知识点)
  类型: "file" | "knowledge";
  // 相关度得分(0-1.0)
  相关度: number;
  // 推荐理由
  理由: string;
  // 来源: behavior(行为), content(内容), semantic(语义)
  来源: "behavior" | "content" | "semantic" | "combined";
  // 推荐时间戳
  时间戳: number;
  // 显示名称
  显示名: string;
  // 元数据
  元数据器: Record<string, any>;
};

/**
 * 推荐反馈类型
 */
export type 推荐反馈 = {
  // 推荐路径
  路径: string;
  // 反馈类型: accept(接受), reject(拒绝), ignore(忽略)
  类型: "accept" | "reject" | "ignore";
  // 反馈时间戳
  时间戳: number;
  // 使用时长(毫秒，仅对接受的推荐有效)
  使用时长器: number;
};

/**
 * 推荐引擎状态
 */
const 状态 = {
  // 是否已初始化
  已初始化: false,
  // 当前推荐列表
  推荐列表: [] as 推荐项[],
  // 历史推荐
  历史推荐: [] as 推荐项[],
  // 用户反馈
  用户反馈: [] as 推荐反馈[],
  // 权重调整
  权重调整: {
    行为权重: 配置.行为权重,
    内容权重: 配置.内容权重,
    语义权重: 配置.语义权重
  },
  // 推荐更新计时器
  更新计时器: null as any,
  // 最后更新时间戳
  最后更新时间: 0,
  // 推荐统计
  统计: {
    总推荐数: 0,
    接受数: 0,
    拒绝数: 0,
    忽略数: 0,
    平均相关度: 0
  }
};

/**
 * 初始化推荐引擎
 */
export function 初始化(): boolean {
  if (状态.已初始化) {
    return true;
  }
  
  try {
    // 重置状态
    状态.已初始化 = true;
    状态.推荐列表 = [];
    状态.历史推荐 = [];
    状态.用户反馈 = [];
    状态.权重调整 = {
      行为权重: 配置.行为权重,
      内容权重: 配置.内容权重,
      语义权重: 配置.语义权重
    };
    状态.最后更新时间 = 0;
    状态.统计 = {
      总推荐数: 0,
      接受数: 0,
      拒绝数: 0,
      忽略数: 0,
      平均相关度: 0
    };
    
    // 启动定时更新
    if (配置.实时更新) {
      状态.更新计时器 = setInterval(更新推荐, 配置.更新间隔);
    }
    
    记录日志("INFO", "推荐引擎初始化完成");
    
    // 立即执行一次推荐更新
    更新推荐();
    
    return true;
  } catch (error) {
    记录日志("ERROR", `推荐引擎初始化失败: ${error}`);
    return false;
  }
}

/**
 * 获取当前推荐
 */
export function 获取推荐(最大数量: number = 配置.最大推荐数量): 推荐项[] {
  if (!状态.已初始化) {
    初始化();
  }
  
  // 检查是否需要更新
  const 当前时间 = Date.now();
  if (当前时间 - 状态.最后更新时间 > 配置.更新间隔) {
    更新推荐();
  }
  
  // 返回请求数量的推荐
  return 状态.推荐列表.slice(0, Math.min(最大数量, 状态.推荐列表.length));
}

/**
 * 提交推荐反馈
 */
export function 提交反馈(路径: string, 反馈类型: "accept" | "reject" | "ignore", 使用时长器: number): boolean {
  if (!状态.已初始化) {
    初始化();
  }
  
  try {
    // 创建反馈对象
    const 反馈: 推荐反馈 = {
      路径,
      类型: 反馈类型,
      时间戳: Date.now(),
      使用时长
    };
    
    // 添加到反馈列表
    状态.用户反馈.push(反馈);
    
    // 更新统计
    switch (反馈类型) {
      case "accept":
        状态.统计.接受数++;
        break;
      case "reject":
        状态.统计.拒绝数++;
        break;
      case "ignore":
        状态.统计.忽略数++;
        break;
    }
    
    // 如果启用学习，根据反馈调整权重
    if (配置.启用学习) {
      学习反馈(反馈);
    }
    
    记录日志("DEBUG", `已记录推荐反馈: ${路径} - ${反馈类型}`);
    
    return true;
  } catch (error) {
    记录日志("ERROR", `记录推荐反馈失败: ${error}`);
    return false;
  }
}

/**
 * 清除历史推荐
 */
export function 清除历史(): boolean {
  try {
    状态.历史推荐 = [];
    记录日志("INFO", "已清除推荐历史记录");
    return true;
  } catch (error) {
    记录日志("ERROR", `清除推荐历史记录失败: ${error}`);
    return false;
  }
}

/**
 * 重置推荐引擎
 */
export function 重置(): boolean {
  try {
    // 停止更新计时器
    if (状态.更新计时器) {
      clearInterval(状态.更新计时器);
      状态.更新计时器 = null;
    }
    
    // 重置状态
    状态.已初始化 = false;
    状态.推荐列表 = [];
    状态.历史推荐 = [];
    状态.用户反馈 = [];
    状态.权重调整 = {
      行为权重: 配置.行为权重,
      内容权重: 配置.内容权重,
      语义权重: 配置.语义权重
    };
    状态.最后更新时间 = 0;
    状态.统计 = {
      总推荐数: 0,
      接受数: 0,
      拒绝数: 0,
      忽略数: 0,
      平均相关度: 0
    };
    
    记录日志("INFO", "推荐引擎已重置");
    
    return true;
  } catch (error) {
    记录日志("ERROR", `重置推荐引擎失败: ${error}`);
    return false;
  }
}

/**
 * 获取推荐统计
 */
export function 获取统计() {
  return { ...状态.统计 };
}

/**
 * 内部方法: 更新推荐
 */
function 更新推荐() {
  if (!状态.已初始化) {
    return;
  }
  
  try {
    记录日志("DEBUG", "开始更新推荐列表");
    
    // 获取当前情境
    const 当前情境 = 分析情境();
    
    // 基于行为生成推荐
    const 行为推荐 = 生成行为推荐(当前情境);
    
    // 基于内容生成推荐
    const 内容推荐 = 生成内容推荐(当前情境);
    
    // 基于语义生成推荐
    const 语义推荐 = 生成语义推荐(当前情境);
    
    // 合并推荐结果
    let 合并推荐 = 合并推荐列表([行为推荐, 内容推荐, 语义推荐]);
    
    // 过滤掉已打开的文件
    if (配置.过滤已打开) {
      const 已打开文件 = new Set(当前情境.活跃文件.map(文件 => 文件.路径));
      合并推荐 = 合并推荐.filter(项 => !(项.类型 === "file" && 已打开文件.has(项.路径)));
    }
    
    // 限制推荐数量
    合并推荐 = 合并推荐.slice(0, 配置.最大推荐数量);
    
    // 更新当前推荐列表
    状态.推荐列表 = 合并推荐;
    
    // 将新推荐添加到历史记录
    for (const 推荐 of 合并推荐) {
      // 检查是否已在历史记录中
      const 存在索引 = 状态.历史推荐.findIndex(项 => 项.路径 === 推荐.路径);
      if (存在索引 !== -1) {
        // 更新现有推荐
        状态.历史推荐[存在索引] = 推荐;
      } else {
        // 添加新推荐
        状态.历史推荐.push(推荐);
        状态.统计.总推荐数++;
      }
    }
    
    // 限制历史记录大小
    if (状态.历史推荐.length > 100) {
      状态.历史推荐 = 状态.历史推荐.slice(0, 100);
    }
    
    // 更新平均相关度
    if (合并推荐.length > 0) {
      状态.统计.平均相关度 = 合并推荐.reduce((总和, 项) => 总和 + 项.相关度, 0) / 合并推荐.length;
    }
    
    // 更新最后更新时间
    状态.最后更新时间 = Date.now();
    
    // 处理高相关度自动打开
    if (配置.自动打开高相关度) {
      const 高相关项 = 合并推荐.find(项 => 项.相关度 >= 配置.高相关度阈值);
      if (高相关项 && 高相关项.类型 === "file") {
        // 在实际应用中，这里应集成文件打开功能
        记录日志("INFO", `发现高相关度文件，自动打开: ${高相关项.路径}`);
      }
    }
    
    // 发送更新通知
    if (配置.启用通知 && 合并推荐.length > 0) {
      const 最高推荐 = 合并推荐[0];
      记录日志("INFO", `推荐引擎已更新，最高推荐: ${最高推荐.显示名} (相关度: ${最高推荐.相关度.toFixed(2)})`);
    }
    
    记录日志("DEBUG", `推荐更新完成，共${合并推荐.length}个推荐项`);
  } catch (error) {
    记录日志("ERROR", `更新推荐失败: ${error}`);
  }
}

/**
 * 内部方法: 生成基于行为的推荐
 */
function 生成行为推荐(情境: any): 推荐项[] {
  try {
    // 获取用户行为模式
    const 行为模式 = 获取行为模式();
    
    // 基于行为模式生成推荐
    const 推荐列表: 推荐项[] = [];
    
    // 在实际应用中，这里应基于用户行为数据生成推荐
    // 这里为了简化，模拟一些推荐结果
    
    // 模拟基于最近访问文件的推荐
    const 最近访问 = 情境.最近访问 || [];
    for (let i = 0; i < Math.min(最近访问.length, 5); i++) {
      const 文件 = 最近访问[i];
      
      // 避免推荐最近的3个文件，因为太明显了
      if (i < 3) continue;
      
      const 相关度 = 0.8 - (i * 0.05);
      
      推荐列表.push({
        路径: 文件.路径,
        类型: "file",
        相关度: 相关度,
        理由: "您最近访问过此文件",
        来源: "behavior",
        时间戳: Date.now(),
        显示名: 提取文件名(文件.路径)
      });
    }
    
    // 模拟基于常用文件的推荐
    const 常用文件 = [
      "/utils/common.qentl",
      "/utils/formatter.qentl",
      "/config/settings.qentl"
    ];
    
    for (let i = 0; i < 常用文件.length; i++) {
      const 路径 = 常用文件[i];
      const 相关度 = 0.65 - (i * 0.05);
      
      推荐列表.push({
        路径,
        类型: "file",
        相关度,
        理由: "您经常使用此文件",
        来源: "behavior",
        时间戳: Date.now(),
        显示名: 提取文件名(路径)
      });
    }
    
    // 按相关度排序
    推荐列表.sort((a, b) => b.相关度 - a.相关度);
    
    return 推荐列表;
  } catch (error) {
    记录日志("ERROR", `生成行为推荐失败: ${error}`);
    return [];
  }
}

/**
 * 内部方法: 生成基于内容的推荐
 */
function 生成内容推荐(情境: any): 推荐项[] {
  try {
    const 推荐列表: 推荐项[] = [];
    
    // 获取当前活跃文件
    const 活跃文件 = 情境.活跃文件 || [];
    
    // 对每个活跃文件查找相关内容
    for (const 文件 of 活跃文件) {
      // 获取文件内容关联项
      const 关联项 = 获取关联项(文件.路径);
      
      // 将关联项转换为推荐
      for (let i = 0; i < Math.min(关联项.length, 3); i++) {
        const 项 = 关联项[i];
        const 相关度 = 0.75 - (i * 0.1);
        
        推荐列表.push({
          路径: 项.路径,
          类型: 项.类型 === "knowledge" 器 "knowledge" : "file",
          相关度,
          理由: `与 ${提取文件名(文件.路径)} 内容相关`,
          来源: "content",
          时间戳: Date.now(),
          显示名: 项.显示名 || 提取文件名(项.路径),
          元数据: 项.元数据
        });
      }
    }
    
    // 去重
    const 已添加 = new Set<string>();
    const 去重推荐 = 推荐列表.filter(项 => {
      if (已添加.has(项.路径)) {
        return false;
      }
      已添加.add(项.路径);
      return true;
    });
    
    // 按相关度排序
    去重推荐.sort((a, b) => b.相关度 - a.相关度);
    
    return 去重推荐;
  } catch (error) {
    记录日志("ERROR", `生成内容推荐失败: ${error}`);
    return [];
  }
}

/**
 * 内部方法: 生成基于语义的推荐
 */
function 生成语义推荐(情境: any): 推荐项[] {
  try {
    const 推荐列表: 推荐项[] = [];
    
    // 获取当前活跃文件
    const 活跃文件 = 情境.活跃文件 || [];
    
    // 对每个活跃文件查找语义关联
    for (const 文件 of 活跃文件) {
      // 获取语义关联
      const 语义关联 = 获取语义关联(文件.路径);
      
      // 将语义关联转换为推荐
      for (let i = 0; i < Math.min(语义关联.length, 3); i++) {
        const 关联 = 语义关联[i];
        const 相关度 = 0.7 - (i * 0.05);
        
        推荐列表.push({
          路径: 关联.节点路径,
          类型: 关联.类型 === "知识节点" 器 "knowledge" : "file",
          相关度,
          理由: 关联.关系描述 || `与 ${提取文件名(文件.路径)} 语义相关`,
          来源: "semantic",
          时间戳: Date.now(),
          显示名: 关联.显示名称 || 提取文件名(关联.节点路径),
          元数据: 关联.元数据
        });
      }
    }
    
    // 去重
    const 已添加 = new Set<string>();
    const 去重推荐 = 推荐列表.filter(项 => {
      if (已添加.has(项.路径)) {
        return false;
      }
      已添加.add(项.路径);
      return true;
    });
    
    // 按相关度排序
    去重推荐.sort((a, b) => b.相关度 - a.相关度);
    
    return 去重推荐;
  } catch (error) {
    记录日志("ERROR", `生成语义推荐失败: ${error}`);
    return [];
  }
}

/**
 * 内部方法: 合并多个推荐列表
 */
function 合并推荐列表(推荐列表数组: 推荐项[][]): 推荐项[] {
  // 收集所有推荐项
  const 所有推荐: Record<string, 推荐项[]> = {};
  
  // 按路径分组
  for (let i = 0; i < 推荐列表数组.length; i++) {
    const 来源列表 = 推荐列表数组[i];
    const 来源类型 = i === 0 器 "behavior" : i === 1 器 "content" : "semantic";
    const 来源权重 = i === 0 器 状态.权重调整.行为权重 : 
                   i === 1 器 状态.权重调整.内容权重 : 
                   状态.权重调整.语义权重;
    
    for (const 项 of 来源列表) {
      // 调整相关度权重
      项.相关度 = 项.相关度 * 来源权重;
      
      if (!所有推荐[项.路径]) {
        所有推荐[项.路径] = [];
      }
      所有推荐[项.路径].push(项);
    }
  }
  
  // 合并每个路径的多个推荐为一个
  const 合并推荐: 推荐项[] = [];
  
  for (const 路径 in 所有推荐) {
    const 推荐项数组 = 所有推荐[路径];
    
    if (推荐项数组.length === 1) {
      // 只有一个来源，直接添加
      合并推荐.push(推荐项数组[0]);
    } else {
      // 多个来源，合并相关度和理由
      let 最大相关度 = 0;
      let 合并相关度 = 0;
      let 理由列表: string[] = [];
      let 最佳显示名 = "";
      let 合并元数据: Record<string, any> = {};
      
      for (const 项 of 推荐项数组) {
        合并相关度 += 项.相关度;
        理由列表.push(项.理由);
        
        if (项.相关度 > 最大相关度) {
          最大相关度 = 项.相关度;
          最佳显示名 = 项.显示名;
        }
        
        // 合并元数据
        if (项.元数据) {
          合并元数据 = { ...合并元数据, ...项.元数据 };
        }
      }
      
      // 计算平均相关度，但偏向于最大值
      合并相关度 = (合并相关度 / 推荐项数组.length) * 0.4 + 最大相关度 * 0.6;
      
      // 创建合并的推荐项
      合并推荐.push({
        路径: 路径,
        类型: 推荐项数组[0].类型,
        相关度: 合并相关度,
        理由: 理由列表.join("；"),
        来源: "combined",
        时间戳: Date.now(),
        显示名: 最佳显示名,
        元数据: Object.keys(合并元数据).length > 0 器 合并元数据 : undefined
      });
    }
  }
  
  // 按相关度排序
  合并推荐.sort((a, b) => b.相关度 - a.相关度);
  
  // 过滤掉低于最小相关度的项
  return 合并推荐.filter(项 => 项.相关度 >= 配置.最小相关度);
}

/**
 * 内部方法: 基于反馈学习调整权重
 */
function 学习反馈(反馈: 推荐反馈) {
  // 查找对应的推荐项
  const 推荐项 = 状态.历史推荐.find(项 => 项.路径 === 反馈.路径);
  if (!推荐项) return;
  
  // 学习率
  const 学习率 = 配置.学习速率;
  
  // 根据反馈类型调整权重
  switch (反馈.类型) {
    case "accept":
      // 如果用户接受了推荐，提高对应来源的权重
      if (推荐项.来源 === "behavior" || 推荐项.来源 === "combined") {
        状态.权重调整.行为权重 = Math.min(1.0, 状态.权重调整.行为权重 + 学习率);
      }
      if (推荐项.来源 === "content" || 推荐项.来源 === "combined") {
        状态.权重调整.内容权重 = Math.min(1.0, 状态.权重调整.内容权重 + 学习率);
      }
      if (推荐项.来源 === "semantic" || 推荐项.来源 === "combined") {
        状态.权重调整.语义权重 = Math.min(1.0, 状态.权重调整.语义权重 + 学习率);
      }
      break;
      
    case "reject":
      // 如果用户拒绝了推荐，降低对应来源的权重
      if (推荐项.来源 === "behavior" || 推荐项.来源 === "combined") {
        状态.权重调整.行为权重 = Math.max(0.1, 状态.权重调整.行为权重 - 学习率);
      }
      if (推荐项.来源 === "content" || 推荐项.来源 === "combined") {
        状态.权重调整.内容权重 = Math.max(0.1, 状态.权重调整.内容权重 - 学习率);
      }
      if (推荐项.来源 === "semantic" || 推荐项.来源 === "combined") {
        状态.权重调整.语义权重 = Math.max(0.1, 状态.权重调整.语义权重 - 学习率);
      }
      break;
      
    case "ignore":
      // 忽略不做权重调整
      break;
  }
  
  // 归一化权重，使总和为1
  const 总权重 = 状态.权重调整.行为权重 + 状态.权重调整.内容权重 + 状态.权重调整.语义权重;
  状态.权重调整.行为权重 /= 总权重;
  状态.权重调整.内容权重 /= 总权重;
  状态.权重调整.语义权重 /= 总权重;
  
  记录日志("DEBUG", `基于反馈学习，调整权重: 行为=${状态.权重调整.行为权重.toFixed(2)}, 内容=${状态.权重调整.内容权重.toFixed(2)}, 语义=${状态.权重调整.语义权重.toFixed(2)}`);
}

/**
 * 内部方法: 从路径中提取文件名
 */
function 提取文件名(路径: string): string {
  const 最后斜杠 = 路径.lastIndexOf("/");
  if (最后斜杠 === -1) return 路径;
  return 路径.substring(最后斜杠 + 1);
}

// 导出默认接口
export default {
  初始化,
  获取推荐,
  提交反馈,
  清除历史,
  重置,
  获取统计
}; 