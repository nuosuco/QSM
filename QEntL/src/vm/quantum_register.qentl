// QEntL量子寄存器
// 创建者: Claude
// 功能: 量子虚拟机的量子寄存器实现

#include <complex.h>
#include <vector.h>
#include <matrix.h>
#include <quantum_math.h>

// 量子位物理基础状态
enum QubitState {
    // 基态 |0⟩
    QUBIT_ZERO = 0,
    
    // 激发态 |1⟩
    QUBIT_ONE = 1,
    
    // 叠加态
    QUBIT_SUPERPOSITION = 2,
    
    // 纠缠态
    QUBIT_ENTANGLED = 3
};

// 量子位
class Qubit {
private:
    // 振幅 - 复数表示: a|0⟩ + b|1⟩
    Complex alpha; // |0⟩的振幅
    Complex beta;  // |1⟩的振幅
    
    // 纠缠状态跟踪
    bool isEntangled;
    int entanglementGroup;
    
public:
    // 构造函数
    Qubit() {
        // 默认初始化为|0⟩状态
        alpha = Complex(1.0, 0.0);
        beta = Complex(0.0, 0.0);
        isEntangled = false;
        entanglementGroup = -1;
    }
    
    // 重置量子位到|0⟩状态
    void reset() {
        alpha = Complex(1.0, 0.0);
        beta = Complex(0.0, 0.0);
        
        // 如果是纠缠态，需要特殊处理
        if (isEntangled) {
            isEntangled = false;
            entanglementGroup = -1;
        }
    }
    
    // 获取状态
    QubitState getState() const {
        if (isEntangled) {
            return QUBIT_ENTANGLED;
        }
        
        // 检查是否处于叠加态
        double zeroProb = alpha.magnitudeSquared();
        double oneProb = beta.magnitudeSquared();
        
        if (QuantumMath::isApproximatelyEqual(zeroProb, 1.0)) {
            return QUBIT_ZERO;
        } else if (QuantumMath::isApproximatelyEqual(oneProb, 1.0)) {
            return QUBIT_ONE;
        } else {
            return QUBIT_SUPERPOSITION;
        }
    }
    
    // 应用Hadamard门
    void applyHadamard() {
        Complex newAlpha = (alpha + beta) * QuantumMath::INV_SQRT2;
        Complex newBeta = (alpha - beta) * QuantumMath::INV_SQRT2;
        
        alpha = newAlpha;
        beta = newBeta;
    }
    
    // 应用X门（Pauli-X，位翻转）
    void applyXGate() {
        // X门交换|0⟩和|1⟩状态
        Complex temp = alpha;
        alpha = beta;
        beta = temp;
    }
    
    // 应用Z门（Pauli-Z，相位翻转）
    void applyZGate() {
        // Z门保持|0⟩不变，将|1⟩变为-|1⟩
        beta = -beta;
    }
    
    // 将量子位置于指定状态
    void setState(Complex newAlpha, Complex newBeta) {
        // 确保归一化
        double normFactor = sqrt(newAlpha.magnitudeSquared() + newBeta.magnitudeSquared());
        
        if (normFactor > 0) {
            alpha = newAlpha / normFactor;
            beta = newBeta / normFactor;
        }
    }
    
    // 获取|0⟩的振幅
    Complex getAlpha() const {
        return alpha;
    }
    
    // 获取|1⟩的振幅
    Complex getBeta() const {
        return beta;
    }
    
    // 测量量子位 - 返回结果（0或1），并崩溃状态
    int measure() {
        double zeroProb = alpha.magnitudeSquared();
        
        // 生成0-1之间的随机数
        double random = QuantumMath::getRandomProbability();
        
        int result = (random < zeroProb) ? 0 : 1;
        
        // 崩溃状态
        if (result == 0) {
            alpha = Complex(1.0, 0.0);
            beta = Complex(0.0, 0.0);
        } else {
            alpha = Complex(0.0, 0.0);
            beta = Complex(1.0, 0.0);
        }
        
        // 如果是纠缠态，需要更新所有纠缠的量子位
        if (isEntangled) {
            // 这里应该触发纠缠组的测量事件
            isEntangled = false;
            entanglementGroup = -1;
        }
        
        return result;
    }
    
    // 设置纠缠状态
    void setEntanglement(bool entangled, int group) {
        isEntangled = entangled;
        entanglementGroup = entangled ? group : -1;
    }
    
    // 检查是否处于纠缠态
    bool getEntangled() const {
        return isEntangled;
    }
    
    // 获取纠缠组ID
    int getEntanglementGroup() const {
        return entanglementGroup;
    }
};

// 量子寄存器 - 表示一组可以统一操作的量子位
class QuantumRegister {
private:
    std::vector<Qubit> qubits;
    int size;
    
    // 用于跟踪纠缠组
    int nextEntanglementGroupId;
    
public:
    // 构造函数
    QuantumRegister() : size(0), nextEntanglementGroupId(0) {}
    
    // 初始化指定数量的量子位
    void initialize(int numQubits) {
        qubits.resize(numQubits);
        size = numQubits;
        
        // 重置所有量子位
        for (int i = 0; i < size; i++) {
            qubits[i].reset();
        }
    }
    
    // 重置所有量子位
    void reset() {
        for (int i = 0; i < size; i++) {
            qubits[i].reset();
        }
        nextEntanglementGroupId = 0;
    }
    
    // 获取量子位数量
    int getSize() const {
        return size;
    }
    
    // 应用Hadamard门到指定量子位
    void applyHadamard(int qubitIndex) {
        if (qubitIndex >= 0 && qubitIndex < size) {
            qubits[qubitIndex].applyHadamard();
        }
    }
    
    // 应用X门到指定量子位
    void applyXGate(int qubitIndex) {
        if (qubitIndex >= 0 && qubitIndex < size) {
            qubits[qubitIndex].applyXGate();
        }
    }
    
    // 应用Z门到指定量子位
    void applyZGate(int qubitIndex) {
        if (qubitIndex >= 0 && qubitIndex < size) {
            qubits[qubitIndex].applyZGate();
        }
    }
    
    // 应用CNOT门（控制-非门）
    void applyCNOT(int controlQubit, int targetQubit) {
        if (controlQubit >= 0 && controlQubit < size && 
            targetQubit >= 0 && targetQubit < size && 
            controlQubit != targetQubit) {
            
            // 如果没有纠缠，创建一个新的纠缠组
            if (!qubits[controlQubit].getEntangled() && !qubits[targetQubit].getEntangled()) {
                int newGroup = nextEntanglementGroupId++;
                qubits[controlQubit].setEntanglement(true, newGroup);
                qubits[targetQubit].setEntanglement(true, newGroup);
            } 
            // 如果控制量子位已纠缠，将目标量子位加入该组
            else if (qubits[controlQubit].getEntangled() && !qubits[targetQubit].getEntangled()) {
                qubits[targetQubit].setEntanglement(true, qubits[controlQubit].getEntanglementGroup());
            }
            // 如果目标量子位已纠缠，将控制量子位加入该组
            else if (!qubits[controlQubit].getEntangled() && qubits[targetQubit].getEntangled()) {
                qubits[controlQubit].setEntanglement(true, qubits[targetQubit].getEntanglementGroup());
            }
            // 如果两个量子位都已纠缠但在不同组，合并两个组
            else if (qubits[controlQubit].getEntanglementGroup() != qubits[targetQubit].getEntanglementGroup()) {
                int targetGroup = qubits[targetQubit].getEntanglementGroup();
                int controlGroup = qubits[controlQubit].getEntanglementGroup();
                
                // 将所有targetGroup的量子位移到controlGroup
                for (int i = 0; i < size; i++) {
                    if (qubits[i].getEntangled() && qubits[i].getEntanglementGroup() == targetGroup) {
                        qubits[i].setEntanglement(true, controlGroup);
                    }
                }
            }
            
            // CNOT门逻辑：如果控制量子位为|1⟩，则翻转目标量子位
            // 注意：实际实现中，这里应该是对整个量子态的操作，而不是经典条件判断
            // 这只是简化的模拟版本
            if (qubits[controlQubit].getState() == QUBIT_ONE) {
                qubits[targetQubit].applyXGate();
            }
        }
    }
    
    // 测量指定量子位，返回测量结果（0或1）
    bool measure(int qubitIndex) {
        if (qubitIndex >= 0 && qubitIndex < size) {
            // 如果量子位已纠缠，需要特殊处理
            if (qubits[qubitIndex].getEntangled()) {
                int group = qubits[qubitIndex].getEntanglementGroup();
                
                // 在真实的量子系统中，测量一个纠缠量子位会影响所有纠缠的量子位
                // 这里是一个简化的模拟
                int result = qubits[qubitIndex].measure();
                
                // 解除所有相关量子位的纠缠
                for (int i = 0; i < size; i++) {
                    if (qubits[i].getEntangled() && qubits[i].getEntanglementGroup() == group) {
                        qubits[i].setEntanglement(false, -1);
                    }
                }
                
                return result == 1;
            } else {
                return qubits[qubitIndex].measure() == 1;
            }
        }
        return false;
    }
    
    // 获取量子寄存器的状态表示
    std::string getStateRepresentation() const {
        std::string representation = "|";
        
        for (int i = 0; i < size; i++) {
            QubitState state = qubits[i].getState();
            
            switch (state) {
                case QUBIT_ZERO:
                    representation += "0";
                    break;
                case QUBIT_ONE:
                    representation += "1";
                    break;
                case QUBIT_SUPERPOSITION:
                    representation += "+";
                    break;
                case QUBIT_ENTANGLED:
                    representation += "E";
                    break;
            }
        }
        
        representation += ">";
        return representation;
    }
    
    // 访问特定的量子位
    Qubit& getQubit(int index) {
        if (index >= 0 && index < size) {
            return qubits[index];
        }
        
        // 索引越界时的处理
        static Qubit dummy;
        return dummy;
    }
    
    // 设置特定量子位的状态
    void setQubitState(int index, Complex alpha, Complex beta) {
        if (index >= 0 && index < size) {
            qubits[index].setState(alpha, beta);
        }
    }
};

// 经典寄存器 - 用于存储经典比特值
class ClassicalRegister {
private:
    int value;
    
public:
    // 构造函数
    ClassicalRegister() : value(0) {}
    
    // 重置寄存器
    void reset() {
        value = 0;
    }
    
    // 设置值
    void setValue(int newValue) {
        value = newValue;
    }
    
    // 获取值
    int getValue() const {
        return value;
    }
    
    // 设置特定位
    void setBit(int bitPosition, bool bitValue) {
        if (bitPosition >= 0) {
            if (bitValue) {
                value |= (1 << bitPosition);
            } else {
                value &= ~(1 << bitPosition);
            }
        }
    }
    
    // 获取特定位
    bool getBit(int bitPosition) const {
        if (bitPosition >= 0) {
            return (value & (1 << bitPosition)) != 0;
        }
        return false;
    }
};

// 复数类的简单实现
class Complex {
private:
    double real;
    double imag;
    
public:
    // 构造函数
    Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {}
    
    // 复数加法
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }
    
    // 复数减法
    Complex operator-(const Complex& other) const {
        return Complex(real - other.real, imag - other.imag);
    }
    
    // 复数乘法
    Complex operator*(const Complex& other) const {
        return Complex(
            real * other.real - imag * other.imag,
            real * other.imag + imag * other.real
        );
    }
    
    // 复数标量乘法
    Complex operator*(double scalar) const {
        return Complex(real * scalar, imag * scalar);
    }
    
    // 复数标量除法
    Complex operator/(double scalar) const {
        if (scalar != 0.0) {
            return Complex(real / scalar, imag / scalar);
        }
        return *this; // 避免除以零
    }
    
    // 取反
    Complex operator-() const {
        return Complex(-real, -imag);
    }
    
    // 获取实部
    double getReal() const {
        return real;
    }
    
    // 获取虚部
    double getImag() const {
        return imag;
    }
    
    // 获取模的平方
    double magnitudeSquared() const {
        return real * real + imag * imag;
    }
    
    // 获取模
    double magnitude() const {
        return sqrt(magnitudeSquared());
    }
    
    // 获取相位角
    double phase() const {
        return atan2(imag, real);
    }
    
    // 字符串表示
    std::string toString() const {
        std::stringstream ss;
        
        if (imag >= 0) {
            ss << real << " + " << imag << "i";
        } else {
            ss << real << " - " << -imag << "i";
        }
        
        return ss.str();
    }
};

// 量子数学辅助类
class QuantumMath {
public:
    // 常数
    static const double PI;
    static const double INV_SQRT2;
    
    // 判断两个浮点数是否近似相等
    static bool isApproximatelyEqual(double a, double b, double epsilon = 1e-10) {
        return fabs(a - b) < epsilon;
    }
    
    // 生成0-1之间的随机概率值
    static double getRandomProbability() {
        return (double)rand() / RAND_MAX;
    }
    
    // 创建Hadamard矩阵
    static Matrix createHadamardMatrix() {
        Matrix h(2, 2);
        double invSqrt2 = INV_SQRT2;
        
        h.set(0, 0, invSqrt2);
        h.set(0, 1, invSqrt2);
        h.set(1, 0, invSqrt2);
        h.set(1, 1, -invSqrt2);
        
        return h;
    }
    
    // 创建Pauli-X矩阵
    static Matrix createPauliXMatrix() {
        Matrix x(2, 2);
        
        x.set(0, 0, 0.0);
        x.set(0, 1, 1.0);
        x.set(1, 0, 1.0);
        x.set(1, 1, 0.0);
        
        return x;
    }
    
    // 创建Pauli-Z矩阵
    static Matrix createPauliZMatrix() {
        Matrix z(2, 2);
        
        z.set(0, 0, 1.0);
        z.set(0, 1, 0.0);
        z.set(1, 0, 0.0);
        z.set(1, 1, -1.0);
        
        return z;
    }
};

// 常量初始化
const double QuantumMath::PI = 3.14159265358979323846;
const double QuantumMath::INV_SQRT2 = 0.7071067811865475;

// 基本矩阵操作
class Matrix {
private:
    std::vector<std::vector<double>> data;
    int rows;
    int cols;
    
public:
    // 构造函数
    Matrix(int r, int c) : rows(r), cols(c) {
        data.resize(rows, std::vector<double>(cols, 0.0));
    }
    
    // 设置矩阵元素
    void set(int row, int col, double value) {
        if (row >= 0 && row < rows && col >= 0 && col < cols) {
            data[row][col] = value;
        }
    }
    
    // 获取矩阵元素
    double get(int row, int col) const {
        if (row >= 0 && row < rows && col >= 0 && col < cols) {
            return data[row][col];
        }
        return 0.0;
    }
    
    // 矩阵乘法
    Matrix multiply(const Matrix& other) const {
        if (cols != other.rows) {
            // 维度不匹配，返回空矩阵
            return Matrix(0, 0);
        }
        
        Matrix result(rows, other.cols);
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < other.cols; j++) {
                double sum = 0.0;
                for (int k = 0; k < cols; k++) {
                    sum += data[i][k] * other.data[k][j];
                }
                result.data[i][j] = sum;
            }
        }
        
        return result;
    }
    
    // 获取行数
    int getRows() const {
        return rows;
    }
    
    // 获取列数
    int getCols() const {
        return cols;
    }
}; 