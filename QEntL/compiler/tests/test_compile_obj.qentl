/**
 * QEntL测试程序 - 编译为.qobj
 * QuantumGene: QG-TEST-COMPILE-OBJ-A1B2-1714044000
 * EntanglementStrength: 0.95
 */

// TestCompileObj - 测试编译为.qobj文件的程序
//
// 版本: 1.0.0
// 作者: Claude AI
// 日期: 2023-04-21
// 描述: 此文件测试QEntL编译器将.qentl文件编译为.qobj文件的功能
//       包含几个量子操作和常见编程结构

quantum_program TestCompileObj {
    metadata {
        name: "TestCompileObj",
        version: "1.0.0",
        author: "Claude AI",
        description: "测试QEntL编译器编译.qobj文件的功能",
        quantum_gene: "QG-TEST-QOBJ-A1B2-1714105847",
        entanglement_strength: 0.75
    }

    state {
        initialized: false,
        qubit_count: 4,
        register_a: null,
        register_b: null,
        results: [],
        verbose_mode: false,
        log_entries: []
    }

    // 初始化函数
    initialize() {
        if (this.initialized) {
            this.addLog("已经初始化过，跳过");
            return;
        }

        this.addLog("初始化测试程序...");
        this.register_a = new QuantumRegister(2, "reg_a");
        this.register_b = new QuantumRegister(2, "reg_b");
        this.initialized = true;
        this.addLog("初始化完成");
    }

    // 处理命令行参数
    parseArgs(args) {
        if (!args || args.length === 0) {
            return;
        }

        for (let i = 0; i < args.length; i++) {
            if (args[i] === "--verbose" || args[i] === "-v") {
                this.verbose_mode = true;
                this.addLog("启用详细模式");
            }
        }
    }

    // 创建量子纠缠态
    createEntanglement() {
        this.addLog("创建量子纠缠态...");
        
        // 在第一个寄存器上应用Hadamard门
        H(this.register_a[0]);
        H(this.register_a[1]);
        
        // 使用CNOT门创建纠缠
        CNOT(this.register_a[0], this.register_b[0]);
        CNOT(this.register_a[1], this.register_b[1]);
        
        this.addLog("纠缠态创建完成");
    }

    // 执行量子傅里叶变换
    applyQFT() {
        this.addLog("应用量子傅里叶变换...");
        
        // 在寄存器A上应用QFT
        QFT(this.register_a);
        
        this.addLog("QFT应用完成");
    }

    // 测量所有量子位
    measureQubits() {
        this.addLog("测量所有量子位...");
        
        let result_a = Measure(this.register_a);
        let result_b = Measure(this.register_b);
        
        this.results = [
            { register: "A", value: result_a },
            { register: "B", value: result_b }
        ];
        
        this.addLog(`测量结果: 寄存器A=${result_a}, 寄存器B=${result_b}`);
    }

    // 打印结果
    printResults() {
        console.log("==== 测试结果 ====");
        console.log(`总量子位数: ${this.qubit_count}`);
        
        for (let i = 0; i < this.results.length; i++) {
            console.log(`寄存器 ${this.results[i].register}: ${this.results[i].value}`);
        }
        
        if (this.verbose_mode) {
            console.log("==== 日志记录 ====");
            for (let i = 0; i < this.log_entries.length; i++) {
                console.log(`[${i+1}] ${this.log_entries[i]}`);
            }
        }
    }

    // 添加日志记录
    addLog(message) {
        let timestamp = new Date().toISOString();
        this.log_entries.push(`${timestamp} - ${message}`);
    }

    // 主运行函数
    run(args) {
        this.parseArgs(args);
        this.initialize();
        
        // 执行量子操作
        this.createEntanglement();
        this.applyQFT();
        this.measureQubits();
        
        // 输出结果
        this.printResults();
        
        this.addLog("测试完成");
        return 0;
    }
}

// 导出程序
export TestCompileObj; 