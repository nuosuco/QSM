/**
 * QEntL macOS平台启动器
 * 
 * 提供macOS平台特定的编译器启动和环境设置功能
 */

// macOS平台启动器
const MacOSLauncher = {
    // 启动器状态
    state: {
        initialized: false,
        env_vars: {},
        temp_files: [],
        original_env: {},
        macos_version: null,
        is_arm64: false
    },
    
    // 设置启动器
    setup: function() {
        console.log("[MacOSLauncher] 初始化macOS平台启动器");
        
        // 保存原始环境变量
        this.state.original_env = { ...process.env };
        
        // 检测macOS版本
        this.detectMacOSVersion();
        
        // 检测处理器架构
        this.detectArchitecture();
        
        // 设置必要的环境变量
        this.setupEnvironment();
        
        // 创建临时目录
        this.setupTempDirectory();
        
        this.state.initialized = true;
        
        console.log("[MacOSLauncher] macOS平台启动器初始化完成");
        
        return true;
    },
    
    // 检测macOS版本
    detectMacOSVersion: function() {
        console.log("[MacOSLauncher] 检测macOS版本");
        
        try {
            // 使用macOS命令查询版本
            const { execSync } = require('child_process');
            const versionInfo = execSync('sw_vers -productVersion', { encoding: 'utf8' });
            
            this.state.macos_version = versionInfo.trim();
            
            console.log(`[MacOSLauncher] 检测到macOS版本: ${this.state.macos_version}`);
            
            // 解析主要版本号
            const versionParts = this.state.macos_version.split('.');
            if (versionParts.length >= 2) {
                const majorVersion = parseFloat(`${versionParts[0]}.${versionParts[1]}`);
                this.state.macos_major_version = majorVersion;
            }
        } catch (error) {
            console.warn("[MacOSLauncher] 无法检测macOS版本:", error.message);
            this.state.macos_version = "unknown";
        }
    },
    
    // 检测处理器架构
    detectArchitecture: function() {
        console.log("[MacOSLauncher] 检测处理器架构");
        
        try {
            // 使用macOS命令查询架构
            const { execSync } = require('child_process');
            const archInfo = execSync('uname -m', { encoding: 'utf8' });
            
            const architecture = archInfo.trim();
            this.state.is_arm64 = architecture === 'arm64';
            
            console.log(`[MacOSLauncher] 检测到处理器架构: ${architecture} (${this.state.is_arm64 ? 'Apple Silicon' : 'Intel'})`);
        } catch (error) {
            console.warn("[MacOSLauncher] 无法检测处理器架构:", error.message);
            this.state.is_arm64 = false;
        }
    },
    
    // 设置环境变量
    setupEnvironment: function() {
        console.log("[MacOSLauncher] 设置环境变量");
        
        // 设置临时目录环境变量
        const tempDir = process.env.TMPDIR || '/tmp';
        this.state.env_vars.QENTL_TEMP = `${tempDir}/QEntL`;
        
        // 设置QEntL编译器路径
        this.state.env_vars.QENTL_COMPILER_PATH = process.cwd();
        
        // 设置macOS特定环境变量
        this.state.env_vars.QENTL_MACOS_VERSION = this.state.macos_version;
        this.state.env_vars.QENTL_ARCHITECTURE = this.state.is_arm64 ? 'arm64' : 'x86_64';
        
        // 应用环境变量
        Object.assign(process.env, this.state.env_vars);
        
        console.log("[MacOSLauncher] 环境变量设置完成");
    },
    
    // 设置临时目录
    setupTempDirectory: function() {
        console.log("[MacOSLauncher] 设置临时目录");
        
        const fs = require('fs');
        const path = require('path');
        
        try {
            // 确保临时目录存在
            const tempDir = this.state.env_vars.QENTL_TEMP;
            
            if (!fs.existsSync(tempDir)) {
                fs.mkdirSync(tempDir, { recursive: true });
                
                // 设置权限为700 (rwx------)
                fs.chmodSync(tempDir, 0o700);
                
                console.log(`[MacOSLauncher] 创建临时目录: ${tempDir}`);
            }
        } catch (error) {
            console.warn("[MacOSLauncher] 无法创建临时目录:", error.message);
        }
    },
    
    // 执行命令
    execute: function(args) {
        console.log("[MacOSLauncher] 处理命令行参数");
        
        // 确保初始化
        if (!this.state.initialized) {
            this.setup();
        }
        
        // 处理macOS平台特定的路径格式
        if (args && args.inputFiles) {
            args.inputFiles = args.inputFiles.map(file => this.normalizePath(file));
            
            if (args.outputFile) {
                args.outputFile = this.normalizePath(args.outputFile);
            }
        }
        
        return args;
    },
    
    // 编译前处理
    beforeCompile: function(filename, options) {
        console.log(`[MacOSLauncher] 编译前处理: ${filename}`);
        
        // 在macOS上规范化路径
        const normalizedPath = this.normalizePath(filename);
        
        // 添加macOS平台特定选项
        options.platform = "macos";
        options.macos_version = this.state.macos_version;
        options.architecture = this.state.is_arm64 ? 'arm64' : 'x86_64';
        
        // Apple Silicon特定选项
        if (this.state.is_arm64) {
            options.apple_silicon = true;
        }
        
        return normalizedPath;
    },
    
    // 编译后处理
    afterCompile: function(result) {
        console.log("[MacOSLauncher] 编译后处理");
        
        // 处理编译结果
        if (result && result.success) {
            // 对输出文件进行macOS平台特定处理
            this.processOutputFile(result.output);
        }
        
        return result;
    },
    
    // 批量编译前处理
    beforeBatchCompile: function(filenames, options) {
        console.log(`[MacOSLauncher] 批量编译前处理: ${filenames.length}个文件`);
        
        // 在macOS上规范化所有路径
        const normalizedPaths = filenames.map(filename => this.normalizePath(filename));
        
        // 添加macOS平台特定选项
        options.platform = "macos";
        options.macos_version = this.state.macos_version;
        options.architecture = this.state.is_arm64 ? 'arm64' : 'x86_64';
        
        // Apple Silicon特定选项
        if (this.state.is_arm64) {
            options.apple_silicon = true;
        }
        
        return normalizedPaths;
    },
    
    // 批量编译后处理
    afterBatchCompile: function(result) {
        console.log("[MacOSLauncher] 批量编译后处理");
        
        // 处理批量编译结果
        if (result && result.success) {
            // 处理每个输出文件
            if (result.results) {
                for (const file in result.results) {
                    if (result.results[file].success) {
                        this.processOutputFile(result.results[file].output);
                    }
                }
            }
            
            // 如果是链接的可执行文件
            if (result.executableFile) {
                this.processOutputFile(result.executableFile);
            }
        }
        
        return result;
    },
    
    // 处理输出文件
    processOutputFile: function(outputFile) {
        console.log(`[MacOSLauncher] 处理输出文件: ${outputFile}`);
        
        try {
            const fs = require('fs');
            const path = require('path');
            
            // 如果文件存在
            if (outputFile && fs.existsSync(outputFile)) {
                // 如果是可执行文件，设置执行权限
                if (outputFile.endsWith('.qexe')) {
                    console.log("[MacOSLauncher] 设置可执行权限");
                    
                    // 设置权限为755 (rwxr-xr-x)
                    fs.chmodSync(outputFile, 0o755);
                    
                    // 为Apple Silicon编译的文件添加标记
                    if (this.state.is_arm64) {
                        this.addAppleSiliconMark(outputFile);
                    }
                }
                
                // 查找并解决macOS的隔离属性问题
                this.removeQuarantine(outputFile);
            }
        } catch (error) {
            console.warn(`[MacOSLauncher] 处理输出文件失败: ${error.message}`);
        }
    },
    
    // 为Apple Silicon添加标记
    addAppleSiliconMark: function(filePath) {
        try {
            const { execSync } = require('child_process');
            console.log("[MacOSLauncher] 添加Apple Silicon编译标记");
            
            // 这里只是一个占位符，实际中应该使用macOS特定工具如lipo来处理
            // execSync(`lipo -create ${filePath} -output ${filePath}`);
        } catch (error) {
            console.warn("[MacOSLauncher] 无法添加Apple Silicon标记:", error.message);
        }
    },
    
    // 移除macOS隔离属性
    removeQuarantine: function(filePath) {
        try {
            const { execSync } = require('child_process');
            console.log("[MacOSLauncher] 移除隔离属性");
            
            // 使用xattr移除隔离属性
            execSync(`xattr -d com.apple.quarantine "${filePath}" 2>/dev/null || true`);
        } catch (error) {
            // 忽略错误，因为文件可能没有隔离属性
        }
    },
    
    // 规范化路径
    normalizePath: function(path) {
        // 确保路径使用正斜杠
        return path.replace(/\\/g, '/');
    },
    
    // 清理
    cleanup: function() {
        console.log("[MacOSLauncher] 执行清理");
        
        // 恢复原始环境变量
        Object.assign(process.env, this.state.original_env);
        
        // 清理临时文件
        this.cleanupTempFiles();
        
        console.log("[MacOSLauncher] 清理完成");
        
        return true;
    },
    
    // 清理临时文件
    cleanupTempFiles: function() {
        console.log("[MacOSLauncher] 清理临时文件");
        
        const fs = require('fs');
        
        // 删除临时文件
        for (const file of this.state.temp_files) {
            try {
                if (fs.existsSync(file)) {
                    fs.unlinkSync(file);
                    console.log(`[MacOSLauncher] 删除临时文件: ${file}`);
                }
            } catch (error) {
                console.warn(`[MacOSLauncher] 无法删除临时文件 ${file}: ${error.message}`);
            }
        }
        
        // 清空临时文件列表
        this.state.temp_files = [];
    }
};

// 导出macOS启动器
module.exports = MacOSLauncher; 