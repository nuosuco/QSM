/**
 * QEntL链接器
 * QuantumGene: QG-COMPILER-LINKER-I5J6-1714043900
 * EntanglementStrength: 1.0
 */

quantum_program Linker {
    // 量子基因编码
    metadata: {
        name: "QEntL链接器",
        version: "1.0.0",
        description: "将QEntL目标文件链接为可执行文件或库的组件",
        quantum_gene: "QG-COMPILER-LINKER-I5J6-1714043900",
        entanglement_strength: 1.0,
        node_state: "ACTIVE"
    },
    
    // 链接器状态
    state: {
        initialized: false,
        output_format: "QXE",  // 默认输出为QEntL可执行文件
        input_files: [],
        resolved_symbols: {},
        unresolved_symbols: [],
        output_sections: {
            header: {},
            text: [],
            data: [],
            quantum: [],
            export: {}
        },
        errors: [],
        warnings: []
    },
    
    // 支持的输出格式
    supported_formats: ["QXE", "QLIB"],
    
    // 初始化链接器
    initialize: function(format = "QXE") {
        if (this.state.initialized) {
            return true;
        }
        
        log("Linker", "初始化链接器");
        
        if (!this.supported_formats.includes(format)) {
            this.addWarning(`不支持的输出格式: ${format}，使用默认格式QXE`);
            format = "QXE";
        }
        
        this.state.output_format = format;
        this.reset();
        this.state.initialized = true;
        
        return true;
    },
    
    // 重置链接器状态
    reset: function() {
        log("Linker", "重置链接器状态");
        
        this.state.input_files = [];
        this.state.resolved_symbols = {};
        this.state.unresolved_symbols = [];
        this.state.output_sections = {
            header: {
                magic: "QENTL",
                version: "1.0",
                format: this.state.output_format,
                timestamp: Date.now(),
                target_platform: "quantum_universal",
                entry_point: "_start",
                flags: []
            },
            text: [],
            data: [],
            quantum: [],
            export: {}
        };
        this.state.errors = [];
        this.state.warnings = [];
    },
    
    // 添加输入文件
    addInputFile: function(objectFile) {
        log("Linker", `添加输入文件: ${objectFile.header.name || "未命名"}`);
        
        // 确保初始化
        if (!this.state.initialized) {
            this.initialize();
        }
        
        // 验证文件格式
        if (objectFile.format !== "QOM" && objectFile.format !== "QLIB") {
            this.addError(`不支持的输入文件格式: ${objectFile.format}`);
            return false;
        }
        
        // 添加到输入文件列表
        this.state.input_files.push(objectFile);
        
        return true;
    },
    
    // 链接所有输入文件
    link: function(options = {}) {
        log("Linker", "开始链接");
        
        // 确保初始化
        if (!this.state.initialized) {
            this.initialize(options.format);
        }
        
        try {
            // 使用选项更新输出格式
            if (options.format && this.supported_formats.includes(options.format)) {
                this.state.output_format = options.format;
                this.state.output_sections.header.format = options.format;
            }
            
            // 使用选项更新其他配置
            if (options.entry_point) {
                this.state.output_sections.header.entry_point = options.entry_point;
            }
            
            // 收集所有符号
            this.collectSymbols();
            
            // 解析符号引用
            this.resolveSymbols();
            
            // 检查未解析的符号
            if (this.checkUnresolvedSymbols() === false) {
                return this.getErrorResult();
            }
            
            // 合并段
            this.mergeSections();
            
            // 更新输出文件头部
            this.updateOutputHeader();
            
            // 生成输出文件
            const outputFile = this.buildOutputFile();
            
            log("Linker", "链接完成");
            
            return {
                success: this.state.errors.length === 0,
                output_file: outputFile,
                errors: this.state.errors,
                warnings: this.state.warnings
            };
            
        } catch (error) {
            this.addError(`链接器异常: ${error.message}`);
            return this.getErrorResult();
        }
    },
    
    // 收集所有符号
    collectSymbols: function() {
        log("Linker", "收集所有符号");
        
        for (let i = 0; i < this.state.input_files.length; i++) {
            const file = this.state.input_files[i];
            const symbols = file.sections.symbols;
            
            for (let j = 0; j < symbols.length; j++) {
                const symbol = symbols[j];
                const name = symbol.name;
                
                // 检查符号是否已存在
                if (this.state.resolved_symbols[name]) {
                    // 如果已存在，且当前是强符号，前一个是弱符号，则覆盖
                    if (!symbol.weak && this.state.resolved_symbols[name].weak) {
                        this.state.resolved_symbols[name] = {
                            name: name,
                            file_index: i,
                            symbol_index: j,
                            address: symbol.address,
                            type: symbol.type,
                            section: symbol.section,
                            weak: symbol.weak || false
                        };
                    } else if (!symbol.weak && !this.state.resolved_symbols[name].weak) {
                        // 如果都是强符号，报告重复定义错误
                        this.addError(`符号'${name}'重复定义`);
                    }
                } else {
                    // 添加新符号
                    this.state.resolved_symbols[name] = {
                        name: name,
                        file_index: i,
                        symbol_index: j,
                        address: symbol.address,
                        type: symbol.type,
                        section: symbol.section,
                        weak: symbol.weak || false
                    };
                }
            }
        }
    },
    
    // 解析符号引用
    resolveSymbols: function() {
        log("Linker", "解析符号引用");
        
        this.state.unresolved_symbols = [];
        
        // 遍历所有文件的重定位条目
        for (let i = 0; i < this.state.input_files.length; i++) {
            const file = this.state.input_files[i];
            const relocations = file.sections.relocation;
            
            for (let j = 0; j < relocations.length; j++) {
                const relocation = relocations[j];
                const symbolName = relocation.symbol;
                
                // 检查符号是否已解析
                if (!this.state.resolved_symbols[symbolName]) {
                    // 未解析的符号
                    if (!this.state.unresolved_symbols.includes(symbolName)) {
                        this.state.unresolved_symbols.push(symbolName);
                    }
                }
            }
        }
    },
    
    // 检查是否有未解析的符号
    checkUnresolvedSymbols: function() {
        if (this.state.unresolved_symbols.length > 0) {
            for (const symbol of this.state.unresolved_symbols) {
                this.addError(`未解析的符号: ${symbol}`);
            }
            
            if (this.state.output_format === "QXE") {
                // 可执行文件需要解析所有符号
                return false;
            } else {
                // 库文件可以有未解析的符号
                this.addWarning(`库文件包含${this.state.unresolved_symbols.length}个未解析的符号`);
            }
        }
        
        return true;
    },
    
    // 合并段
    mergeSections: function() {
        log("Linker", "合并段");
        
        // 合并文本段
        this.mergeTextSections();
        
        // 合并数据段
        this.mergeDataSections();
        
        // 合并量子段
        this.mergeQuantumSections();
        
        // 如果是库文件，合并导出符号
        if (this.state.output_format === "QLIB") {
            this.mergeExportSections();
        }
    },
    
    // 合并文本段
    mergeTextSections: function() {
        let textOffset = 0;
        
        for (let i = 0; i < this.state.input_files.length; i++) {
            const file = this.state.input_files[i];
            const textSection = file.sections.text;
            
            // 计算此文件文本段的基址
            const textBase = textOffset;
            
            // 更新此文件中的符号地址
            this.updateSymbolAddresses(i, "text", textBase);
            
            // 合并文本段
            for (let j = 0; j < textSection.length; j++) {
                const instruction = textSection[j];
                
                // 深拷贝指令
                const newInstruction = {...instruction};
                
                // 更新地址
                newInstruction.address = textOffset;
                
                // 添加到输出
                this.state.output_sections.text.push(newInstruction);
                
                // 更新偏移量
                textOffset += instruction.size;
            }
        }
    },
    
    // 合并数据段
    mergeDataSections: function() {
        let dataOffset = 0;
        
        for (let i = 0; i < this.state.input_files.length; i++) {
            const file = this.state.input_files[i];
            const dataSection = file.sections.data;
            
            // 计算此文件数据段的基址
            const dataBase = dataOffset;
            
            // 更新此文件中的符号地址
            this.updateSymbolAddresses(i, "data", dataBase);
            
            // 合并数据段
            for (let j = 0; j < dataSection.length; j++) {
                const data = dataSection[j];
                
                // 深拷贝数据
                const newData = {...data};
                
                // 更新地址
                newData.address = dataOffset;
                
                // 添加到输出
                this.state.output_sections.data.push(newData);
                
                // 更新偏移量
                dataOffset += data.size;
            }
        }
    },
    
    // 合并量子段
    mergeQuantumSections: function() {
        let quantumOffset = 0;
        
        for (let i = 0; i < this.state.input_files.length; i++) {
            const file = this.state.input_files[i];
            const quantumSection = file.sections.quantum;
            
            // 计算此文件量子段的基址
            const quantumBase = quantumOffset;
            
            // 更新此文件中的符号地址
            this.updateSymbolAddresses(i, "quantum", quantumBase);
            
            // 合并量子段
            for (let j = 0; j < quantumSection.length; j++) {
                const quantum = quantumSection[j];
                
                // 深拷贝量子数据
                const newQuantum = {...quantum};
                
                // 更新地址
                newQuantum.address = quantumOffset;
                
                // 添加到输出
                this.state.output_sections.quantum.push(newQuantum);
                
                // 更新偏移量
                quantumOffset += quantum.size;
            }
        }
    },
    
    // 合并导出符号
    mergeExportSections: function() {
        for (let i = 0; i < this.state.input_files.length; i++) {
            const file = this.state.input_files[i];
            
            // 如果是库文件，它有导出段
            if (file.format === "QLIB" && file.exports) {
                for (const exportSymbol of file.exports) {
                    const originalName = exportSymbol.original;
                    const exportName = exportSymbol.name;
                    
                    // 验证符号存在
                    if (this.state.resolved_symbols[originalName]) {
                        // 添加到导出表
                        this.state.output_sections.export[exportName] = {
                            name: exportName,
                            original: originalName,
                            type: exportSymbol.type
                        };
                    }
                }
            } else {
                // 如果是普通目标文件，自动导出所有公共符号
                for (const symbolName in this.state.resolved_symbols) {
                    if (this.state.resolved_symbols.hasOwnProperty(symbolName) && 
                        this.state.resolved_symbols[symbolName].file_index === i) {
                        
                        const symbol = this.state.resolved_symbols[symbolName];
                        
                        // 公共符号以'export_'开头或类型为'EXPORT'
                        if (symbolName.startsWith("export_") || symbol.type === "EXPORT") {
                            const exportName = symbolName.startsWith("export_") ? 
                                symbolName.substring(7) : symbolName;
                            
                            this.state.output_sections.export[exportName] = {
                                name: exportName,
                                original: symbolName,
                                type: symbol.type
                            };
                        }
                    }
                }
            }
        }
    },
    
    // 更新符号地址
    updateSymbolAddresses: function(fileIndex, section, baseAddress) {
        for (const symbolName in this.state.resolved_symbols) {
            if (this.state.resolved_symbols.hasOwnProperty(symbolName)) {
                const symbol = this.state.resolved_symbols[symbolName];
                
                // 如果符号属于当前文件和段
                if (symbol.file_index === fileIndex && symbol.section === section) {
                    // 更新符号地址
                    symbol.address = baseAddress + symbol.address;
                }
            }
        }
    },
    
    // 更新输出文件头部
    updateOutputHeader: function() {
        log("Linker", "更新输出文件头部");
        
        // 从第一个输入文件复制基本信息
        if (this.state.input_files.length > 0) {
            const firstFile = this.state.input_files[0];
            
            this.state.output_sections.header.quantum_gene = 
                `QG-LINKED-${this.generateRandomHex(4)}-${Math.floor(Date.now() / 1000)}`;
                
            // 如果是可执行文件，使用指定的入口点
            if (this.state.output_format === "QXE") {
                // 检查入口点是否存在
                if (!this.state.resolved_symbols[this.state.output_sections.header.entry_point]) {
                    this.addWarning(`找不到入口点: ${this.state.output_sections.header.entry_point}，使用默认值`);
                }
            }
        }
        
        // 设置输出格式和当前时间戳
        this.state.output_sections.header.format = this.state.output_format;
        this.state.output_sections.header.timestamp = Date.now();
    },
    
    // 构建输出文件
    buildOutputFile: function() {
        log("Linker", "构建输出文件");
        
        // 创建输出文件结构
        const outputFile = {
            format: this.state.output_format,
            header: this.state.output_sections.header,
            sections: {
                text: this.state.output_sections.text,
                data: this.state.output_sections.data,
                quantum: this.state.output_sections.quantum
            }
        };
        
        // 如果是可执行文件，添加入口点信息
        if (this.state.output_format === "QXE") {
            outputFile.entry_point = this.state.output_sections.header.entry_point;
            
            // 添加入口点地址
            if (this.state.resolved_symbols[outputFile.entry_point]) {
                outputFile.entry_point_address = this.state.resolved_symbols[outputFile.entry_point].address;
            }
            
            outputFile.qxe_version = "1.0";
        }
        
        // 如果是库文件，添加导出符号
        if (this.state.output_format === "QLIB") {
            outputFile.exports = this.convertExportsToArray();
            outputFile.qlib_version = "1.0";
        }
        
        return outputFile;
    },
    
    // 将导出符号转换为数组
    convertExportsToArray: function() {
        const exportsArray = [];
        
        for (const exportName in this.state.output_sections.export) {
            if (this.state.output_sections.export.hasOwnProperty(exportName)) {
                exportsArray.push(this.state.output_sections.export[exportName]);
            }
        }
        
        return exportsArray;
    },
    
    // 生成随机十六进制字符串
    generateRandomHex: function(length) {
        const hex = "0123456789ABCDEF";
        let result = "";
        
        for (let i = 0; i < length; i++) {
            result += hex.charAt(Math.floor(Math.random() * hex.length));
        }
        
        return result;
    },
    
    // 获取错误结果
    getErrorResult: function() {
        return {
            success: false,
            output_file: null,
            errors: this.state.errors,
            warnings: this.state.warnings
        };
    },
    
    // 添加错误
    addError: function(message) {
        const error = {
            message: message,
            timestamp: Date.now()
        };
        
        this.state.errors.push(error);
        log("Linker", `错误: ${message}`, "ERROR");
    },
    
    // 添加警告
    addWarning: function(message) {
        const warning = {
            message: message,
            timestamp: Date.now()
        };
        
        this.state.warnings.push(warning);
        log("Linker", `警告: ${message}`, "WARNING");
    }
};

// 导出链接器
export Linker; 