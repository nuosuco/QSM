/**
 * QEntL语义分析器
 * QuantumGene: QG-COMPILER-SEMANTIC-A1B2-1714043530
 * EntanglementStrength: 1.0
 */

quantum_module SemanticAnalyzer {
    // 量子基因编码
    metadata: {
        name: "QEntL语义分析器",
        version: "1.0.0",
        description: "QEntL语言语义分析器",
        quantum_gene: "QG-COMPILER-SEMANTIC-A1B2-1714043530",
        entanglement_strength: 1.0,
        node_state: "ACTIVE"
    },
    
    // 语义分析器状态
    state: {
        ast: null,
        symbol_table: [],
        current_scope: null,
        error_list: [],
        warning_list: [],
        is_initialized: false,
        // 当前上下文信息
        current_function: null,
        current_loop: null,
        current_module: null,
        in_quantum_context: false
    },
    
    // 初始化语义分析器
    initialize: function() {
        log("SemanticAnalyzer", "初始化语义分析器");
        this.state.is_initialized = true;
        this.reset();
        return true;
    },
    
    // 重置状态
    reset: function() {
        this.state.ast = null;
        this.state.symbol_table = [];
        this.state.current_scope = this.createScope("global");
        this.state.error_list = [];
        this.state.warning_list = [];
        this.state.current_function = null;
        this.state.current_loop = null;
        this.state.current_module = null;
        this.state.in_quantum_context = false;
    },
    
    // 创建新的作用域
    createScope: function(name) {
        return {
            name: name,
            parent: this.state.current_scope,
            symbols: {},
            children: []
        };
    },
    
    // 进入新作用域
    enterScope: function(name) {
        const newScope = this.createScope(name);
        if (this.state.current_scope) {
            this.state.current_scope.children.push(newScope);
        }
        this.state.current_scope = newScope;
        return newScope;
    },
    
    // 离开当前作用域
    exitScope: function() {
        if (this.state.current_scope && this.state.current_scope.parent) {
            this.state.current_scope = this.state.current_scope.parent;
        } else {
            this.addError("尝试退出全局作用域");
        }
    },
    
    // 在当前作用域中声明符号
    declareSymbol: function(name, type, info = {}) {
        if (!this.state.current_scope) {
            this.addError(`无法在空作用域中声明符号: ${name}`);
            return false;
        }
        
        // 检查当前作用域中是否已存在同名符号
        if (this.state.current_scope.symbols[name]) {
            this.addError(`符号重定义: ${name}`);
            return false;
        }
        
        // 创建符号
        this.state.current_scope.symbols[name] = {
            name: name,
            type: type,
            defined: true,
            ...info
        };
        
        return true;
    },
    
    // 查找符号
    lookupSymbol: function(name) {
        let scope = this.state.current_scope;
        
        while (scope) {
            if (scope.symbols[name]) {
                return scope.symbols[name];
            }
            scope = scope.parent;
        }
        
        return null;
    },
    
    // 分析AST
    analyze: function(ast) {
        log("SemanticAnalyzer", "开始语义分析");
        
        this.reset();
        this.state.ast = ast;
        
        // 第一遍：收集声明信息
        this.collectDeclarations(ast);
        
        // 第二遍：分析语义
        this.analyzeNode(ast);
        
        log("SemanticAnalyzer", `语义分析完成，${this.state.error_list.length} 个错误，${this.state.warning_list.length} 个警告`);
        
        return ast;
    },
    
    // 收集声明信息
    collectDeclarations: function(node) {
        if (!node) {
            return;
        }
        
        switch (node.type) {
            case "Program":
                for (const statement of node.body) {
                    this.collectDeclarations(statement);
                }
                break;
                
            case "QuantumProgram":
                // 声明量子程序
                this.declareSymbol(node.name, "quantum_program", {
                    node: node
                });
                
                // 进入程序作用域
                this.enterScope(`program:${node.name}`);
                
                // 收集程序体内的声明
                for (const statement of node.body) {
                    this.collectDeclarations(statement);
                }
                
                // 离开程序作用域
                this.exitScope();
                break;
                
            case "QuantumModule":
                // 声明量子模块
                this.declareSymbol(node.name, "quantum_module", {
                    node: node
                });
                
                // 进入模块作用域
                this.enterScope(`module:${node.name}`);
                
                // 收集模块体内的声明
                for (const statement of node.body) {
                    this.collectDeclarations(statement);
                }
                
                // 离开模块作用域
                this.exitScope();
                break;
                
            case "QuantumEntity":
                // 声明量子实体
                this.declareSymbol(node.name, "quantum_entity", {
                    node: node
                });
                
                // 进入实体作用域
                this.enterScope(`entity:${node.name}`);
                
                // 收集实体体内的声明
                for (const statement of node.body) {
                    this.collectDeclarations(statement);
                }
                
                // 离开实体作用域
                this.exitScope();
                break;
                
            case "FunctionDeclaration":
                if (node.name) {
                    // 声明函数
                    this.declareSymbol(node.name, "function", {
                        params: node.params,
                        node: node
                    });
                }
                
                // 进入函数作用域
                this.enterScope(`function:${node.name || "anonymous"}`);
                
                // 声明函数参数
                for (const param of node.params) {
                    this.declareSymbol(param, "parameter", {
                        node: node
                    });
                }
                
                // 收集函数体内的声明
                for (const statement of node.body) {
                    this.collectDeclarations(statement);
                }
                
                // 离开函数作用域
                this.exitScope();
                break;
                
            case "VariableDeclaration":
                // 声明变量
                this.declareSymbol(node.name, node.kind, {
                    node: node
                });
                break;
                
            case "ImportStatement":
                // 记录导入信息
                // 但不处理符号，因为需要查看导入的文件内容
                break;
                
            case "ExportStatement":
                // 处理导出声明
                this.collectDeclarations(node.declaration);
                break;
                
            // 其他语句类型无需预先收集声明信息
            default:
                break;
        }
    },
    
    // 分析节点
    analyzeNode: function(node) {
        if (!node) {
            return;
        }
        
        switch (node.type) {
            case "Program":
                for (const statement of node.body) {
                    this.analyzeNode(statement);
                }
                break;
                
            case "QuantumProgram":
                // 保存当前模块信息
                const prevModule = this.state.current_module;
                this.state.current_module = node;
                
                // 进入程序作用域
                this.enterScope(`program:${node.name}`);
                
                // 分析程序体
                for (const statement of node.body) {
                    this.analyzeNode(statement);
                }
                
                // 离开程序作用域
                this.exitScope();
                
                // 恢复当前模块信息
                this.state.current_module = prevModule;
                break;
                
            case "QuantumModule":
                // 保存当前模块信息
                const prevMod = this.state.current_module;
                this.state.current_module = node;
                
                // 进入模块作用域
                this.enterScope(`module:${node.name}`);
                
                // 分析模块体
                for (const statement of node.body) {
                    this.analyzeNode(statement);
                }
                
                // 离开模块作用域
                this.exitScope();
                
                // 恢复当前模块信息
                this.state.current_module = prevMod;
                break;
                
            case "QuantumEntity":
                // 进入实体作用域
                this.enterScope(`entity:${node.name}`);
                
                // 分析实体体
                for (const statement of node.body) {
                    this.analyzeNode(statement);
                }
                
                // 离开实体作用域
                this.exitScope();
                break;
                
            case "FunctionDeclaration":
                // 保存当前函数信息
                const prevFunction = this.state.current_function;
                this.state.current_function = node;
                
                // 进入函数作用域
                this.enterScope(`function:${node.name || "anonymous"}`);
                
                // 分析函数体
                for (const statement of node.body) {
                    this.analyzeNode(statement);
                }
                
                // 离开函数作用域
                this.exitScope();
                
                // 恢复当前函数信息
                this.state.current_function = prevFunction;
                break;
                
            case "VariableDeclaration":
                // 分析初始化表达式
                if (node.initializer) {
                    this.analyzeNode(node.initializer);
                }
                break;
                
            case "ImportStatement":
                // 验证导入路径是否是字符串字面量
                if (typeof node.path !== "string") {
                    this.addError("导入路径必须是字符串字面量");
                }
                break;
                
            case "ExportStatement":
                // 分析导出的声明
                this.analyzeNode(node.declaration);
                break;
                
            case "IfStatement":
                // 分析条件表达式
                this.analyzeNode(node.condition);
                
                // 分析then分支
                this.analyzeNode(node.thenBranch);
                
                // 分析else分支
                if (node.elseBranch) {
                    this.analyzeNode(node.elseBranch);
                }
                break;
                
            case "ForStatement":
                // 保存当前循环信息
                const prevLoop = this.state.current_loop;
                this.state.current_loop = node;
                
                // 进入循环作用域
                this.enterScope("for");
                
                // 分析初始化表达式
                if (node.initializer) {
                    this.analyzeNode(node.initializer);
                }
                
                // 分析条件表达式
                if (node.condition) {
                    this.analyzeNode(node.condition);
                }
                
                // 分析增量表达式
                if (node.increment) {
                    this.analyzeNode(node.increment);
                }
                
                // 分析循环体
                this.analyzeNode(node.body);
                
                // 离开循环作用域
                this.exitScope();
                
                // 恢复当前循环信息
                this.state.current_loop = prevLoop;
                break;
                
            case "WhileStatement":
                // 保存当前循环信息
                const prevWhileLoop = this.state.current_loop;
                this.state.current_loop = node;
                
                // 进入循环作用域
                this.enterScope("while");
                
                // 分析条件表达式
                this.analyzeNode(node.condition);
                
                // 分析循环体
                this.analyzeNode(node.body);
                
                // 离开循环作用域
                this.exitScope();
                
                // 恢复当前循环信息
                this.state.current_loop = prevWhileLoop;
                break;
                
            case "ReturnStatement":
                // 检查是否在函数内部
                if (!this.state.current_function) {
                    this.addError("return语句只能出现在函数内部");
                }
                
                // 分析返回值
                if (node.value) {
                    this.analyzeNode(node.value);
                }
                break;
                
            case "ExpressionStatement":
                // 分析表达式
                this.analyzeNode(node.expression);
                break;
                
            case "CallExpression":
                // 分析调用函数
                this.analyzeNode(node.callee);
                
                // 分析参数
                for (const arg of node.arguments) {
                    this.analyzeNode(arg);
                }
                
                // 验证函数调用
                if (node.callee.type === "Identifier") {
                    const symbol = this.lookupSymbol(node.callee.name);
                    if (!symbol) {
                        this.addError(`调用未声明的函数: ${node.callee.name}`);
                    } else if (symbol.type !== "function") {
                        this.addError(`尝试调用非函数对象: ${node.callee.name}`);
                    } else if (symbol.params && symbol.params.length !== node.arguments.length) {
                        this.addError(`函数参数数量不匹配: ${node.callee.name} 期望 ${symbol.params.length} 个参数，但得到 ${node.arguments.length} 个`);
                    }
                }
                break;
                
            case "AssignmentExpression":
                // 分析赋值目标
                this.analyzeNode(node.left);
                
                // 分析赋值值
                this.analyzeNode(node.right);
                
                // 验证赋值目标
                if (node.left.type === "Identifier") {
                    const symbol = this.lookupSymbol(node.left.name);
                    if (!symbol) {
                        this.addError(`赋值给未声明的变量: ${node.left.name}`);
                    } else if (symbol.type === "const") {
                        this.addError(`不能赋值给常量: ${node.left.name}`);
                    }
                }
                break;
                
            case "BinaryExpression":
                // 分析左操作数
                this.analyzeNode(node.left);
                
                // 分析右操作数
                this.analyzeNode(node.right);
                break;
                
            case "LogicalExpression":
                // 分析左操作数
                this.analyzeNode(node.left);
                
                // 分析右操作数
                this.analyzeNode(node.right);
                break;
                
            case "UnaryExpression":
                // 分析操作数
                this.analyzeNode(node.argument);
                break;
                
            case "QuantumExpression":
                // 设置量子上下文标志
                const prevQuantumContext = this.state.in_quantum_context;
                this.state.in_quantum_context = true;
                
                // 分析操作数
                this.analyzeNode(node.argument);
                
                // 恢复量子上下文标志
                this.state.in_quantum_context = prevQuantumContext;
                break;
                
            case "Identifier":
                // 验证标识符是否已声明
                const symbol = this.lookupSymbol(node.name);
                if (!symbol) {
                    this.addError(`使用未声明的标识符: ${node.name}`);
                }
                break;
                
            case "MemberExpression":
                // 分析对象
                this.analyzeNode(node.object);
                
                // 分析属性
                if (node.computed) {
                    this.analyzeNode(node.property);
                }
                break;
                
            case "ObjectExpression":
                // 分析对象属性
                for (const prop of node.properties) {
                    this.analyzeNode(prop);
                }
                break;
                
            case "Property":
                // 分析属性值
                this.analyzeNode(prop.value);
                break;
                
            case "ArrayExpression":
                // 分析数组元素
                for (const element of node.elements) {
                    this.analyzeNode(element);
                }
                break;
                
            // 基本值类型无需进一步分析
            case "Literal":
            case "EmptyStatement":
                break;
                
            default:
                this.addWarning(`未处理的节点类型: ${node.type}`);
                break;
        }
    },
    
    // 添加错误
    addError: function(message, location = null) {
        const error = {
            message: message,
            location: location,
            timestamp: Date.now()
        };
        
        this.state.error_list.push(error);
        log("SemanticAnalyzer", `语义错误: ${message}`, "ERROR");
        return error;
    },
    
    // 添加警告
    addWarning: function(message, location = null) {
        const warning = {
            message: message,
            location: location,
            timestamp: Date.now()
        };
        
        this.state.warning_list.push(warning);
        log("SemanticAnalyzer", `语义警告: ${message}`, "WARNING");
        return warning;
    }
};

// 导出语义分析器
export SemanticAnalyzer; 