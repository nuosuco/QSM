/**
 * QEntL编译器主程序
 * QuantumGene: QG-COMPILER-MAIN-A1B2-1714043600
 * EntanglementStrength: 1.0
 */

quantum_program QEntLCompiler {
    // 量子基因编码
    metadata: {
        name: "QEntL编译器",
        version: "1.0.0",
        description: "QEntL语言编译器主程序",
        quantum_gene: "QG-COMPILER-MAIN-A1B2-1714043600",
        entanglement_strength: 1.0,
        node_state: "ACTIVE"
    },
    
    // 加载编译器核心
    components: {
        compiler_core: @import("core/compiler_core.qentl")
    },
    
    // 编译器配置
    config: {
        default_output_extension: ".qobj",
        optimization_level: "high", // 可选：none, low, medium, high
        include_debug_info: false,
        generate_source_map: true,
        target_platform: "multiplatform", // 可选：multiplatform, quantum, classical
        emit_quantum_gene: true,
        enable_entanglement_channel: true,
        quantum_bit_adaptive: true
    },
    
    // 命令行参数解析
    parseCommandLine: function(args) {
        log("QEntLCompiler", "解析命令行参数");
        
        const options = Object.assign({}, this.config);
        const inputFiles = [];
        let outputFile = null;
        
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            
            if (arg.startsWith("-")) {
                // 处理选项
                switch (arg) {
                    case "-o":
                    case "--output":
                        if (i + 1 < args.length) {
                            outputFile = args[++i];
                        } else {
                            log("QEntLCompiler", "错误: -o/--output 选项需要一个文件名", "ERROR");
                            return null;
                        }
                        break;
                        
                    case "-O0":
                        options.optimization_level = "none";
                        break;
                        
                    case "-O1":
                        options.optimization_level = "low";
                        break;
                        
                    case "-O2":
                        options.optimization_level = "medium";
                        break;
                        
                    case "-O3":
                        options.optimization_level = "high";
                        break;
                        
                    case "-g":
                    case "--debug":
                        options.include_debug_info = true;
                        break;
                        
                    case "--no-sourcemap":
                        options.generate_source_map = false;
                        break;
                        
                    case "--target":
                        if (i + 1 < args.length) {
                            const target = args[++i];
                            if (["multiplatform", "quantum", "classical"].includes(target)) {
                                options.target_platform = target;
                            } else {
                                log("QEntLCompiler", `错误: 无效的目标平台: ${target}`, "ERROR");
                                return null;
                            }
                        } else {
                            log("QEntLCompiler", "错误: --target 选项需要一个平台名称", "ERROR");
                            return null;
                        }
                        break;
                        
                    case "--no-quantum-gene":
                        options.emit_quantum_gene = false;
                        break;
                        
                    case "--no-entanglement":
                        options.enable_entanglement_channel = false;
                        break;
                        
                    case "--no-adaptive":
                        options.quantum_bit_adaptive = false;
                        break;
                        
                    case "-h":
                    case "--help":
                        this.showHelp();
                        return null;
                        
                    case "-v":
                    case "--version":
                        this.showVersion();
                        return null;
                        
                    default:
                        log("QEntLCompiler", `警告: 未知选项: ${arg}`, "WARNING");
                        break;
                }
            } else {
                // 处理输入文件
                inputFiles.push(arg);
            }
        }
        
        if (inputFiles.length === 0) {
            log("QEntLCompiler", "错误: 未指定输入文件", "ERROR");
            this.showHelp();
            return null;
        }
        
        return {
            inputFiles: inputFiles,
            outputFile: outputFile,
            options: options
        };
    },
    
    // 显示帮助信息
    showHelp: function() {
        console.log("QEntL编译器 v1.0.0");
        console.log("用法: qentl-compiler [选项] 文件 ...");
        console.log("");
        console.log("选项:");
        console.log("  -o, --output <文件>       指定输出文件");
        console.log("  -O0, -O1, -O2, -O3        设置优化级别(none, low, medium, high)");
        console.log("  -g, --debug               包含调试信息");
        console.log("  --no-sourcemap            不生成源码映射");
        console.log("  --target <平台>           指定目标平台(multiplatform, quantum, classical)");
        console.log("  --no-quantum-gene         不生成量子基因编码");
        console.log("  --no-entanglement         不生成量子纠缠信道");
        console.log("  --no-adaptive             不启用量子比特自适应能力");
        console.log("  -h, --help                显示此帮助信息");
        console.log("  -v, --version             显示版本信息");
    },
    
    // 显示版本信息
    showVersion: function() {
        console.log("QEntL编译器 v1.0.0");
        console.log("量子基因编码: QG-COMPILER-MAIN-A1B2-1714043600");
        console.log("纠缠强度: 1.0");
    },
    
    // 编译单个文件
    compileFile: function(filepath, options, outputPath) {
        log("QEntLCompiler", `编译文件: ${filepath}`);
        
        // 如果未指定输出路径，则根据输入文件生成
        if (!outputPath) {
            outputPath = this.generateOutputPath(filepath, options);
        }
        
        // 调用编译器核心进行编译
        const result = this.components.compiler_core.compileFile(filepath, {
            ...options,
            output: outputPath
        });
        
        if (result.success) {
            log("QEntLCompiler", `编译成功: ${filepath} -> ${result.output}`);
        } else {
            log("QEntLCompiler", `编译失败: ${filepath}, 阶段: ${result.stage}`, "ERROR");
            
            // 输出错误信息
            for (const error of result.errors) {
                console.error(`错误: ${error.message} (${error.line}:${error.column})`);
            }
        }
        
        return result;
    },
    
    // 编译多个文件
    compileFiles: function(filepaths, options, outputPath) {
        log("QEntLCompiler", `编译多个文件: ${filepaths.length} 个文件`);
        
        // 如果指定了单一输出路径，但有多个输入文件，则需要特殊处理
        if (outputPath && filepaths.length > 1) {
            // 假设输出是对象文件，可以链接在一起
            const objectFiles = [];
            let allSuccess = true;
            
            // 先编译成对象文件
            for (const filepath of filepaths) {
                // 生成临时对象文件路径
                const tempObjPath = this.generateOutputPath(filepath, {
                    ...options,
                    default_output_extension: ".qobj.tmp"
                });
                
                // 编译文件
                const result = this.compileFile(filepath, options, tempObjPath);
                
                if (result.success) {
                    objectFiles.push(tempObjPath);
                } else {
                    allSuccess = false;
                }
            }
            
            // 如果所有文件都编译成功，则链接它们
            if (allSuccess && objectFiles.length > 0) {
                this.linkFiles(objectFiles, outputPath, options);
            }
            
            return {
                success: allSuccess,
                objectFiles: objectFiles,
                executableFile: allSuccess ? outputPath : null
            };
            
        } else {
            // 多文件，多输出
            const results = {};
            let allSuccess = true;
            
            for (const filepath of filepaths) {
                // 生成输出路径
                const filePath = outputPath || this.generateOutputPath(filepath, options);
                
                // 编译文件
                const result = this.compileFile(filepath, options, filePath);
                results[filepath] = result;
                
                if (!result.success) {
                    allSuccess = false;
                }
            }
            
            return {
                success: allSuccess,
                results: results
            };
        }
    },
    
    // 链接多个对象文件
    linkFiles: function(objectFiles, outputFile, options) {
        log("QEntLCompiler", `链接文件: ${objectFiles.join(", ")} -> ${outputFile}`);
        
        // TODO: 实现实际的链接逻辑
        // 这里只是一个模拟实现
        
        log("QEntLCompiler", `链接完成: ${outputFile}`);
        
        return {
            success: true,
            output: outputFile
        };
    },
    
    // 生成输出文件路径
    generateOutputPath: function(inputPath, options) {
        // 获取文件扩展名
        const extension = options.default_output_extension || this.config.default_output_extension;
        
        // 替换扩展名
        if (inputPath.endsWith(".qentl")) {
            return inputPath.replace(/\.qentl$/, extension);
        } else {
            return inputPath + extension;
        }
    },
    
    // 编译器主函数
    main: function(args) {
        log("QEntLCompiler", "QEntL编译器启动");
        
        // 初始化编译器核心
        this.components.compiler_core.initialize();
        
        // 解析命令行参数
        const params = this.parseCommandLine(args);
        if (!params) {
            return 1; // 参数解析错误
        }
        
        // 编译文件
        const result = this.compileFiles(params.inputFiles, params.options, params.outputFile);
        
        log("QEntLCompiler", "QEntL编译器完成");
        
        // 返回编译结果
        return result.success ? 0 : 1;
    }
};

// 如果是直接运行，调用主函数
if (require.main === module) {
    process.exit(QEntLCompiler.main(process.argv.slice(2)));
}

// 导出编译器
export QEntLCompiler; 