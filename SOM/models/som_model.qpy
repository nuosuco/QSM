#!/usr/bin/env qpy
# -*- coding: utf-8 -*-

"""
量子自组织市场模型 (SOM) - 核心模型

提供基于量子原理的经济系统核心功能，包括:
- 市场与供需动态自组织调节
- 量子币创建与管理
- 钱包系统与交易处理
- 智能合约执行
- 去中心化交易所
"""

# 量子基因编码
QG-SOM-MODEL-CORE-A1B3

# 量子纠缠信道
@quantum_entangle
  channel_id: QE-SOM-MODEL-20240406
  state: ACTIVE
  strength: 0.94
  objects: [
    "QSM/models/qsm_model.qpy",
    "WeQ/models/weq_model.qpy",
    "SOM/api/som_api.qpy",
    "SOM/services/market_service.qpy"
  ]

@imports
  standard: [os, sys, json, logging, time, datetime, uuid, random, math, hashlib]
  numpy: [numpy as np]
  quantum_math: [
    QuantumVector,
    QuantumMatrix,
    QuantumTensor,
    quantum_fourier_transform
  ]
  quantum_crypto: [
    QuantumHash,
    QuantumSignature,
    QuantumKeyPair
  ]
  quantum_data: [
    QuantumDataFrame,
    QuantumTimeSeries
  ]
  quantum_core: [
    QuantumState,
    QuantumSuperposition
  ]

@constants
  # 目录设置
  ROOT_DIR = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
  DATA_DIR = os.path.join(ROOT_DIR, 'data', 'som')
  LOG_DIR = os.path.join(ROOT_DIR, '.logs')
  
  # 市场参数
  MARKET_FEE = 0.001  # 0.1%
  MIN_LIQUIDITY = 1000
  
  # 量子币参数
  DEFAULT_SUPPLY = 1_000_000
  QUANTUM_ENTROPY_BITS = 256
  
  # 合约参数
  MAX_CONTRACT_EXECUTION_TIME = 10  # 秒
  
  # 价格发现参数
  PRICE_HISTORY_LENGTH = 100
  PRICE_UPDATE_INTERVAL = 60  # 秒

@initialization
  # 创建数据目录
  os.makedirs(DATA_DIR, exist_ok=True)
  
  # 创建日志目录
  os.makedirs(LOG_DIR, exist_ok=True)
  
  # 配置日志
  logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
      logging.FileHandler(os.path.join(LOG_DIR, 'som.log')),
      logging.StreamHandler()
    ]
  )
  logger = logging.getLogger('SOM-Model')

@class Coin
  @constructor(name, symbol, initial_supply=DEFAULT_SUPPLY, creator=None, properties=None)
    """初始化量子币
    
    Args:
        name: 量子币名称
        symbol: 量子币符号
        initial_supply: 初始供应量
        creator: 创建者ID
        properties: 币种特性字典
    """
    self.id = str(uuid.uuid4())
    self.name = name
    self.symbol = symbol
    self.total_supply = initial_supply
    self.circulating_supply = 0
    self.creator = creator
    self.creation_time = datetime.datetime.now().isoformat()
    self.properties = properties or {}
    self.quantum_state = self._create_quantum_state()
    self.holders = {}  # 持有者ID -> 数量
    self.price_history = []
    self.last_price = 1.0  # 初始价格
    
    logger.info(f"创建量子币: {self.name} ({self.symbol}), 供应量: {self.total_supply}")
  
  @method _create_quantum_state()
    """创建量子币的量子态
    
    Returns:
        QuantumState: 币种的量子态
    """
    # 使用币种属性生成量子态
    seed = hashlib.sha256(f"{self.name}:{self.symbol}:{self.creation_time}".encode()).digest()
    random.seed(int.from_bytes(seed, byteorder='big'))
    
    # 创建量子态向量
    dimension = 16
    amplitude_vector = []
    for _ in range(dimension):
      angle = random.uniform(0, 2 * math.pi)
      amplitude_vector.append(complex(math.cos(angle), math.sin(angle)))
    
    # 归一化
    norm = math.sqrt(sum(abs(amp)**2 for amp in amplitude_vector))
    normalized = [amp / norm for amp in amplitude_vector]
    
    return QuantumState(normalized)
  
  @method mint(amount, recipient_id)
    """铸造新的币量
    
    Args:
        amount: 铸造数量
        recipient_id: 接收者ID
        
    Returns:
        bool: 铸造是否成功
    """
    if amount <= 0:
      logger.error(f"铸造数量必须为正数: {amount}")
      return False
    
    if self.circulating_supply + amount > self.total_supply:
      logger.error(f"超出总供应量: 当前 {self.circulating_supply}, 请求 {amount}, 总量 {self.total_supply}")
      return False
    
    # 更新持有者余额
    if recipient_id in self.holders:
      self.holders[recipient_id] += amount
    else:
      self.holders[recipient_id] = amount
    
    # 更新流通量
    self.circulating_supply += amount
    
    logger.info(f"铸造 {amount} {self.symbol} 给 {recipient_id}, 流通量: {self.circulating_supply}")
    return True
  
  @method burn(amount, sender_id)
    """销毁币量
    
    Args:
        amount: 销毁数量
        sender_id: 发送者ID
        
    Returns:
        bool: 销毁是否成功
    """
    if amount <= 0:
      logger.error(f"销毁数量必须为正数: {amount}")
      return False
    
    if sender_id not in self.holders or self.holders[sender_id] < amount:
      logger.error(f"持有者 {sender_id} 余额不足: 拥有 {self.holders.get(sender_id, 0)}, 请求 {amount}")
      return False
    
    # 更新持有者余额
    self.holders[sender_id] -= amount
    if self.holders[sender_id] == 0:
      del self.holders[sender_id]
    
    # 更新流通量
    self.circulating_supply -= amount
    
    logger.info(f"销毁 {amount} {self.symbol} 从 {sender_id}, 流通量: {self.circulating_supply}")
    return True
  
  @method update_price(new_price, timestamp=None)
    """更新币价
    
    Args:
        new_price: 新价格
        timestamp: 时间戳，默认为当前时间
    """
    if new_price <= 0:
      logger.error(f"价格必须为正数: {new_price}")
      return
    
    if not timestamp:
      timestamp = datetime.datetime.now().isoformat()
    
    self.price_history.append({
      'price': new_price,
      'timestamp': timestamp
    })
    
    # 保持历史记录在指定长度内
    if len(self.price_history) > PRICE_HISTORY_LENGTH:
      self.price_history = self.price_history[-PRICE_HISTORY_LENGTH:]
    
    self.last_price = new_price
    
    logger.info(f"{self.symbol} 价格更新: {new_price}")
  
  @method get_price_trend(window=10)
    """获取价格趋势
    
    Args:
        window: 计算趋势的窗口大小
        
    Returns:
        float: 价格趋势指标，正值为上涨趋势，负值为下跌趋势
    """
    if len(self.price_history) < 2:
      return 0.0
    
    # 取最近的window个价格记录
    recent_prices = [entry['price'] for entry in self.price_history[-window:]]
    
    if len(recent_prices) < 2:
      return 0.0
    
    # 计算简单趋势指标
    first_price = recent_prices[0]
    last_price = recent_prices[-1]
    
    return (last_price - first_price) / first_price
  
  @method to_dict()
    """转换为字典格式
    
    Returns:
        dict: 字典表示
    """
    return {
      'id': self.id,
      'name': self.name,
      'symbol': self.symbol,
      'total_supply': self.total_supply,
      'circulating_supply': self.circulating_supply,
      'creator': self.creator,
      'creation_time': self.creation_time,
      'properties': self.properties,
      'holders_count': len(self.holders),
      'last_price': self.last_price,
      'price_trend': self.get_price_trend()
    }
  
  @classmethod
  @method from_dict(cls, data)
    """从字典创建币种
    
    Args:
        data: 币种数据字典
        
    Returns:
        Coin: 币种实例
    """
    coin = cls(
      name=data['name'],
      symbol=data['symbol'],
      initial_supply=data['total_supply'],
      creator=data['creator'],
      properties=data.get('properties', {})
    )
    
    coin.id = data['id']
    coin.circulating_supply = data['circulating_supply']
    coin.creation_time = data['creation_time']
    coin.holders = data.get('holders', {})
    coin.price_history = data.get('price_history', [])
    coin.last_price = data.get('last_price', 1.0)
    
    return coin

@class Wallet
  @constructor(owner_id, name=None)
    """初始化钱包
    
    Args:
        owner_id: 所有者ID
        name: 钱包名称
    """
    self.id = str(uuid.uuid4())
    self.owner_id = owner_id
    self.name = name or f"钱包-{self.id[:8]}"
    self.creation_time = datetime.datetime.now().isoformat()
    self.balances = {}  # 币种ID -> 余额
    self.key_pair = QuantumKeyPair.generate()
    self.public_key = self.key_pair.public_key
    self.transaction_history = []
    
    logger.info(f"创建钱包: {self.name}, 所有者: {self.owner_id}")
  
  @method add_funds(coin_id, amount)
    """添加资金
    
    Args:
        coin_id: 币种ID
        amount: 数量
        
    Returns:
        bool: 是否成功
    """
    if amount <= 0:
      logger.error(f"添加金额必须为正数: {amount}")
      return False
    
    if coin_id in self.balances:
      self.balances[coin_id] += amount
    else:
      self.balances[coin_id] = amount
    
    logger.info(f"向钱包 {self.id} 添加 {amount} 个币 {coin_id}")
    return True
  
  @method remove_funds(coin_id, amount)
    """移除资金
    
    Args:
        coin_id: 币种ID
        amount: 数量
        
    Returns:
        bool: 是否成功
    """
    if amount <= 0:
      logger.error(f"移除金额必须为正数: {amount}")
      return False
    
    if coin_id not in self.balances or self.balances[coin_id] < amount:
      logger.error(f"钱包 {self.id} 余额不足: 拥有 {self.balances.get(coin_id, 0)}, 请求 {amount}")
      return False
    
    self.balances[coin_id] -= amount
    if self.balances[coin_id] == 0:
      del self.balances[coin_id]
    
    logger.info(f"从钱包 {self.id} 移除 {amount} 个币 {coin_id}")
    return True
  
  @method get_balance(coin_id)
    """获取指定币种的余额
    
    Args:
        coin_id: 币种ID
        
    Returns:
        float: 余额
    """
    return self.balances.get(coin_id, 0)
  
  @method add_transaction(transaction)
    """添加交易记录
    
    Args:
        transaction: 交易实例或ID
    """
    if hasattr(transaction, 'id'):
      tx_id = transaction.id
    else:
      tx_id = transaction
    
    self.transaction_history.append(tx_id)
    logger.debug(f"钱包 {self.id} 添加交易记录: {tx_id}")
  
  @method sign_message(message)
    """使用钱包私钥签名消息
    
    Args:
        message: 消息文本
        
    Returns:
        str: 量子签名
    """
    return self.key_pair.sign(message)
  
  @method verify_signature(message, signature, public_key=None)
    """验证签名
    
    Args:
        message: 消息文本
        signature: 签名
        public_key: 公钥，默认使用钱包的公钥
        
    Returns:
        bool: 签名是否有效
    """
    key = public_key or self.public_key
    return QuantumSignature.verify(message, signature, key)
  
  @method to_dict()
    """转换为字典格式
    
    Returns:
        dict: 字典表示
    """
    return {
      'id': self.id,
      'owner_id': self.owner_id,
      'name': self.name,
      'creation_time': self.creation_time,
      'balances': self.balances,
      'public_key': self.public_key,
      'transaction_count': len(self.transaction_history)
    }
  
  @classmethod
  @method from_dict(cls, data)
    """从字典创建钱包
    
    Args:
        data: 钱包数据字典
        
    Returns:
        Wallet: 钱包实例
    """
    wallet = cls(
      owner_id=data['owner_id'],
      name=data['name']
    )
    
    wallet.id = data['id']
    wallet.creation_time = data['creation_time']
    wallet.balances = data['balances']
    wallet.public_key = data['public_key']
    wallet.transaction_history = data.get('transaction_history', [])
    
    # 注意：从字典恢复的钱包没有私钥，需要单独处理
    
    return wallet

@class Transaction
  @constructor(sender_wallet, recipient_wallet, coin_id, amount, fee=None, message=None)
    """初始化交易
    
    Args:
        sender_wallet: 发送者钱包
        recipient_wallet: 接收者钱包
        coin_id: 币种ID
        amount: 数量
        fee: 手续费，默认为0
        message: 附带消息
    """
    self.id = str(uuid.uuid4())
    self.sender_id = sender_wallet.id
    self.recipient_id = recipient_wallet.id
    self.coin_id = coin_id
    self.amount = amount
    self.fee = fee or 0
    self.message = message
    self.timestamp = datetime.datetime.now().isoformat()
    self.status = 'pending'  # pending, confirmed, failed
    self.hash = self._compute_hash()
    self.signature = None
    
    logger.info(f"创建交易: 从 {self.sender_id} 到 {self.recipient_id}, 金额: {amount}, 币种: {coin_id}")
  
  @method _compute_hash()
    """计算交易哈希
    
    Returns:
        str: 交易哈希
    """
    tx_data = f"{self.sender_id}:{self.recipient_id}:{self.coin_id}:{self.amount}:{self.fee}:{self.timestamp}"
    return QuantumHash.hash(tx_data)
  
  @method sign(wallet)
    """用钱包签名交易
    
    Args:
        wallet: 钱包实例
        
    Returns:
        bool: 签名是否成功
    """
    if wallet.id != self.sender_id:
      logger.error(f"签名错误: 钱包ID {wallet.id} 与发送者ID {self.sender_id} 不匹配")
      return False
    
    tx_data = f"{self.sender_id}:{self.recipient_id}:{self.coin_id}:{self.amount}:{self.fee}:{self.timestamp}"
    self.signature = wallet.sign_message(tx_data)
    
    logger.debug(f"交易 {self.id} 已签名")
    return True
  
  @method verify()
    """验证交易签名
    
    Returns:
        bool: 签名是否有效
    """
    if not self.signature:
      logger.error(f"交易 {self.id} 未签名")
      return False
    
    tx_data = f"{self.sender_id}:{self.recipient_id}:{self.coin_id}:{self.amount}:{self.fee}:{self.timestamp}"
    result = QuantumSignature.verify(tx_data, self.signature)
    
    if not result:
      logger.error(f"交易 {self.id} 签名验证失败")
    
    return result
  
  @method execute(som_model)
    """执行交易
    
    Args:
        som_model: 自组织市场模型实例
        
    Returns:
        bool: 执行是否成功
    """
    if self.status != 'pending':
      logger.error(f"交易 {self.id} 已处理，状态: {self.status}")
      return False
    
    if not self.verify():
      self.status = 'failed'
      logger.error(f"交易 {self.id} 验证失败")
      return False
    
    # 获取钱包
    sender_wallet = som_model.get_wallet(self.sender_id)
    recipient_wallet = som_model.get_wallet(self.recipient_id)
    
    if not sender_wallet or not recipient_wallet:
      self.status = 'failed'
      logger.error(f"交易 {self.id} 失败: 钱包不存在")
      return False
    
    # 检查余额
    total_amount = self.amount + self.fee
    if sender_wallet.get_balance(self.coin_id) < total_amount:
      self.status = 'failed'
      logger.error(f"交易 {self.id} 失败: 余额不足")
      return False
    
    # 执行转账
    if not sender_wallet.remove_funds(self.coin_id, total_amount):
      self.status = 'failed'
      logger.error(f"交易 {self.id} 失败: 无法从发送者钱包扣款")
      return False
    
    if not recipient_wallet.add_funds(self.coin_id, self.amount):
      # 转账失败，退还资金
      sender_wallet.add_funds(self.coin_id, total_amount)
      self.status = 'failed'
      logger.error(f"交易 {self.id} 失败: 无法向接收者钱包添加资金")
      return False
    
    # 处理手续费
    if self.fee > 0:
      fee_wallet = som_model.get_fee_wallet()
      if fee_wallet:
        fee_wallet.add_funds(self.coin_id, self.fee)
    
    # 更新交易记录
    sender_wallet.add_transaction(self)
    recipient_wallet.add_transaction(self)
    
    self.status = 'confirmed'
    logger.info(f"交易 {self.id} 成功执行")
    return True
  
  @method to_dict()
    """转换为字典格式
    
    Returns:
        dict: 字典表示
    """
    return {
      'id': self.id,
      'sender_id': self.sender_id,
      'recipient_id': self.recipient_id,
      'coin_id': self.coin_id,
      'amount': self.amount,
      'fee': self.fee,
      'message': self.message,
      'timestamp': self.timestamp,
      'status': self.status,
      'hash': self.hash
    }
  
  @classmethod
  @method from_dict(cls, data, sender_wallet, recipient_wallet)
    """从字典创建交易
    
    Args:
        data: 交易数据字典
        sender_wallet: 发送者钱包
        recipient_wallet: 接收者钱包
        
    Returns:
        Transaction: 交易实例
    """
    tx = cls(
      sender_wallet=sender_wallet,
      recipient_wallet=recipient_wallet,
      coin_id=data['coin_id'],
      amount=data['amount'],
      fee=data['fee'],
      message=data.get('message')
    )
    
    tx.id = data['id']
    tx.timestamp = data['timestamp']
    tx.status = data['status']
    tx.hash = data['hash']
    
    return tx

@class Market
  @constructor(name, base_coin_id, quote_coin_id, creator_id=None)
    """初始化市场
    
    Args:
        name: 市场名称
        base_coin_id: 基础币种ID
        quote_coin_id: 报价币种ID
        creator_id: 创建者ID
    """
    self.id = str(uuid.uuid4())
    self.name = name
    self.base_coin_id = base_coin_id
    self.quote_coin_id = quote_coin_id
    self.creator_id = creator_id
    self.creation_time = datetime.datetime.now().isoformat()
    self.orders = {
      'buy': [],  # 买单列表
      'sell': []  # 卖单列表
    }
    self.transaction_history = []
    self.last_price = None
    self.price_history = []
    self.liquidity = 0
    self.status = 'active'  # active, paused, closed
    self.quantum_state = None
    
    logger.info(f"创建市场: {self.name}, 交易对: {base_coin_id}/{quote_coin_id}")
  
  @method add_order(order)
    """添加订单
    
    Args:
        order: 订单实例
        
    Returns:
        bool: 是否成功
    """
    if order.order_type not in ['buy', 'sell']:
      logger.error(f"无效的订单类型: {order.order_type}")
      return False
    
    self.orders[order.order_type].append(order)
    logger.info(f"市场 {self.id} 添加 {order.order_type} 订单: {order.id}")
    
    # 按价格排序，买单降序，卖单升序
    if order.order_type == 'buy':
      self.orders['buy'].sort(key=lambda o: o.price, reverse=True)
    else:
      self.orders['sell'].sort(key=lambda o: o.price)
    
    return True
  
  @method remove_order(order_id)
    """移除订单
    
    Args:
        order_id: 订单ID
        
    Returns:
        bool: 是否成功
    """
    for order_type in ['buy', 'sell']:
      for i, order in enumerate(self.orders[order_type]):
        if order.id == order_id:
          self.orders[order_type].pop(i)
          logger.info(f"市场 {self.id} 移除 {order_type} 订单: {order_id}")
          return True
    
    logger.warning(f"市场 {self.id} 未找到订单: {order_id}")
    return False
  
  @method get_order(order_id)
    """获取订单
    
    Args:
        order_id: 订单ID
        
    Returns:
        Order or None: 订单实例
    """
    for order_type in ['buy', 'sell']:
      for order in self.orders[order_type]:
        if order.id == order_id:
          return order
    
    return None
  
  @method get_order_book()
    """获取订单簿
    
    Returns:
        dict: 订单簿
    """
    return {
      'buy': [order.to_dict() for order in self.orders['buy']],
      'sell': [order.to_dict() for order in self.orders['sell']]
    }
  
  @method match_orders()
    """匹配订单
    
    Returns:
        list: 成交的订单对列表
    """
    matches = []
    
    # 如果买单或卖单为空，无法匹配
    if not self.orders['buy'] or not self.orders['sell']:
      return matches
    
    # 检查最高买价和最低卖价
    highest_buy = self.orders['buy'][0]
    lowest_sell = self.orders['sell'][0]
    
    # 当最高买价 >= 最低卖价时，可以撮合交易
    while (self.orders['buy'] and self.orders['sell'] and 
           self.orders['buy'][0].price >= self.orders['sell'][0].price):
      buy_order = self.orders['buy'][0]
      sell_order = self.orders['sell'][0]
      
      # 确定成交量和价格
      trade_amount = min(buy_order.amount, sell_order.amount)
      trade_price = (buy_order.price + sell_order.price) / 2
      
      # 更新订单量
      buy_order.amount -= trade_amount
      sell_order.amount -= trade_amount
      
      # 创建匹配记录
      match = {
        'buy_order_id': buy_order.id,
        'sell_order_id': sell_order.id,
        'amount': trade_amount,
        'price': trade_price,
        'timestamp': datetime.datetime.now().isoformat()
      }
      matches.append(match)
      
      # 更新市场状态
      self.last_price = trade_price
      self.price_history.append({
        'price': trade_price,
        'amount': trade_amount,
        'timestamp': match['timestamp']
      })
      self.transaction_history.append(match)
      
      # 移除已完成订单
      if buy_order.amount == 0:
        self.orders['buy'].pop(0)
      if sell_order.amount == 0:
        self.orders['sell'].pop(0)
      
      # 更新流动性
      self.update_liquidity()
      
      logger.info(f"市场 {self.id} 成交: 买单 {buy_order.id}, 卖单 {sell_order.id}, 数量 {trade_amount}, 价格 {trade_price}")
    
    return matches
  
  @method update_liquidity()
    """更新市场流动性
    
    Returns:
        float: 新的流动性值
    """
    buy_volume = sum(order.amount * order.price for order in self.orders['buy'])
    sell_volume = sum(order.amount * order.price for order in self.orders['sell'])
    
    self.liquidity = buy_volume + sell_volume
    return self.liquidity
  
  @method get_price_range()
    """获取价格范围
    
    Returns:
        tuple: (最低价, 最高价)
    """
    prices = [entry['price'] for entry in self.price_history]
    if not prices:
      return (None, None)
    
    return (min(prices), max(prices))
  
  @method get_volume(hours=24)
    """获取交易量
    
    Args:
        hours: 时间范围（小时）
        
    Returns:
        float: 交易量
    """
    if not self.transaction_history:
      return 0
    
    now = datetime.datetime.now()
    cutoff_time = (now - datetime.timedelta(hours=hours)).isoformat()
    
    recent_transactions = [tx for tx in self.transaction_history if tx['timestamp'] >= cutoff_time]
    volume = sum(tx['amount'] * tx['price'] for tx in recent_transactions)
    
    return volume
  
  @method pause()
    """暂停市场"""
    self.status = 'paused'
    logger.info(f"市场 {self.id} 已暂停")
  
  @method resume()
    """恢复市场"""
    self.status = 'active'
    logger.info(f"市场 {self.id} 已恢复")
  
  @method close()
    """关闭市场"""
    self.status = 'closed'
    logger.info(f"市场 {self.id} 已关闭")
  
  @method to_dict()
    """转换为字典格式
    
    Returns:
        dict: 字典表示
    """
    return {
      'id': self.id,
      'name': self.name,
      'base_coin_id': self.base_coin_id,
      'quote_coin_id': self.quote_coin_id,
      'creator_id': self.creator_id,
      'creation_time': self.creation_time,
      'last_price': self.last_price,
      'liquidity': self.liquidity,
      'status': self.status,
      'buy_orders_count': len(self.orders['buy']),
      'sell_orders_count': len(self.orders['sell']),
      'transaction_count': len(self.transaction_history),
      '24h_volume': self.get_volume(24)
    }
  
  @classmethod
  @method from_dict(cls, data)
    """从字典创建市场
    
    Args:
        data: 市场数据字典
        
    Returns:
        Market: 市场实例
    """
    market = cls(
      name=data['name'],
      base_coin_id=data['base_coin_id'],
      quote_coin_id=data['quote_coin_id'],
      creator_id=data['creator_id']
    )
    
    market.id = data['id']
    market.creation_time = data['creation_time']
    market.last_price = data['last_price']
    market.liquidity = data['liquidity']
    market.status = data['status']
    market.price_history = data.get('price_history', [])
    market.transaction_history = data.get('transaction_history', [])
    
    return market

@class Order
  @constructor(market_id, wallet_id, order_type, amount, price, expiry=None)
    """初始化订单
    
    Args:
        market_id: 市场ID
        wallet_id: 钱包ID
        order_type: 订单类型 (buy/sell)
        amount: 数量
        price: 价格
        expiry: 过期时间
    """
    self.id = str(uuid.uuid4())
    self.market_id = market_id
    self.wallet_id = wallet_id
    self.order_type = order_type
    self.amount = amount
    self.price = price
    self.original_amount = amount
    self.creation_time = datetime.datetime.now().isoformat()
    self.expiry = expiry
    self.status = 'open'  # open, partial, filled, canceled, expired
    
    logger.info(f"创建订单: 市场 {market_id}, 类型 {order_type}, 数量 {amount}, 价格 {price}")
  
  @method is_expired()
    """检查订单是否过期
    
    Returns:
        bool: 是否过期
    """
    if not self.expiry:
      return False
    
    now = datetime.datetime.now().isoformat()
    return now > self.expiry
  
  @method update_status()
    """更新订单状态"""
    if self.is_expired() and self.status in ['open', 'partial']:
      self.status = 'expired'
      logger.info(f"订单 {self.id} 已过期")
    elif self.amount == 0:
      self.status = 'filled'
      logger.info(f"订单 {self.id} 已完全成交")
    elif self.amount < self.original_amount:
      self.status = 'partial'
      logger.info(f"订单 {self.id} 部分成交: {self.original_amount - self.amount}/{self.original_amount}")
  
  @method cancel()
    """取消订单
    
    Returns:
        bool: 是否成功
    """
    if self.status in ['filled', 'canceled', 'expired']:
      logger.warning(f"无法取消订单 {self.id}, 当前状态: {self.status}")
      return False
    
    self.status = 'canceled'
    logger.info(f"订单 {self.id} 已取消")
    return True
  
  @method to_dict()
    """转换为字典格式
    
    Returns:
        dict: 字典表示
    """
    return {
      'id': self.id,
      'market_id': self.market_id,
      'wallet_id': self.wallet_id,
      'order_type': self.order_type,
      'amount': self.amount,
      'original_amount': self.original_amount,
      'price': self.price,
      'creation_time': self.creation_time,
      'expiry': self.expiry,
      'status': self.status
    }
  
  @classmethod
  @method from_dict(cls, data)
    """从字典创建订单
    
    Args:
        data: 订单数据字典
        
    Returns:
        Order: 订单实例
    """
    order = cls(
      market_id=data['market_id'],
      wallet_id=data['wallet_id'],
      order_type=data['order_type'],
      amount=data['amount'],
      price=data['price'],
      expiry=data.get('expiry')
    )
    
    order.id = data['id']
    order.original_amount = data['original_amount']
    order.creation_time = data['creation_time']
    order.status = data['status']
    
    return order

@class Contract
  @constructor(name, creator_id, code, parameters=None, description=None)
    """初始化智能合约
    
    Args:
        name: 合约名称
        creator_id: 创建者ID
        code: 合约代码
        parameters: 合约参数字典
        description: 合约描述
    """
    self.id = str(uuid.uuid4())
    self.name = name
    self.creator_id = creator_id
    self.code = code
    self.parameters = parameters or {}
    self.description = description
    self.creation_time = datetime.datetime.now().isoformat()
    self.last_execution = None
    self.execution_count = 0
    self.status = 'active'  # active, paused, expired
    self.quantum_state = self._create_quantum_state()
    
    logger.info(f"创建合约: {self.name}, 创建者: {self.creator_id}")
  
  @method _create_quantum_state()
    """创建合约的量子态
    
    Returns:
        QuantumState: 合约的量子态
    """
    # 使用合约属性生成量子态
    seed = hashlib.sha256(f"{self.name}:{self.creator_id}:{self.creation_time}".encode()).digest()
    random.seed(int.from_bytes(seed, byteorder='big'))
    
    # 创建量子态向量
    dimension = 8
    amplitude_vector = []
    for _ in range(dimension):
      angle = random.uniform(0, 2 * math.pi)
      amplitude_vector.append(complex(math.cos(angle), math.sin(angle)))
    
    # 归一化
    norm = math.sqrt(sum(abs(amp)**2 for amp in amplitude_vector))
    normalized = [amp / norm for amp in amplitude_vector]
    
    return QuantumState(normalized)
  
  @method execute(context=None, max_execution_time=MAX_CONTRACT_EXECUTION_TIME)
    """执行合约
    
    Args:
        context: 执行上下文
        max_execution_time: 最大执行时间（秒）
        
    Returns:
        dict: 执行结果
    """
    if self.status != 'active':
      logger.error(f"合约 {self.id} 当前状态不可执行: {self.status}")
      return {
        'success': False,
        'error': f"合约状态为 {self.status}，不可执行"
      }
    
    context = context or {}
    context.update(self.parameters)
    
    try:
      # 记录开始时间
      start_time = time.time()
      
      # 创建安全的执行环境
      safe_globals = {
        'math': math,
        'random': random,
        'time': time,
        'np': np,
        'context': context,
        'quantum_state': self.quantum_state,
        'logger': logging.getLogger(f'Contract-{self.id}')
      }
      
      # 创建本地环境
      local_vars = {}
      
      # 编译代码
      compiled_code = compile(self.code, f'contract-{self.id}', 'exec')
      
      # 执行代码
      exec(compiled_code, safe_globals, local_vars)
      
      # 获取结果
      result = local_vars.get('result', None)
      
      # 检查执行时间
      execution_time = time.time() - start_time
      if execution_time > max_execution_time:
        logger.warning(f"合约 {self.id} 执行时间过长: {execution_time:.2f} 秒")
      
      # 更新执行记录
      self.last_execution = datetime.datetime.now().isoformat()
      self.execution_count += 1
      
      logger.info(f"合约 {self.id} 执行成功，耗时: {execution_time:.2f} 秒")
      
      return {
        'success': True,
        'result': result,
        'execution_time': execution_time
      }
    
    except Exception as e:
      logger.error(f"合约 {self.id} 执行失败: {str(e)}")
      return {
        'success': False,
        'error': str(e)
      }
  
  @method update_code(new_code)
    """更新合约代码
    
    Args:
        new_code: 新的合约代码
        
    Returns:
        bool: 是否成功
    """
    self.code = new_code
    logger.info(f"合约 {self.id} 代码已更新")
    return True
  
  @method update_parameters(new_parameters)
    """更新合约参数
    
    Args:
        new_parameters: 新的合约参数
        
    Returns:
        bool: 是否成功
    """
    self.parameters.update(new_parameters)
    logger.info(f"合约 {self.id} 参数已更新")
    return True
  
  @method pause()
    """暂停合约"""
    self.status = 'paused'
    logger.info(f"合约 {self.id} 已暂停")
  
  @method resume()
    """恢复合约"""
    self.status = 'active'
    logger.info(f"合约 {self.id} 已恢复")
  
  @method expire()
    """使合约过期"""
    self.status = 'expired'
    logger.info(f"合约 {self.id} 已过期")
  
  @method to_dict()
    """转换为字典格式
    
    Returns:
        dict: 字典表示
    """
    return {
      'id': self.id,
      'name': self.name,
      'creator_id': self.creator_id,
      'code': self.code,
      'parameters': self.parameters,
      'description': self.description,
      'creation_time': self.creation_time,
      'last_execution': self.last_execution,
      'execution_count': self.execution_count,
      'status': self.status
    }
  
  @classmethod
  @method from_dict(cls, data)
    """从字典创建合约
    
    Args:
        data: 合约数据字典
        
    Returns:
        Contract: 合约实例
    """
    contract = cls(
      name=data['name'],
      creator_id=data['creator_id'],
      code=data['code'],
      parameters=data['parameters'],
      description=data['description']
    )
    
    contract.id = data['id']
    contract.creation_time = data['creation_time']
    contract.last_execution = data['last_execution']
    contract.execution_count = data['execution_count']
    contract.status = data['status']
    
    return contract

@class SelfOrganizingMarket
  @constructor()
    """初始化自组织市场模型"""
    self.id = str(uuid.uuid4())
    self.coins = {}  # coin_id -> Coin
    self.wallets = {}  # wallet_id -> Wallet
    self.markets = {}  # market_id -> Market
    self.contracts = {}  # contract_id -> Contract
    self.transactions = {}  # transaction_id -> Transaction
    self.quantum_state = self._create_quantum_state()
    self.fee_wallet_id = None
    self.creation_time = datetime.datetime.now().isoformat()
    self.last_update_time = self.creation_time
    
    # 创建系统费用钱包
    self._create_fee_wallet()
    
    logger.info(f"初始化自组织市场模型, ID: {self.id}")
  
  @method _create_quantum_state()
    """创建模型的量子态
    
    Returns:
        QuantumState: 模型的量子态
    """
    # 使用模型属性生成量子态
    seed = hashlib.sha256(f"SOM:{self.id}:{datetime.datetime.now().isoformat()}".encode()).digest()
    random.seed(int.from_bytes(seed, byteorder='big'))
    
    # 创建量子态向量
    dimension = 32
    amplitude_vector = []
    for _ in range(dimension):
      angle = random.uniform(0, 2 * math.pi)
      amplitude_vector.append(complex(math.cos(angle), math.sin(angle)))
    
    # 归一化
    norm = math.sqrt(sum(abs(amp)**2 for amp in amplitude_vector))
    normalized = [amp / norm for amp in amplitude_vector]
    
    return QuantumState(normalized)
  
  @method _create_fee_wallet()
    """创建系统费用钱包"""
    fee_wallet = Wallet('system_fee')
    self.fee_wallet_id = fee_wallet.id
    self.wallets[fee_wallet.id] = fee_wallet
    logger.info(f"创建系统费用钱包: {fee_wallet.id}")
  
  @method create_coin(name, symbol, initial_supply=DEFAULT_SUPPLY, creator=None, properties=None)
    """创建新币种
    
    Args:
        name: 币种名称
        symbol: 币种符号
        initial_supply: 初始供应量
        creator: 创建者ID
        properties: 币种属性
        
    Returns:
        Coin: 币种实例
    """
    coin = Coin(name, symbol, initial_supply, creator, properties)
    self.coins[coin.id] = coin
    logger.info(f"创建币种: {coin.name} ({coin.symbol}), ID: {coin.id}")
    return coin
  
  @method get_coin(coin_id)
    """获取币种
    
    Args:
        coin_id: 币种ID
        
    Returns:
        Coin or None: 币种实例
    """
    return self.coins.get(coin_id)
  
  @method create_wallet(owner_id, name=None)
    """创建新钱包
    
    Args:
        owner_id: 所有者ID
        name: 钱包名称
        
    Returns:
        Wallet: 钱包实例
    """
    wallet = Wallet(owner_id, name)
    self.wallets[wallet.id] = wallet
    logger.info(f"创建钱包: {wallet.name}, ID: {wallet.id}")
    return wallet
  
  @method get_wallet(wallet_id)
    """获取钱包
    
    Args:
        wallet_id: 钱包ID
        
    Returns:
        Wallet or None: 钱包实例
    """
    return self.wallets.get(wallet_id)
  
  @method get_fee_wallet()
    """获取系统费用钱包
    
    Returns:
        Wallet: 系统费用钱包
    """
    return self.wallets.get(self.fee_wallet_id)
  
  @method create_market(name, base_coin_id, quote_coin_id, creator_id=None)
    """创建新市场
    
    Args:
        name: 市场名称
        base_coin_id: 基础币种ID
        quote_coin_id: 报价币种ID
        creator_id: 创建者ID
        
    Returns:
        Market: 市场实例
    """
    # 检查币种是否存在
    if base_coin_id not in self.coins:
      logger.error(f"创建市场失败: 基础币种 {base_coin_id} 不存在")
      return None
    
    if quote_coin_id not in self.coins:
      logger.error(f"创建市场失败: 报价币种 {quote_coin_id} 不存在")
      return None
    
    market = Market(name, base_coin_id, quote_coin_id, creator_id)
    self.markets[market.id] = market
    logger.info(f"创建市场: {market.name}, ID: {market.id}")
    return market
  
  @method get_market(market_id)
    """获取市场
    
    Args:
        market_id: 市场ID
        
    Returns:
        Market or None: 市场实例
    """
    return self.markets.get(market_id)
  
  @method create_contract(name, creator_id, code, parameters=None, description=None)
    """创建新合约
    
    Args:
        name: 合约名称
        creator_id: 创建者ID
        code: 合约代码
        parameters: 合约参数
        description: 合约描述
        
    Returns:
        Contract: 合约实例
    """
    contract = Contract(name, creator_id, code, parameters, description)
    self.contracts[contract.id] = contract
    logger.info(f"创建合约: {contract.name}, ID: {contract.id}")
    return contract
  
  @method get_contract(contract_id)
    """获取合约
    
    Args:
        contract_id: 合约ID
        
    Returns:
        Contract or None: 合约实例
    """
    return self.contracts.get(contract_id)
  
  @method create_transaction(sender_wallet_id, recipient_wallet_id, coin_id, amount, fee=None, message=None)
    """创建新交易
    
    Args:
        sender_wallet_id: 发送者钱包ID
        recipient_wallet_id: 接收者钱包ID
        coin_id: 币种ID
        amount: 数量
        fee: 手续费
        message: 附带消息
        
    Returns:
        Transaction: 交易实例
    """
    # 检查钱包和币种是否存在
    sender_wallet = self.get_wallet(sender_wallet_id)
    if not sender_wallet:
      logger.error(f"创建交易失败: 发送者钱包 {sender_wallet_id} 不存在")
      return None
    
    recipient_wallet = self.get_wallet(recipient_wallet_id)
    if not recipient_wallet:
      logger.error(f"创建交易失败: 接收者钱包 {recipient_wallet_id} 不存在")
      return None
    
    if coin_id not in self.coins:
      logger.error(f"创建交易失败: 币种 {coin_id} 不存在")
      return None
    
    transaction = Transaction(sender_wallet, recipient_wallet, coin_id, amount, fee, message)
    self.transactions[transaction.id] = transaction
    logger.info(f"创建交易: ID: {transaction.id}, 金额: {amount}")
    return transaction
  
  @method get_transaction(transaction_id)
    """获取交易
    
    Args:
        transaction_id: 交易ID
        
    Returns:
        Transaction or None: 交易实例
    """
    return self.transactions.get(transaction_id)
  
  @method execute_transaction(transaction_id)
    """执行交易
    
    Args:
        transaction_id: 交易ID
        
    Returns:
        bool: 是否成功
    """
    transaction = self.get_transaction(transaction_id)
    if not transaction:
      logger.error(f"执行交易失败: 交易 {transaction_id} 不存在")
      return False
    
    return transaction.execute(self)
  
  @method place_order(market_id, wallet_id, order_type, amount, price, expiry=None)
    """下单
    
    Args:
        market_id: 市场ID
        wallet_id: 钱包ID
        order_type: 订单类型 (buy/sell)
        amount: 数量
        price: 价格
        expiry: 过期时间
        
    Returns:
        Order: 订单实例
    """
    # 检查市场和钱包是否存在
    market = self.get_market(market_id)
    if not market:
      logger.error(f"下单失败: 市场 {market_id} 不存在")
      return None
    
    wallet = self.get_wallet(wallet_id)
    if not wallet:
      logger.error(f"下单失败: 钱包 {wallet_id} 不存在")
      return None
    
    # 创建订单
    order = Order(market_id, wallet_id, order_type, amount, price, expiry)
    
    # 添加到市场
    if market.add_order(order):
      logger.info(f"下单成功: ID: {order.id}, 类型: {order_type}, 金额: {amount}, 价格: {price}")
      
      # 匹配订单
      matches = market.match_orders()
      if matches:
        logger.info(f"订单匹配: 市场 {market_id}, 匹配 {len(matches)} 个订单")
      
      return order
    else:
      logger.error(f"下单失败: 无法添加到市场 {market_id}")
      return None
  
  @method cancel_order(market_id, order_id)
    """取消订单
    
    Args:
        market_id: 市场ID
        order_id: 订单ID
        
    Returns:
        bool: 是否成功
    """
    market = self.get_market(market_id)
    if not market:
      logger.error(f"取消订单失败: 市场 {market_id} 不存在")
      return False
    
    order = market.get_order(order_id)
    if not order:
      logger.error(f"取消订单失败: 订单 {order_id} 不存在")
      return False
    
    if order.cancel() and market.remove_order(order_id):
      logger.info(f"取消订单成功: ID: {order_id}")
      return True
    else:
      logger.error(f"取消订单失败: ID: {order_id}")
      return False
  
  @method get_market_stats()
    """获取所有市场统计
    
    Returns:
        dict: 市场统计数据
    """
    stats = {}
    for market_id, market in self.markets.items():
      stats[market_id] = {
        'name': market.name,
        'last_price': market.last_price,
        'liquidity': market.liquidity,
        'volume_24h': market.get_volume(24),
        'price_range': market.get_price_range(),
        'buy_orders': len(market.orders['buy']),
        'sell_orders': len(market.orders['sell'])
      }
    
    return stats
  
  @method get_coin_stats()
    """获取所有币种统计
    
    Returns:
        dict: 币种统计数据
    """
    stats = {}
    for coin_id, coin in self.coins.items():
      stats[coin_id] = {
        'name': coin.name,
        'symbol': coin.symbol,
        'total_supply': coin.total_supply,
        'circulating_supply': coin.circulating_supply,
        'price': coin.last_price,
        'price_trend': coin.get_price_trend()
      }
    
    return stats
  
  @method save_to_file(file_path=None)
    """保存模型到文件
    
    Args:
        file_path: 文件路径，默认为DATA_DIR/som_model.json
        
    Returns:
        bool: 是否成功
    """
    if file_path is None:
      file_path = os.path.join(DATA_DIR, 'som_model.json')
    
    try:
      model_data = {
        'id': self.id,
        'fee_wallet_id': self.fee_wallet_id,
        'creation_time': self.creation_time,
        'last_update_time': datetime.datetime.now().isoformat(),
        'coins': {coin_id: coin.to_dict() for coin_id, coin in self.coins.items()},
        'wallets': {wallet_id: wallet.to_dict() for wallet_id, wallet in self.wallets.items()},
        'markets': {market_id: market.to_dict() for market_id, market in self.markets.items()},
        'contracts': {contract_id: contract.to_dict() for contract_id, contract in self.contracts.items()},
        'transactions': {tx_id: tx.to_dict() for tx_id, tx in self.transactions.items()}
      }
      
      with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(model_data, f, ensure_ascii=False, indent=2)
      
      logger.info(f"模型已保存到文件: {file_path}")
      return True
    
    except Exception as e:
      logger.error(f"保存模型到文件失败: {str(e)}")
      return False
  
  @classmethod
  @method load_from_file(cls, file_path=None)
    """从文件加载模型
    
    Args:
        file_path: 文件路径，默认为DATA_DIR/som_model.json
        
    Returns:
        SelfOrganizingMarket: 模型实例
    """
    if file_path is None:
      file_path = os.path.join(DATA_DIR, 'som_model.json')
    
    try:
      with open(file_path, 'r', encoding='utf-8') as f:
        model_data = json.load(f)
      
      model = cls()
      model.id = model_data['id']
      model.fee_wallet_id = model_data['fee_wallet_id']
      model.creation_time = model_data['creation_time']
      model.last_update_time = model_data['last_update_time']
      
      # 清空默认创建的钱包和其他对象
      model.coins = {}
      model.wallets = {}
      model.markets = {}
      model.contracts = {}
      model.transactions = {}
      
      # 恢复币种
      for coin_id, coin_data in model_data['coins'].items():
        model.coins[coin_id] = Coin.from_dict(coin_data)
      
      # 恢复钱包
      for wallet_id, wallet_data in model_data['wallets'].items():
        model.wallets[wallet_id] = Wallet.from_dict(wallet_data)
      
      # 恢复市场
      for market_id, market_data in model_data['markets'].items():
        model.markets[market_id] = Market.from_dict(market_data)
      
      # 恢复合约
      for contract_id, contract_data in model_data['contracts'].items():
        model.contracts[contract_id] = Contract.from_dict(contract_data)
      
      # 恢复交易 - 需要获取相应的钱包
      for tx_id, tx_data in model_data['transactions'].items():
        sender_wallet = model.get_wallet(tx_data['sender_id'])
        recipient_wallet = model.get_wallet(tx_data['recipient_id'])
        if sender_wallet and recipient_wallet:
          model.transactions[tx_id] = Transaction.from_dict(tx_data, sender_wallet, recipient_wallet)
      
      logger.info(f"模型已从文件加载: {file_path}")
      return model
    
    except Exception as e:
      logger.error(f"从文件加载模型失败: {str(e)}")
      return None
  
  @method to_dict()
    """转换为字典格式
    
    Returns:
        dict: 字典表示
    """
    return {
      'id': self.id,
      'fee_wallet_id': self.fee_wallet_id,
      'creation_time': self.creation_time,
      'last_update_time': self.last_update_time,
      'coins_count': len(self.coins),
      'wallets_count': len(self.wallets),
      'markets_count': len(self.markets),
      'contracts_count': len(self.contracts),
      'transactions_count': len(self.transactions)
    }

# 用法示例
if __name__ == "__main__":
  # 创建自组织市场模型
  som = SelfOrganizingMarket()
  
  # 创建币种
  quantum_coin = som.create_coin("量子币", "QTC", 1_000_000, "system")
  
  # 创建用户钱包
  alice_wallet = som.create_wallet("alice", "Alice的钱包")
  bob_wallet = som.create_wallet("bob", "Bob的钱包")
  
  # 为钱包铸造一些币
  quantum_coin.mint(10000, alice_wallet.id)
  quantum_coin.mint(5000, bob_wallet.id)
  
  # 创建市场
  qtc_market = som.create_market("QTC/USDC", quantum_coin.id, "usdc_coin_id", "system")
  
  # 发起交易
  tx = som.create_transaction(alice_wallet.id, bob_wallet.id, quantum_coin.id, 100, 1)
  tx.sign(alice_wallet)
  som.execute_transaction(tx.id)
  
  # 下单
  som.place_order(qtc_market.id, alice_wallet.id, "sell", 200, 10)
  som.place_order(qtc_market.id, bob_wallet.id, "buy", 100, 10)
  
  # 保存模型
  som.save_to_file() 