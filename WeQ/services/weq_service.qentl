#!/usr/bin/env qentl
# -*- coding: utf-8 -*-

"""
WeQ服务模块
提供量子情感网络模型的服务层逻辑
"""

# 量子基因编码
QG-SERVICE-WEQ-EMOTION-S1V9

# 量子纠缠信道
@quantum_entangle
  channel_id: QE-SERVICE-WEQ-20240501
  state: ACTIVE
  strength: 0.96
  objects: [
    "WeQ/models/weq_model.qentl",
    "WeQ/api/weq_api.qentl",
    "WeQ/utils/weq_utils.qentl"
  ]

@imports
  standard: [os, json, logging, datetime, time, threading, queue, uuid]
  quantum: [Dict, List, Any, Optional, Union, Callable, Path]
  quantum_asyncio: [asyncio]
  quantum_internal: [
    "../models/weq_model.qentl" as weq_model,
    "../utils/weq_utils.qentl" as weq_utils
  ]

@constants
  ROOT_DIR = Path(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
  LOG_DIR = ROOT_DIR / 'logs'
  MODEL_DIR = ROOT_DIR / 'models'
  CACHE_DIR = ROOT_DIR / 'data' / 'cache'
  
  # 模型缓存有效期（秒）
  MODEL_CACHE_TTL = 3600
  
  # 处理队列大小
  MAX_QUEUE_SIZE = 1000
  
  # 最大并行任务数
  MAX_WORKERS = 4
  
  # 默认分析参数
  DEFAULT_ANALYSIS_PARAMS = {
    'time_window': 24 * 60 * 60,  # 24小时（秒）
    'min_interactions': 3,         # 最少交互次数
    'similarity_threshold': 0.6    # 相似度阈值
  }

@initialization
  # 创建目录
  LOG_DIR.mkdir(exist_ok=True)
  MODEL_DIR.mkdir(exist_ok=True, parents=True)
  CACHE_DIR.mkdir(exist_ok=True, parents=True)
  
  # 配置日志
  logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - [%(levelname)s] - %(message)s',
    handlers=[
      logging.FileHandler(LOG_DIR / f'weq_service_{datetime.datetime.now().strftime("%Y%m%d")}.log'),
      logging.StreamHandler()
    ]
  )
  logger = logging.getLogger('WeQ-SERVICE')
  
  # 初始化服务
  _model_cache = {}         # 模型缓存
  _model_cache_times = {}   # 模型缓存时间戳
  _process_queue = queue.Queue(maxsize=MAX_QUEUE_SIZE)  # 处理队列
  _processing_thread = None   # 处理线程
  _is_processing = False      # 处理标志

@class ModelManager:
  """模型管理器"""

  @staticmethod
  def get_model(model_id: str = "default") -> weq_model.WeQModel:
    """获取模型实例
    
    Args:
        model_id: 模型ID
        
    Returns:
        WeQ模型实例
    """
    current_time = time.time()
    
    # 检查缓存
    if model_id in _model_cache and (current_time - _model_cache_times.get(model_id, 0)) < MODEL_CACHE_TTL:
      logger.debug(f"从缓存获取模型 {model_id}")
      return _model_cache[model_id]
    
    # 尝试加载模型
    model_path = MODEL_DIR / f"{model_id}.qmodel"
    if model_path.exists():
      try:
        logger.info(f"加载模型 {model_id}")
        model = weq_model.WeQModel.load(str(model_path))
        
        # 更新缓存
        _model_cache[model_id] = model
        _model_cache_times[model_id] = current_time
        
        return model
      except Exception as e:
        logger.error(f"加载模型 {model_id} 出错: {str(e)}")
    
    # 创建新模型
    logger.info(f"创建新模型 {model_id}")
    model = weq_model.WeQModel(model_id=model_id)
    
    # 更新缓存
    _model_cache[model_id] = model
    _model_cache_times[model_id] = current_time
    
    return model

  @staticmethod
  def save_model(model: weq_model.WeQModel) -> str:
    """保存模型
    
    Args:
        model: 模型实例
        
    Returns:
        模型保存路径
    """
    model_id = model.model_id
    model_path = MODEL_DIR / f"{model_id}.qmodel"
    
    try:
      # 保存模型
      saved_path = model.save(str(model_path))
      
      # 更新缓存
      _model_cache[model_id] = model
      _model_cache_times[model_id] = time.time()
      
      logger.info(f"模型 {model_id} 已保存: {saved_path}")
      return saved_path
    
    except Exception as e:
      logger.error(f"保存模型 {model_id} 出错: {str(e)}")
      raise

  @staticmethod
  def refresh_model(model_id: str = "default") -> weq_model.WeQModel:
    """刷新模型缓存
    
    Args:
        model_id: 模型ID
        
    Returns:
        刷新后的模型实例
    """
    # 从缓存中移除
    if model_id in _model_cache:
      del _model_cache[model_id]
    if model_id in _model_cache_times:
      del _model_cache_times[model_id]
    
    # 重新加载
    return ModelManager.get_model(model_id)

  @staticmethod
  def list_models() -> List[str]:
    """列出所有模型
    
    Returns:
        模型ID列表
    """
    model_files = list(MODEL_DIR.glob("*.qmodel"))
    return [os.path.splitext(os.path.basename(str(f)))[0] for f in model_files]

  @staticmethod
  def delete_model(model_id: str) -> bool:
    """删除模型
    
    Args:
        model_id: 模型ID
        
    Returns:
        是否成功删除
    """
    model_path = MODEL_DIR / f"{model_id}.qmodel"
    
    try:
      if model_path.exists():
        os.remove(str(model_path))
        
        # 从缓存中移除
        if model_id in _model_cache:
          del _model_cache[model_id]
        if model_id in _model_cache_times:
          del _model_cache_times[model_id]
        
        logger.info(f"模型 {model_id} 已删除")
        return True
      else:
        logger.warning(f"模型 {model_id} 不存在")
        return False
    
    except Exception as e:
      logger.error(f"删除模型 {model_id} 出错: {str(e)}")
      return False

@class MessageProcessor:
  """消息处理器"""

  @staticmethod
  def process_message(
                  message_id: str,
                  sender_id: str,
                  content: str,
                  recipients: List[str],
                  message_type: str = "TEXT",
                  model_id: str = "default") -> Dict[str, Any]:
    """处理消息
    
    Args:
        message_id: 消息ID
        sender_id: 发送者ID
        content: 消息内容
        recipients: 接收者ID列表
        message_type: 消息类型
        model_id: 模型ID
        
    Returns:
        处理结果
    """
    try:
      # 获取模型
      model = ModelManager.get_model(model_id)
      
      # 处理消息
      result = model.process_message(
        message_id=message_id,
        sender_id=sender_id,
        content=content,
        recipients=recipients,
        message_type=message_type
      )
      
      # 保存模型
      ModelManager.save_model(model)
      
      return {
        'status': 'success',
        'message_id': message_id,
        'emotions': result
      }
    
    except Exception as e:
      logger.error(f"处理消息 {message_id} 出错: {str(e)}")
      return {
        'status': 'error',
        'message_id': message_id,
        'error': str(e)
      }

  @staticmethod
  def queue_message(
                message_data: Dict[str, Any]) -> str:
    """将消息加入队列
    
    Args:
        message_data: 消息数据
        
    Returns:
        任务ID
    """
    # 生成任务ID
    task_id = f"task_{uuid.uuid4().hex[:8]}"
    
    # 添加任务ID
    message_data['task_id'] = task_id
    
    try:
      # 加入队列
      _process_queue.put(message_data, block=False)
      logger.info(f"消息已加入队列，任务ID: {task_id}")
      
      # 确保处理线程在运行
      MessageProcessor._ensure_processing_thread()
      
      return task_id
    
    except queue.Full:
      logger.error("处理队列已满")
      raise RuntimeError("处理队列已满，请稍后再试")

  @staticmethod
  def _ensure_processing_thread():
    """确保处理线程在运行"""
    global _processing_thread, _is_processing
    
    if _processing_thread is None or not _processing_thread.is_alive():
      _is_processing = True
      _processing_thread = threading.Thread(target=MessageProcessor._process_queue)
      _processing_thread.daemon = True
      _processing_thread.start()
      logger.info("处理线程已启动")

  @staticmethod
  def _process_queue():
    """处理队列中的消息"""
    global _is_processing
    
    while _is_processing:
      try:
        # 从队列中获取消息
        message_data = _process_queue.get(block=True, timeout=1.0)
        
        # 处理消息
        try:
          MessageProcessor.process_message(
            message_id=message_data.get('message_id', f"msg_{uuid.uuid4().hex[:8]}"),
            sender_id=message_data.get('sender_id', ''),
            content=message_data.get('content', ''),
            recipients=message_data.get('recipients', []),
            message_type=message_data.get('message_type', 'TEXT'),
            model_id=message_data.get('model_id', 'default')
          )
        except Exception as e:
          logger.error(f"处理队列中的消息出错: {str(e)}")
        
        # 标记任务完成
        _process_queue.task_done()
        
      except queue.Empty:
        # 队列为空，继续等待
        pass
      except Exception as e:
        logger.error(f"消息队列处理出错: {str(e)}")
    
    logger.info("处理线程已停止")

  @staticmethod
  def stop_processing():
    """停止处理线程"""
    global _is_processing
    _is_processing = False
    
    if _processing_thread and _processing_thread.is_alive():
      _processing_thread.join(timeout=5.0)
      logger.info("处理线程已停止")

@class EmotionAnalysisService:
  """情感分析服务"""

  @staticmethod
  def analyze_text(text: str) -> Dict[str, float]:
    """分析文本情感
    
    Args:
        text: 文本内容
        
    Returns:
        情感分析结果 {emotion_type: intensity}
    """
    return weq_utils.analyze_text_emotion(text)

  @staticmethod
  def extract_emotion_keywords(text: str) -> Dict[str, List[str]]:
    """提取情感关键词
    
    Args:
        text: 文本内容
        
    Returns:
        情感关键词 {emotion_type: [keywords]}
    """
    return weq_utils.extract_emotion_keywords(text)

  @staticmethod
  def find_emotional_matches(
                         user_id: str,
                         num_matches: int = 5,
                         model_id: str = "default") -> List[Dict[str, Any]]:
    """查找情感匹配用户
    
    Args:
        user_id: 用户ID
        num_matches: 匹配数量
        model_id: 模型ID
        
    Returns:
        匹配用户列表
    """
    try:
      # 获取模型
      model = ModelManager.get_model(model_id)
      
      # 查找匹配
      matches = model.find_emotional_matches(user_id, num_matches)
      
      return matches
    
    except Exception as e:
      logger.error(f"查找情感匹配用户出错: {str(e)}")
      raise

  @staticmethod
  def find_emotional_complements(
                             user_id: str,
                             num_matches: int = 5,
                             model_id: str = "default") -> List[Dict[str, Any]]:
    """查找情感互补用户
    
    Args:
        user_id: 用户ID
        num_matches: 匹配数量
        model_id: 模型ID
        
    Returns:
        互补用户列表
    """
    try:
      # 获取模型
      model = ModelManager.get_model(model_id)
      
      # 查找互补
      complements = model.find_emotional_complements(user_id, num_matches)
      
      return complements
    
    except Exception as e:
      logger.error(f"查找情感互补用户出错: {str(e)}")
      raise

  @staticmethod
  def analyze_group_emotion(
                        user_ids: List[str],
                        model_id: str = "default") -> Dict[str, float]:
    """分析群组情感
    
    Args:
        user_ids: 用户ID列表
        model_id: 模型ID
        
    Returns:
        群组情感 {emotion_type: intensity}
    """
    try:
      # 获取模型
      model = ModelManager.get_model(model_id)
      
      # 分析群组情感
      group_emotion = model.analyze_group_emotion(user_ids)
      
      return group_emotion
    
    except Exception as e:
      logger.error(f"分析群组情感出错: {str(e)}")
      raise

  @staticmethod
  def analyze_emotional_trajectory(
                               user_id: str,
                               window_size: int = 10,
                               model_id: str = "default") -> List[Dict[str, Any]]:
    """分析情感轨迹
    
    Args:
        user_id: 用户ID
        window_size: 窗口大小
        model_id: 模型ID
        
    Returns:
        情感轨迹数据
    """
    try:
      # 获取模型
      model = ModelManager.get_model(model_id)
      
      # 分析情感轨迹
      trajectory = model.get_user_emotional_trajectory(user_id, window_size)
      
      return trajectory
    
    except Exception as e:
      logger.error(f"分析情感轨迹出错: {str(e)}")
      raise

@class UserManagementService:
  """用户管理服务"""

  @staticmethod
  def add_user(
           user_id: str,
           initial_emotions: Optional[Dict[str, float]] = None,
           model_id: str = "default") -> Dict[str, Any]:
    """添加用户
    
    Args:
        user_id: 用户ID
        initial_emotions: 初始情感状态
        model_id: 模型ID
        
    Returns:
        用户信息
    """
    try:
      # 获取模型
      model = ModelManager.get_model(model_id)
      
      # 添加用户
      user_info = model.add_user(user_id, initial_emotions)
      
      # 保存模型
      ModelManager.save_model(model)
      
      return user_info
    
    except Exception as e:
      logger.error(f"添加用户 {user_id} 出错: {str(e)}")
      raise

  @staticmethod
  def get_user(
           user_id: str,
           model_id: str = "default") -> Dict[str, Any]:
    """获取用户信息
    
    Args:
        user_id: 用户ID
        model_id: 模型ID
        
    Returns:
        用户信息
    """
    try:
      # 获取模型
      model = ModelManager.get_model(model_id)
      
      # 获取用户
      user_info = model.get_user(user_id)
      
      return user_info
    
    except Exception as e:
      logger.error(f"获取用户 {user_id} 出错: {str(e)}")
      raise

  @staticmethod
  def update_user_emotions(
                       user_id: str,
                       emotions: Dict[str, float],
                       model_id: str = "default") -> Dict[str, Any]:
    """更新用户情感
    
    Args:
        user_id: 用户ID
        emotions: 情感状态
        model_id: 模型ID
        
    Returns:
        更新后的用户信息
    """
    try:
      # 获取模型
      model = ModelManager.get_model(model_id)
      
      # 更新用户情感
      user_info = model.update_user_emotions(user_id, emotions)
      
      # 保存模型
      ModelManager.save_model(model)
      
      return user_info
    
    except Exception as e:
      logger.error(f"更新用户 {user_id} 情感出错: {str(e)}")
      raise

  @staticmethod
  def list_users(model_id: str = "default") -> List[str]:
    """列出所有用户
    
    Args:
        model_id: 模型ID
        
    Returns:
        用户ID列表
    """
    try:
      # 获取模型
      model = ModelManager.get_model(model_id)
      
      # 获取用户列表
      users = model.list_users()
      
      return users
    
    except Exception as e:
      logger.error(f"列出用户出错: {str(e)}")
      raise

  @staticmethod
  def remove_user(
              user_id: str,
              model_id: str = "default") -> bool:
    """移除用户
    
    Args:
        user_id: 用户ID
        model_id: 模型ID
        
    Returns:
        是否成功
    """
    try:
      # 获取模型
      model = ModelManager.get_model(model_id)
      
      # 移除用户
      success = model.remove_user(user_id)
      
      # 保存模型
      if success:
        ModelManager.save_model(model)
      
      return success
    
    except Exception as e:
      logger.error(f"移除用户 {user_id} 出错: {str(e)}")
      raise

@class DataExportService:
  """数据导出服务"""

  @staticmethod
  def export_model_data(model_id: str = "default") -> str:
    """导出模型数据
    
    Args:
        model_id: 模型ID
        
    Returns:
        导出文件路径
    """
    try:
      # 获取模型
      model = ModelManager.get_model(model_id)
      
      # 导出数据
      user_emotions = {}
      for user_id in model.list_users():
        user_info = model.get_user(user_id)
        user_emotions[user_id] = user_info
      
      # 导出交互历史
      interaction_history = model.get_interaction_history()
      
      # 导出
      timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
      export_path = weq_utils.export_emotion_data(
        user_emotions=user_emotions,
        interaction_history=interaction_history,
        filepath=str(CACHE_DIR / f"model_{model_id}_{timestamp}.json")
      )
      
      return export_path
    
    except Exception as e:
      logger.error(f"导出模型 {model_id} 数据出错: {str(e)}")
      raise

  @staticmethod
  def import_model_data(
                    filepath: str,
                    model_id: str = "default") -> bool:
    """导入模型数据
    
    Args:
        filepath: 数据文件路径
        model_id: 模型ID
        
    Returns:
        是否成功
    """
    try:
      # 导入数据
      data = weq_utils.import_emotion_data(filepath)
      
      # 验证数据
      valid, error_msg = weq_utils.validate_emotion_data(data)
      if not valid:
        logger.error(f"数据验证失败: {error_msg}")
        return False
      
      # 创建新模型
      model = weq_model.WeQModel(model_id=model_id)
      
      # 导入用户
      user_emotions = data.get("user_emotions", {})
      for user_id, user_info in user_emotions.items():
        model.add_user(user_id, user_info.get("current_emotions", {}))
      
      # 导入交互历史
      interaction_history = data.get("interaction_history", [])
      
      # 按时间戳排序
      interaction_history.sort(key=lambda x: x.get("timestamp", ""))
      
      # 处理交互
      for interaction in interaction_history:
        try:
          model.process_message(
            message_id=interaction.get("message_id", f"msg_{uuid.uuid4().hex[:8]}"),
            sender_id=interaction.get("sender_id", ""),
            content=interaction.get("content", ""),
            recipients=interaction.get("recipients", []),
            message_type=interaction.get("message_type", "TEXT")
          )
        except Exception as e:
          logger.warning(f"处理交互记录出错: {str(e)}")
      
      # 保存模型
      ModelManager.save_model(model)
      
      return True
    
    except Exception as e:
      logger.error(f"导入模型数据出错: {str(e)}")
      return False

@function initialize() -> None:
  """初始化服务
  
  Returns:
      None
  """
  logger.info("初始化WeQ服务")
  
  # 确保默认模型存在
  try:
    model = ModelManager.get_model("default")
    logger.info(f"默认模型已加载: {model.model_id}")
  except Exception as e:
    logger.error(f"加载默认模型出错: {str(e)}")

@function cleanup() -> None:
  """清理资源
  
  Returns:
      None
  """
  logger.info("清理WeQ服务资源")
  
  # 停止处理线程
  MessageProcessor.stop_processing()
  
  # 保存所有模型
  for model_id in _model_cache:
    try:
      model = _model_cache[model_id]
      ModelManager.save_model(model)
    except Exception as e:
      logger.error(f"保存模型 {model_id} 出错: {str(e)}")

@function generate_test_data(num_users: int = 5, num_messages: int = 20) -> Dict[str, Any]:
  """生成测试数据
  
  Args:
      num_users: 用户数量
      num_messages: 消息数量
      
  Returns:
      测试数据统计
  """
  model_id = "test_model"
  
  try:
    # 创建新模型
    model = weq_model.WeQModel(model_id=model_id)
    
    # 添加用户
    for i in range(num_users):
      user_id = f"user_{i}"
      model.add_user(user_id)
    
    # 生成测试消息
    messages = weq_utils.generate_test_messages(num_messages)
    
    # 处理消息
    model = weq_utils.process_test_messages(model, messages)
    
    # 保存模型
    ModelManager.save_model(model)
    
    return {
      'model_id': model_id,
      'num_users': num_users,
      'num_messages': num_messages,
      'users': model.list_users()
    }
  
  except Exception as e:
    logger.error(f"生成测试数据出错: {str(e)}")
    raise

@entrypoint
def run_service() -> None:
  """运行服务"""
  try:
    # 初始化服务
    initialize()
    
    # 示例：生成测试数据
    test_data = generate_test_data()
    logger.info(f"测试数据已生成: {test_data}")
    
    # 保持服务运行状态
    while True:
      time.sleep(1)
  
  except KeyboardInterrupt:
    logger.info("服务被中断")
  
  finally:
    # 清理资源
    cleanup()

# 如果直接运行该文件
if __name__ == "__main__":
  run_service() 