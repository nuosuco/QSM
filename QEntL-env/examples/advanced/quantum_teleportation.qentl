// ==========================================
// QEntL 量子隐形传态示例
// 展示量子隐形传态的完整流程和细节
// 
// 作者: QEntL核心开发团队
// 日期: 2024-05-18
// 版本: 1.0
// ==========================================

import quantum.core;
import quantum.state;
import quantum.entanglement;
import quantum.teleportation;
import system.io;
import system.math;
import system.visualization;

/**
 * 基本量子隐形传态
 * 传送未知量子态从发送者到接收者
 */
function basic_teleportation() {
    system.io.print("=== 基本量子隐形传态 ===\n");
    
    // 创建三量子比特系统 (0:发送者的源比特, 1-2:共享纠缠对)
    QuantumState state = new QuantumState(3);
    
    // 创建要传送的未知状态 (假设为任意的单量子比特状态)
    float theta = math.PI / 4;
    float phi = math.PI / 3;
    system.io.print("要传送的状态参数: θ=" + theta + ", φ=" + phi);
    
    // 在第0个量子比特上准备未知状态 |ψ⟩ = cos(θ/2)|0⟩ + e^(iφ)sin(θ/2)|1⟩
    state.applyRY(0, theta);
    state.applyRZ(0, phi);
    
    // 打印初始状态
    system.io.print("初始状态 |ψ⟩ (第0个量子比特):");
    system.io.print(state.qubitToString(0));
    
    // 创建Bell对 (第1和第2个量子比特之间) - 这是共享的纠缠资源
    state.applyH(1);
    state.applyCNOT(1, 2);
    
    // 打印初始纠缠对状态
    system.io.print("\nBell对状态 (第1-2个量子比特):");
    system.io.print(state.getReducedDensityMatrix([1, 2]).to_string());
    
    // 打印整个系统状态
    system.io.print("\n传送前完整系统状态:");
    system.io.print(state.to_string());
    
    // --------- 量子隐形传态协议 ---------
    
    // 步骤1: 发送者应用Bell测量 (CNOT + H + 测量)
    state.applyCNOT(0, 1);
    state.applyH(0);
    
    // 步骤2: 测量发送端量子比特
    int m0 = state.measure(0);
    int m1 = state.measure(1);
    
    system.io.print("\n测量结果:");
    system.io.print("- 第0个量子比特测量结果: " + m0);
    system.io.print("- 第1个量子比特测量结果: " + m1);
    
    // 步骤3: 根据测量结果应用修正操作
    if (m1 == 1) {
        state.applyX(2);
    }
    if (m0 == 1) {
        state.applyZ(2);
    }
    
    // 打印接收端最终状态
    system.io.print("\n接收端最终状态 (第2个量子比特):");
    system.io.print(state.qubitToString(2));
    
    // 验证传送是否成功 (生成参考状态用于比较)
    QuantumState reference = new QuantumState(1);
    reference.applyRY(0, theta);
    reference.applyRZ(0, phi);
    
    system.io.print("\n验证传送质量:");
    float fidelity = state.calculateFidelity(2, reference, 0);
    system.io.print("- 保真度: " + fidelity);
    
    if (fidelity > 0.99) {
        system.io.print("- 传送成功! 接收端状态与原始状态匹配");
    } else {
        system.io.print("- 传送有误，接收端状态与原始状态不匹配");
    }
    
    // 生成量子电路图示
    system.visualization.drawTeleportationCircuit([
        { gate: "RY", qubit: 0, params: [theta] },
        { gate: "RZ", qubit: 0, params: [phi] },
        { gate: "H", qubit: 1 },
        { gate: "CNOT", control: 1, target: 2 },
        { gate: "CNOT", control: 0, target: 1 },
        { gate: "H", qubit: 0 },
        { gate: "MEASURE", qubit: 0, result: m0 },
        { gate: "MEASURE", qubit: 1, result: m1 },
        { gate: "X", qubit: 2, condition: { qubit: 1, value: 1 } },
        { gate: "Z", qubit: 2, condition: { qubit: 0, value: 1 } }
    ]);
    
    return state;
}

/**
 * 多量子比特态的隐形传态
 * 传送一个两量子比特系统的状态
 */
function multi_qubit_teleportation() {
    system.io.print("\n=== 多量子比特量子隐形传态 ===\n");
    
    // 创建六量子比特系统 
    // (0-1:要传送的两量子比特状态, 2-3:发送端纠缠对第一部分, 4-5:接收端纠缠对第二部分)
    QuantumState state = new QuantumState(6);
    
    // 准备要传送的两量子比特纠缠态
    system.io.print("准备要传送的两量子比特纠缠态 (第0-1个量子比特)");
    state.applyH(0);
    state.applyCNOT(0, 1);
    state.applyT(1);  // 添加一些相位以创建更复杂的状态
    state.applyRX(0, math.PI/6);
    
    // 打印要传送的状态
    system.io.print("\n要传送的初始状态 (第0-1个量子比特):");
    system.io.print(state.getReducedDensityMatrix([0, 1]).to_string());
    
    // 准备两对Bell对作为传送信道
    system.io.print("\n准备两对Bell对作为传送信道");
    // 第一对Bell对 (2-4)
    state.applyH(2);
    state.applyCNOT(2, 4);
    // 第二对Bell对 (3-5)
    state.applyH(3);
    state.applyCNOT(3, 5);
    
    // 执行第一个量子比特的隐形传态
    system.io.print("\n执行第一个量子比特的隐形传态 (0→4)");
    state.applyCNOT(0, 2);
    state.applyH(0);
    int m0 = state.measure(0);
    int m2 = state.measure(2);
    
    if (m2 == 1) state.applyX(4);
    if (m0 == 1) state.applyZ(4);
    
    // 执行第二个量子比特的隐形传态
    system.io.print("执行第二个量子比特的隐形传态 (1→5)");
    state.applyCNOT(1, 3);
    state.applyH(1);
    int m1 = state.measure(1);
    int m3 = state.measure(3);
    
    if (m3 == 1) state.applyX(5);
    if (m1 == 1) state.applyZ(5);
    
    // 打印测量结果
    system.io.print("\n测量结果:");
    system.io.print("- 第一对: m0=" + m0 + ", m2=" + m2);
    system.io.print("- 第二对: m1=" + m1 + ", m3=" + m3);
    
    // 打印接收端最终状态
    system.io.print("\n接收端最终状态 (第4-5个量子比特):");
    system.io.print(state.getReducedDensityMatrix([4, 5]).to_string());
    
    // 验证传送是否成功 (准备参考态)
    QuantumState reference = new QuantumState(2);
    reference.applyH(0);
    reference.applyCNOT(0, 1);
    reference.applyT(1);
    reference.applyRX(0, math.PI/6);
    
    system.io.print("\n验证传送质量:");
    float fidelity = state.calculateMultiQubitFidelity([4, 5], reference, [0, 1]);
    system.io.print("- 保真度: " + fidelity);
    
    if (fidelity > 0.99) {
        system.io.print("- 多量子比特传送成功!");
    } else {
        system.io.print("- 多量子比特传送有误");
    }
    
    return state;
}

/**
 * 通过噪声信道的量子隐形传态
 * 模拟在有噪声环境下的量子隐形传态
 */
function noisy_teleportation() {
    system.io.print("\n=== 噪声环境下的量子隐形传态 ===\n");
    
    // 创建包含噪声模型的量子状态
    QuantumState state = new QuantumState(3, { 
        noise_model: "depolarizing",
        noise_strength: 0.05  // 5%的噪声强度
    });
    
    // 创建要传送的未知状态 (与基本示例相同)
    float theta = math.PI / 4;
    float phi = math.PI / 3;
    
    // 在第0个量子比特上准备未知状态
    state.applyRY(0, theta);
    state.applyRZ(0, phi);
    
    // 打印初始状态
    system.io.print("初始状态 |ψ⟩ (第0个量子比特):");
    system.io.print(state.qubitToString(0));
    
    // 创建Bell对 (第1和第2个量子比特之间)
    state.applyH(1);
    state.applyCNOT(1, 2);
    
    // 模拟信道噪声影响纠缠对
    system.io.print("\n应用噪声到纠缠信道 (5%去极化噪声)...");
    state.applyNoise([1, 2]);
    
    // 展示受噪声影响的纠缠对
    system.io.print("受噪声影响的Bell对状态:");
    system.io.print(state.getReducedDensityMatrix([1, 2]).to_string());
    
    // 执行量子隐形传态协议
    state.applyCNOT(0, 1);
    state.applyH(0);
    
    int m0 = state.measure(0);
    int m1 = state.measure(1);
    
    system.io.print("\n测量结果:");
    system.io.print("- 第0个量子比特测量结果: " + m0);
    system.io.print("- 第1个量子比特测量结果: " + m1);
    
    if (m1 == 1) state.applyX(2);
    if (m0 == 1) state.applyZ(2);
    
    // 打印接收端最终状态
    system.io.print("\n接收端最终状态 (第2个量子比特):");
    system.io.print(state.qubitToString(2));
    
    // 验证传送是否成功
    QuantumState reference = new QuantumState(1);
    reference.applyRY(0, theta);
    reference.applyRZ(0, phi);
    
    system.io.print("\n验证传送质量:");
    float fidelity = state.calculateFidelity(2, reference, 0);
    system.io.print("- 保真度: " + fidelity);
    
    system.io.print("- 噪声导致的保真度下降: " + (1.0 - fidelity));
    
    // 比较不同噪声水平下的保真度
    system.io.print("\n不同噪声水平下的保真度比较:");
    float[] noise_levels = [0.01, 0.05, 0.1, 0.2];
    float[] fidelities = [];
    
    foreach (level in noise_levels) {
        QuantumState test_state = new QuantumState(3, { 
            noise_model: "depolarizing",
            noise_strength: level
        });
        
        // 准备状态
        test_state.applyRY(0, theta);
        test_state.applyRZ(0, phi);
        test_state.applyH(1);
        test_state.applyCNOT(1, 2);
        test_state.applyNoise([1, 2]);
        
        // 执行传送
        test_state.applyCNOT(0, 1);
        test_state.applyH(0);
        test_state.measure(0);
        test_state.measure(1);
        
        float test_fidelity = test_state.calculateFidelity(2, reference, 0);
        fidelities.push(test_fidelity);
        
        system.io.print("- 噪声水平 " + (level * 100) + "%: 保真度 = " + test_fidelity);
    }
    
    // 绘制噪声vs保真度图表
    system.visualization.plotData("噪声对量子隐形传态保真度的影响", {
        x_data: noise_levels,
        y_data: fidelities,
        x_label: "噪声水平",
        y_label: "保真度",
        title: "噪声水平对量子隐形传态保真度的影响"
    });
    
    return state;
}

/**
 * 使用量子纠错增强的量子隐形传态
 */
function error_corrected_teleportation() {
    system.io.print("\n=== 量子纠错增强的量子隐形传态 ===\n");
    
    // 创建带噪声的量子状态
    QuantumState state = new QuantumState(9, { 
        noise_model: "depolarizing",
        noise_strength: 0.03
    });
    
    // 创建要传送的未知状态
    float theta = math.PI / 4;
    float phi = math.PI / 3;
    
    // 准备要传送的逻辑量子比特 (使用3量子比特编码)
    system.io.print("准备编码的逻辑量子比特...");
    
    // 先在第0个量子比特上准备要传送的状态
    state.applyRY(0, theta);
    state.applyRZ(0, phi);
    
    // 将状态编码为逻辑量子比特 (3量子比特编码)
    // 逻辑0 → |000⟩ + |111⟩, 逻辑1 → |000⟩ - |111⟩
    state.encodeLogicalQubit([0, 1, 2], "BitFlip");
    
    system.io.print("初始逻辑量子比特状态 (第0-2个量子比特):");
    system.io.print(state.getReducedDensityMatrix([0, 1, 2]).to_string());
    
    // 准备编码的Bell对
    system.io.print("\n准备编码的Bell对...");
    // 使用量子比特3-5作为发送端，6-8作为接收端
    state.applyH(3);
    state.applyCNOT(3, 6);
    
    // 对Bell对的每个端都应用3量子比特编码
    state.encodeLogicalQubit([3, 4, 5], "BitFlip");
    state.encodeLogicalQubit([6, 7, 8], "BitFlip");
    
    // 应用噪声到量子系统
    system.io.print("\n应用噪声到量子系统 (3%去极化噪声)...");
    state.applyNoise([0, 1, 2, 3, 4, 5, 6, 7, 8]);
    
    // 执行错误校正
    system.io.print("执行错误校正...");
    state.correctErrors([0, 1, 2], "BitFlip");
    state.correctErrors([3, 4, 5], "BitFlip");
    state.correctErrors([6, 7, 8], "BitFlip");
    
    // 执行量子隐形传态 (使用逻辑量子比特)
    system.io.print("\n在逻辑量子比特层面执行量子隐形传态...");
    state.applyLogicalCNOT([0, 1, 2], [3, 4, 5]);
    state.applyLogicalH([0, 1, 2]);
    
    int[] logical_m0 = state.measureLogicalQubit([0, 1, 2]);
    int[] logical_m1 = state.measureLogicalQubit([3, 4, 5]);
    
    system.io.print("\n逻辑量子比特测量结果:");
    system.io.print("- 第一个逻辑量子比特: " + logical_m0[0]);
    system.io.print("- 第二个逻辑量子比特: " + logical_m1[0]);
    
    // 应用逻辑门修正
    if (logical_m1[0] == 1) {
        state.applyLogicalX([6, 7, 8]);
    }
    if (logical_m0[0] == 1) {
        state.applyLogicalZ([6, 7, 8]);
    }
    
    // 执行最终错误校正
    state.correctErrors([6, 7, 8], "BitFlip");
    
    // 解码接收端的逻辑量子比特
    state.decodeLogicalQubit([6, 7, 8], "BitFlip");
    
    // 打印接收端最终状态
    system.io.print("\n接收端最终状态 (第6个量子比特):");
    system.io.print(state.qubitToString(6));
    
    // 验证传送是否成功
    QuantumState reference = new QuantumState(1);
    reference.applyRY(0, theta);
    reference.applyRZ(0, phi);
    
    system.io.print("\n验证传送质量:");
    float fidelity = state.calculateFidelity(6, reference, 0);
    system.io.print("- 有量子纠错的保真度: " + fidelity);
    
    // 比较有纠错和无纠错的情况
    system.io.print("\n比较有纠错和无纠错情况:");
    
    // 创建无纠错的测试状态
    QuantumState noEC_state = new QuantumState(3, { 
        noise_model: "depolarizing",
        noise_strength: 0.03
    });
    
    // 准备要传送的状态
    noEC_state.applyRY(0, theta);
    noEC_state.applyRZ(0, phi);
    
    // 准备Bell对
    noEC_state.applyH(1);
    noEC_state.applyCNOT(1, 2);
    
    // 应用噪声
    noEC_state.applyNoise([0, 1, 2]);
    
    // 执行传送
    noEC_state.applyCNOT(0, 1);
    noEC_state.applyH(0);
    noEC_state.measure(0);
    noEC_state.measure(1);
    
    float noEC_fidelity = noEC_state.calculateFidelity(2, reference, 0);
    system.io.print("- 无量子纠错的保真度: " + noEC_fidelity);
    system.io.print("- 量子纠错带来的保真度提升: " + (fidelity - noEC_fidelity));
    
    return state;
}

/**
 * 量子隐形传态网络实现
 * 通过量子网络实现长距离量子隐形传态
 */
function teleportation_network() {
    system.io.print("\n=== 量子隐形传态网络 ===\n");
    
    // 假设我们有一个5节点的量子网络 (节点编号0-4)
    // 我们希望从节点0传送量子状态到节点4
    system.io.print("创建5节点量子网络 (0→1→2→3→4)");
    
    // 每个相邻节点之间共享一个纠缠对
    // 总共需要7个量子比特:
    // - 0: 待传送的状态
    // - 1-2: 节点0-1之间的纠缠对
    // - 2-3: 节点1-2之间的纠缠对
    // - 3-4: 节点2-3之间的纠缠对
    // - 4-5: 节点3-4之间的纠缠对
    QuantumState state = new QuantumState(11);
    
    // 准备要传送的状态
    float theta = math.PI / 3;
    float phi = math.PI / 5;
    state.applyRY(0, theta);
    state.applyRZ(0, phi);
    
    system.io.print("初始状态准备完成 (节点0, 量子比特0)");
    system.io.print(state.qubitToString(0));
    
    // 准备网络中的纠缠对
    system.io.print("\n准备网络中的纠缠对:");
    
    // 节点0-1的纠缠对 (量子比特1-2)
    state.applyH(1);
    state.applyCNOT(1, 2);
    system.io.print("- 节点0-1之间的纠缠对准备完成 (量子比特1-2)");
    
    // 节点1-2的纠缠对 (量子比特3-4)
    state.applyH(3);
    state.applyCNOT(3, 4);
    system.io.print("- 节点1-2之间的纠缠对准备完成 (量子比特3-4)");
    
    // 节点2-3的纠缠对 (量子比特5-6)
    state.applyH(5);
    state.applyCNOT(5, 6);
    system.io.print("- 节点2-3之间的纠缠对准备完成 (量子比特5-6)");
    
    // 节点3-4的纠缠对 (量子比特7-8)
    state.applyH(7);
    state.applyCNOT(7, 8);
    system.io.print("- 节点3-4之间的纠缠对准备完成 (量子比特7-8)");
    
    // 执行量子隐形传态链
    system.io.print("\n执行量子隐形传态链:");
    
    // 第一次传送: 从节点0到节点1 (0→2)
    system.io.print("\n1. 从节点0到节点1传送 (量子比特0→2)");
    state.applyCNOT(0, 1);
    state.applyH(0);
    int m0 = state.measure(0);
    int m1 = state.measure(1);
    
    system.io.print("- 测量结果: m0=" + m0 + ", m1=" + m1);
    
    if (m1 == 1) state.applyX(2);
    if (m0 == 1) state.applyZ(2);
    
    // 第二次传送: 从节点1到节点2 (2→4)
    system.io.print("\n2. 从节点1到节点2传送 (量子比特2→4)");
    state.applyCNOT(2, 3);
    state.applyH(2);
    int m2 = state.measure(2);
    int m3 = state.measure(3);
    
    system.io.print("- 测量结果: m2=" + m2 + ", m3=" + m3);
    
    if (m3 == 1) state.applyX(4);
    if (m2 == 1) state.applyZ(4);
    
    // 第三次传送: 从节点2到节点3 (4→6)
    system.io.print("\n3. 从节点2到节点3传送 (量子比特4→6)");
    state.applyCNOT(4, 5);
    state.applyH(4);
    int m4 = state.measure(4);
    int m5 = state.measure(5);
    
    system.io.print("- 测量结果: m4=" + m4 + ", m5=" + m5);
    
    if (m5 == 1) state.applyX(6);
    if (m4 == 1) state.applyZ(6);
    
    // 第四次传送: 从节点3到节点4 (6→8)
    system.io.print("\n4. 从节点3到节点4传送 (量子比特6→8)");
    state.applyCNOT(6, 7);
    state.applyH(6);
    int m6 = state.measure(6);
    int m7 = state.measure(7);
    
    system.io.print("- 测量结果: m6=" + m6 + ", m7=" + m7);
    
    if (m7 == 1) state.applyX(8);
    if (m6 == 1) state.applyZ(8);
    
    // 打印最终结果
    system.io.print("\n最终传送结果 (节点4, 量子比特8):");
    system.io.print(state.qubitToString(8));
    
    // 验证传送质量
    QuantumState reference = new QuantumState(1);
    reference.applyRY(0, theta);
    reference.applyRZ(0, phi);
    
    float fidelity = state.calculateFidelity(8, reference, 0);
    system.io.print("\n通过网络传送后的保真度: " + fidelity);
    
    // 说明: 理论上每一步隐形传态都是完美的，但在实际中每一步都会累积误差
    if (fidelity > 0.95) {
        system.io.print("网络传送成功! 经过" + 4 + "个节点后状态依然保持良好");
    } else {
        system.io.print("网络传送质量下降，可能需要添加量子纠错");
    }
    
    // 计算中继效率
    system.io.print("\n量子中继效率分析:");
    system.io.print("- 总传送距离: 4跳");
    system.io.print("- 每跳平均保真度损失: " + ((1.0 - fidelity) / 4.0));
    system.io.print("- 纠缠资源消耗: 4对Bell态");
    
    return state;
}

/**
 * 主函数
 */
function main() {
    system.io.print("===== QEntL量子隐形传态示例 =====\n");
    
    // 运行基本量子隐形传态演示
    basic_teleportation();
    
    // 运行多量子比特隐形传态
    multi_qubit_teleportation();
    
    // 噪声环境下的量子隐形传态
    noisy_teleportation();
    
    // 使用量子纠错增强的量子隐形传态
    error_corrected_teleportation();
    
    // 量子隐形传态网络演示
    teleportation_network();
    
    system.io.print("\n===== 量子隐形传态示例完成 =====");
    return 0;
} 