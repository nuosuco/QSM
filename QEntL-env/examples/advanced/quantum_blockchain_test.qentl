/**
 * @file quantum_blockchain_test.qentl
 * @brief 量子区块链和智能合约测试示例
 * @author Claude
 * @version 1.0
 * @date 2024-06-03
 */

// 引入相关模块
import quantum.state;
import quantum.entanglement;
import runtime.blockchain;
import runtime.contract;

/**
 * @brief 测试量子区块链的基本功能
 */
function test_quantum_blockchain() {
    print("============ 量子区块链基本功能测试 ============");
    
    // 创建量子区块链
    print("创建量子区块链...");
    let chain = blockchain_create(3, "这是创世区块数据");
    print("区块链创建成功！");
    
    // 创建测试交易
    print("\n创建交易...");
    let tx1 = transaction_create(TRANSACTION_TYPE_NORMAL, "Alice", "Bob", 10, "交易1", 4);
    let tx2 = transaction_create(TRANSACTION_TYPE_QUANTUM_STATE, "Bob", "Charlie", 5, "交易2", 4);
    
    // 创建量子状态作为交易数据
    print("\n创建量子态交易...");
    let qubit = quantum_state_create(1);
    quantum_state_hadamard(qubit, 0);  // 创建叠加态
    let tx3 = transaction_create(TRANSACTION_TYPE_QUANTUM_STATE, "Charlie", "Alice", 7, qubit, 0);
    
    // 添加交易到区块链
    print("\n添加交易到区块链...");
    blockchain_add_transaction(chain, tx1);
    blockchain_add_transaction(chain, tx2);
    blockchain_add_transaction(chain, tx3);
    
    // 挖矿生成新区块
    print("\n挖掘新区块...");
    let new_block = blockchain_mine_block(chain, "Miner1");
    print("新区块已挖掘完成！");
    print("区块哈希: ", new_block.header.quantum_hash);
    
    // 检验区块链
    print("\n验证区块链完整性...");
    let is_valid = blockchain_verify_consistency(chain);
    print("区块链验证结果: ", is_valid ? "有效" : "无效");
    
    // 计算区块链熵
    print("\n计算区块链熵值...");
    let entropy = blockchain_calculate_entropy(chain);
    print("区块链熵值: ", entropy);
    
    // 导出区块链
    print("\n导出区块链到文件...");
    blockchain_export(chain, "blockchain_export.txt");
    
    // 清理资源
    print("\n清理资源...");
    transaction_destroy(tx1);
    transaction_destroy(tx2);
    transaction_destroy(tx3);
    quantum_state_destroy(qubit);
    blockchain_destroy(chain);
    
    print("测试完成\n");
}

/**
 * @brief 测试量子智能合约的基本功能
 */
function test_quantum_contracts() {
    print("============ 量子智能合约功能测试 ============");
    
    // 创建合约管理器
    print("创建智能合约管理器...");
    let manager = contract_manager_create();
    
    // 创建示例字节码（这里使用简单字符串模拟）
    let bytecode = "quantum contract bytecode example";
    
    // 创建不同类型的合约
    print("\n创建基本合约...");
    let basic_contract = contract_create(
        manager, 
        "Alice", 
        CONTRACT_TYPE_BASIC, 
        bytecode, 
        strlen(bytecode)
    );
    
    print("\n创建量子合约...");
    let quantum_bytecode = "H 0; CNOT 0 1; MEASURE 0; MEASURE 1";
    let quantum_contract = contract_create(
        manager, 
        "Bob", 
        CONTRACT_TYPE_QUANTUM, 
        quantum_bytecode, 
        strlen(quantum_bytecode)
    );
    
    // 查看合约信息
    print("\n合约信息：");
    let info_buffer = new char[1024];
    contract_get_info_string(basic_contract, info_buffer, 1024);
    print(info_buffer);
    
    print("\n量子合约信息：");
    contract_get_info_string(quantum_contract, info_buffer, 1024);
    print(info_buffer);
    
    // 准备合约参数
    print("\n准备执行合约参数...");
    let params = new ContractParameter[3];
    params[0] = contract_param_create_int("值", 42);
    params[1] = contract_param_create_string("消息", "Hello Quantum World");
    
    // 创建量子参数
    let q_param = quantum_state_create(2);
    quantum_state_hadamard(q_param, 0);
    quantum_state_cnot(q_param, 0, 1);
    params[2] = contract_param_create_quantum("纠缠态", q_param);
    
    // 执行合约
    print("\n执行量子合约...");
    let result = new ContractResult;
    contract_execute(manager, quantum_contract, "main", params, 3, result);
    
    print("执行结果: ", result.success ? "成功" : "失败");
    print("结果消息: ", result.message);
    
    // 创建区块链并部署合约
    print("\n创建区块链并部署合约...");
    let chain = blockchain_create(2, "合约测试用区块链");
    contract_deploy_to_blockchain(manager, chain, quantum_contract);
    
    // 生成报告
    print("\n生成合约执行报告...");
    contract_generate_report(manager, "contract_report.txt");
    
    // 清理资源
    print("\n清理资源...");
    contract_param_free(&params[0]);
    contract_param_free(&params[1]);
    contract_param_free(&params[2]);
    contract_result_free(result);
    delete[] params;
    delete[] info_buffer;
    quantum_state_destroy(q_param);
    contract_manager_destroy(manager);
    blockchain_destroy(chain);
    
    print("测试完成\n");
}

/**
 * @brief 测试量子区块链上的纠缠特性
 */
function test_quantum_entanglement_in_blockchain() {
    print("============ 量子区块链纠缠特性测试 ============");
    
    // 创建量子区块链
    print("创建区块链...");
    let chain = blockchain_create(2, "纠缠测试区块链");
    
    // 创建纠缠量子态
    print("\n创建纠缠量子态...");
    let bell_state = quantum_state_create(2);
    quantum_state_hadamard(bell_state, 0);
    quantum_state_cnot(bell_state, 0, 1);
    print("Bell态已创建");
    
    // 在交易中使用纠缠态
    print("\n创建纠缠交易...");
    let tx = transaction_create(
        TRANSACTION_TYPE_ENTANGLEMENT, 
        "Alice", 
        "Bob", 
        0, 
        bell_state, 
        0
    );
    
    // 添加交易并挖矿
    print("\n将纠缠交易添加到区块链...");
    blockchain_add_transaction(chain, tx);
    let block = blockchain_mine_block(chain, "Miner1");
    
    // 观察纠缠效应
    print("\n观察区块链中的纠缠效应...");
    print("区块状态:");
    quantum_state_print(block.block_state);
    
    // 测量第一个量子比特的影响
    print("\n测量交易中的量子态第一个比特...");
    int result = quantum_state_measure(bell_state, 0);
    print("测量结果: ", result);
    
    // 观察区块链状态的变化
    print("\n观察测量后的区块链状态:");
    quantum_state_print(block.block_state);
    
    // 验证纠缠
    print("\n验证纠缠影响...");
    // 在实际系统中，这里会有复杂的纠缠验证逻辑
    print("纠缠验证完成");
    
    // 清理资源
    print("\n清理资源...");
    transaction_destroy(tx);
    quantum_state_destroy(bell_state);
    blockchain_destroy(chain);
    
    print("测试完成\n");
}

/**
 * @brief 测试量子区块链共识机制
 */
function test_quantum_consensus() {
    print("============ 量子共识机制测试 ============");
    
    // 创建区块链网络
    print("创建区块链网络...");
    let chain = blockchain_create(2, "共识测试区块链");
    
    // 创建共识节点
    print("\n创建共识节点...");
    let nodes = new quantum_consensus_node_t*[3];
    nodes[0] = quantum_consensus_node_create("Node1", 1, 1);  // 验证+挖矿
    nodes[1] = quantum_consensus_node_create("Node2", 1, 0);  // 只验证
    nodes[2] = quantum_consensus_node_create("Node3", 0, 1);  // 只挖矿
    
    // 节点加入网络
    print("\n节点加入网络...");
    for (let i = 0; i < 3; i++) {
        nodes[i].blockchain = chain;
        print("节点 ", nodes[i].node_id, " 已加入网络");
    }
    
    // 模拟交易
    print("\n创建测试交易...");
    let tx = transaction_create(TRANSACTION_TYPE_NORMAL, "Alice", "Bob", 30, "共识测试交易", 12);
    blockchain_add_transaction(chain, tx);
    
    // 模拟共识过程
    print("\n执行量子共识过程...");
    // 此处简化了实际的共识过程
    print("节点正在达成共识...");
    
    // 模拟挖矿节点竞争
    print("\n模拟挖矿竞争...");
    let winning_node = 2;  // 假设Node3赢得竞争
    print("节点 ", nodes[winning_node].node_id, " 赢得挖矿竞争");
    
    // 产生新区块
    let block = blockchain_mine_block(chain, nodes[winning_node].node_id);
    print("新区块已生成，哈希: ", block.header.quantum_hash);
    
    // 验证节点确认
    print("\n验证节点确认新区块...");
    let confirmations = 0;
    for (let i = 0; i < 3; i++) {
        if (nodes[i].is_validator) {
            print("节点 ", nodes[i].node_id, " 确认区块有效");
            confirmations++;
        }
    }
    print("总确认数: ", confirmations);
    
    // 清理资源
    print("\n清理资源...");
    for (let i = 0; i < 3; i++) {
        quantum_consensus_node_destroy(nodes[i]);
    }
    delete[] nodes;
    transaction_destroy(tx);
    blockchain_destroy(chain);
    
    print("测试完成\n");
}

/**
 * @brief 主函数
 */
function main() {
    print("===== 量子区块链与智能合约测试开始 =====\n");
    
    // 执行各个测试
    test_quantum_blockchain();
    print("\n");
    test_quantum_contracts();
    print("\n");
    test_quantum_entanglement_in_blockchain();
    print("\n");
    test_quantum_consensus();
    
    print("\n===== 量子区块链与智能合约测试完成 =====");
    return 0;
} 