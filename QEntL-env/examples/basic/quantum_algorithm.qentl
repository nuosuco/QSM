// ==========================================
// QEntL 量子算法示例
// 演示基本量子算法的实现和应用
// 
// 作者: QEntL核心开发团队
// 日期: 2024-05-18
// 版本: 1.0
// ==========================================

import quantum.core;
import quantum.algorithm;
import quantum.state;
import system.io;
import system.math;

/**
 * Grover量子搜索算法实现
 * 演示如何使用Grover算法在无序数据中搜索特定元素
 * @param n 量子比特数量
 * @param target_index 目标索引（要搜索的元素索引）
 */
function grover_search(int n, int target_index) {
    system.io.print("=== Grover量子搜索算法 ===");
    system.io.print("搜索空间大小: 2^" + n + " = " + (1 << n));
    system.io.print("目标索引: " + target_index);
    
    // 创建n量子比特的寄存器
    QuantumState register = new QuantumState(n);
    
    // 步骤1: 初始化为均匀叠加态
    system.io.print("\n步骤1: 初始化均匀叠加态");
    for (int i = 0; i < n; i++) {
        register.apply_gate("H", i);
    }
    
    // 计算所需迭代次数
    int iterations = floor(system.math.PI / 4 * sqrt(1 << n));
    system.io.print("\n最优迭代次数: " + iterations);
    
    // 步骤2: 应用Grover迭代
    for (int iter = 0; iter < iterations; iter++) {
        system.io.print("\n执行Grover迭代 #" + (iter + 1));
        
        // 阶段1: 应用Oracle（标记目标状态）
        system.io.print("- 应用Oracle (标记目标状态)");
        // 创建目标状态的Oracle
        register.apply_oracle("PHASE_FLIP", target_index);
        
        // 阶段2: 振幅放大
        system.io.print("- 应用振幅放大");
        
        // 2.1: 对所有量子比特应用H门
        for (int i = 0; i < n; i++) {
            register.apply_gate("H", i);
        }
        
        // 2.2: 应用条件相位反转（除|0⟩态外所有态反转相位）
        register.apply_oracle("PHASE_FLIP_ZERO");
        
        // 2.3: 再次应用H门
        for (int i = 0; i < n; i++) {
            register.apply_gate("H", i);
        }
    }
    
    // 显示最终状态
    system.io.print("\n量子态最终概率分布:");
    for (int i = 0; i < (1 << n); i++) {
        float prob = register.probability_of_state(i);
        if (prob > 0.01) {
            system.io.print("|" + i.to_binary(n) + "⟩: " + prob);
        }
    }
    
    // 进行测量
    system.io.print("\n执行测量...");
    int measurements[1000];
    int counts[1 << n];
    
    for (int i = 0; i < 1 << n; i++) {
        counts[i] = 0;
    }
    
    for (int i = 0; i < 1000; i++) {
        QuantumState copy = register.clone();
        int result = copy.measure_all_to_int();
        measurements[i] = result;
        counts[result]++;
    }
    
    // 显示测量结果
    system.io.print("\n测量结果统计 (1000次测量):");
    for (int i = 0; i < (1 << n); i++) {
        if (counts[i] > 0) {
            system.io.print("|" + i.to_binary(n) + "⟩: " + counts[i] + " 次 (" + (counts[i] / 10.0) + "%)");
        }
    }
    
    // 检查算法成功率
    float success_rate = counts[target_index] / 1000.0;
    system.io.print("\n算法成功率: " + (success_rate * 100) + "%");
    
    return success_rate;
}

/**
 * 量子相位估计算法实现
 * 用于估计酉矩阵特征值的相位
 * @param precision 精度（使用的量子比特数量）
 * @param actual_phase 实际相位（用于验证）
 */
function quantum_phase_estimation(int precision, float actual_phase) {
    system.io.print("\n=== 量子相位估计算法 ===");
    system.io.print("精度位数: " + precision);
    system.io.print("实际相位值: " + actual_phase + " (约等于 " + 
                    (actual_phase * (1 << precision)) + "/" + (1 << precision) + ")");
    
    // 创建量子态：precision位相位寄存器 + 1位特征向量寄存器
    QuantumState qpe_state = new QuantumState(precision + 1);
    
    // 步骤1: 初始化特征向量寄存器
    // 对于简单演示，我们使用|1⟩作为特征向量
    system.io.print("\n步骤1: 初始化特征向量寄存器");
    qpe_state.apply_gate("X", precision);
    
    // 步骤2: 对相位寄存器应用H门，创建均匀叠加态
    system.io.print("步骤2: 创建相位寄存器的均匀叠加态");
    for (int i = 0; i < precision; i++) {
        qpe_state.apply_gate("H", i);
    }
    
    // 步骤3: 应用受控U操作
    // 我们模拟一个已知相位的U操作
    system.io.print("步骤3: 应用受控U操作");
    for (int i = 0; i < precision; i++) {
        // 应用2^i次受控U操作在控制位i上
        int repetitions = 1 << i;
        float phase_angle = 2 * system.math.PI * actual_phase * repetitions;
        
        system.io.print("- 对控制位 " + i + " 应用受控相位旋转 " + repetitions + " 次");
        qpe_state.apply_controlled_phase(i, precision, phase_angle);
    }
    
    // 步骤4: 应用逆量子傅里叶变换
    system.io.print("步骤4: 应用逆量子傅里叶变换");
    qpe_state.apply_inverse_qft(0, precision - 1);
    
    // 显示最终状态
    system.io.print("\n量子态最终概率分布:");
    for (int i = 0; i < (1 << precision); i++) {
        float prob = qpe_state.probability(i, precision, 1);
        if (prob > 0.01) {
            system.io.print("|" + i.to_binary(precision) + "⟩|1⟩: " + prob);
        }
    }
    
    // 测量相位寄存器
    system.io.print("\n测量相位寄存器...");
    int measurements[1000];
    int counts[1 << precision];
    
    for (int i = 0; i < (1 << precision); i++) {
        counts[i] = 0;
    }
    
    for (int i = 0; i < 1000; i++) {
        QuantumState copy = qpe_state.clone();
        int result = copy.measure_range_to_int(0, precision - 1);
        measurements[i] = result;
        counts[result]++;
    }
    
    // 显示测量结果
    system.io.print("\n测量结果统计 (1000次测量):");
    int max_count = 0;
    int max_result = 0;
    
    for (int i = 0; i < (1 << precision); i++) {
        if (counts[i] > 0) {
            system.io.print("|" + i.to_binary(precision) + "⟩: " + counts[i] + 
                            " 次 (" + (counts[i] / 10.0) + "%) - 相位估计值: " + 
                            (float(i) / (1 << precision)));
            
            if (counts[i] > max_count) {
                max_count = counts[i];
                max_result = i;
            }
        }
    }
    
    // 计算估计相位与实际相位的误差
    float estimated_phase = float(max_result) / (1 << precision);
    float phase_error = abs(estimated_phase - actual_phase);
    
    system.io.print("\n最常见测量结果: |" + max_result.to_binary(precision) + "⟩");
    system.io.print("估计相位值: " + estimated_phase + 
                    " (约等于 " + max_result + "/" + (1 << precision) + ")");
    system.io.print("相位估计误差: " + phase_error);
    system.io.print("相对误差: " + (phase_error / actual_phase * 100) + "%");
    
    return estimated_phase;
}

/**
 * Deutsch-Jozsa算法实现
 * 确定一个黑盒函数是常数函数还是平衡函数
 */
function deutsch_jozsa_algorithm() {
    system.io.print("\n=== Deutsch-Jozsa算法 ===");
    
    // 为简单起见，我们使用3个量子比特
    int n = 3;
    QuantumState dj_state = new QuantumState(n + 1);  // n个输入比特加1个输出比特
    
    system.io.print("使用 " + n + " 个输入量子比特");
    
    // 步骤1: 初始化 - 将输出比特设为|1⟩，其他设为|0⟩
    system.io.print("\n步骤1: 初始化量子态");
    dj_state.apply_gate("X", n);  // 输出比特设为|1⟩
    
    // 步骤2: 对所有量子比特应用H门
    system.io.print("步骤2: 对所有量子比特应用H门");
    for (int i = 0; i <= n; i++) {
        dj_state.apply_gate("H", i);
    }
    
    // 步骤3: 应用Oracle
    system.io.print("步骤3: 应用Oracle函数");
    
    // 这里我们模拟两种Oracle:
    // 1. 常数函数(总是返回0或1)
    // 2. 平衡函数(对一半输入返回0，另一半返回1)
    
    bool use_constant_oracle = false;  // 切换此值可以测试不同的Oracle
    
    if (use_constant_oracle) {
        system.io.print("使用常数函数Oracle (总是返回1)");
        dj_state.apply_gate("X", n);  // 翻转输出比特 (总是返回1的常数函数)
    } else {
        system.io.print("使用平衡函数Oracle (对一半输入返回0，一半返回1)");
        // 实现平衡函数: 如果输入比特中1的个数为奇数，则翻转输出
        for (int i = 0; i < n; i++) {
            dj_state.apply_gate("CNOT", i, n);
        }
    }
    
    // 步骤4: 对输入寄存器再次应用H门
    system.io.print("步骤4: 对输入寄存器应用H门");
    for (int i = 0; i < n; i++) {
        dj_state.apply_gate("H", i);
    }
    
    // 显示最终状态
    system.io.print("\n量子态最终概率分布:");
    for (int i = 0; i < (1 << (n+1)); i++) {
        float prob = dj_state.probability_of_state(i);
        if (prob > 0.01) {
            system.io.print("|" + i.to_binary(n+1) + "⟩: " + prob);
        }
    }
    
    // 测量输入寄存器
    system.io.print("\n测量输入寄存器...");
    int measurements[100];
    
    for (int i = 0; i < 100; i++) {
        QuantumState copy = dj_state.clone();
        int result = copy.measure_range_to_int(0, n-1);
        measurements[i] = result;
    }
    
    // 统计全0状态的测量结果
    int zero_count = 0;
    for (int i = 0; i < 100; i++) {
        if (measurements[i] == 0) {
            zero_count++;
        }
    }
    
    system.io.print("\n测量|0...0⟩状态的次数: " + zero_count + "/100");
    
    // 解释结果
    system.io.print("\n=== 算法结论 ===");
    if (zero_count > 90) {  // 允许一些误差
        system.io.print("Oracle是常数函数 (输入寄存器测量结果总是|0...0⟩)");
    } else {
        system.io.print("Oracle是平衡函数 (输入寄存器测量结果很少是|0...0⟩)");
    }
    
    return (zero_count > 90);
}

/**
 * 主函数
 */
function main() {
    system.io.print("===== QEntL量子算法示例 =====\n");
    
    // 运行Grover搜索算法示例
    // 使用3量子比特搜索目标索引5
    grover_search(3, 5);
    
    // 运行量子相位估计算法示例
    // 使用8位精度估计相位0.25 (1/4)
    quantum_phase_estimation(8, 0.25);
    
    // 运行Deutsch-Jozsa算法示例
    deutsch_jozsa_algorithm();
    
    system.io.print("\n===== 测试完成 =====");
    return 0;
} 